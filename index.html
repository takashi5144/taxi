<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="theme-color" content="#1a1a2e" />
  <meta name="description" content="タクシードライバー向けの売上サポートツール" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="manifest" href="./manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192.png" />
  <link rel="apple-touch-icon" href="./icons/icon-192.png" />
  <title>タクシー売上サポート v0.9.1</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="preconnect" href="https://maps.googleapis.com" />
  <link rel="preconnect" href="https://maps.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet" />
<style>
/* FILE: variables.css */
:root {
  /* カラーパレット */
  --color-primary: #1a73e8;
  --color-primary-dark: #1557b0;
  --color-primary-light: #4a90e2;
  --color-secondary: #f9a825;
  --color-secondary-dark: #c17900;
  --color-accent: #00c853;
  --color-danger: #e53935;
  --color-warning: #ff9800;

  /* 背景色 */
  --bg-dark: #1a1a2e;
  --bg-medium: #16213e;
  --bg-light: #0f3460;
  --bg-card: #1e2a4a;
  --bg-card-hover: #253252;
  --bg-secondary: #1e2a4a;
  --bg-tertiary: #253252;
  --bg-surface: #f5f5f5;

  /* テキスト色 */
  --text-primary: #ffffff;
  --text-secondary: #b0b8c8;
  --text-muted: #6c757d;
  --text-dark: #1a1a2e;

  /* フォント */
  --font-family: 'Noto Sans JP', -apple-system, BlinkMacSystemFont, sans-serif;
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-base: 1rem;
  --font-size-lg: 1.125rem;
  --font-size-xl: 1.5rem;
  --font-size-2xl: 2rem;

  /* スペーシング */
  --space-xs: 0.25rem;
  --space-sm: 0.5rem;
  --space-md: 1rem;
  --space-lg: 1.5rem;
  --space-xl: 2rem;
  --space-2xl: 3rem;

  /* レイアウト */
  --header-height: 56px;
  --sidebar-width: 240px;
  --bottom-nav-height: 64px;
  --border-radius: 12px;
  --border-radius-sm: 8px;

  /* シャドウ */
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.3);
  --shadow-lg: 0 8px 24px rgba(0,0,0,0.4);

  /* トランジション */
  --transition-fast: 150ms ease;
  --transition-normal: 250ms ease;
}

/* FILE: global.css */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  font-size: 16px;
  -webkit-text-size-adjust: 100%;
}

body {
  font-family: var(--font-family);
  background-color: var(--bg-dark);
  color: var(--text-primary);
  line-height: 1.6;
  min-height: 100vh;
  overflow-x: hidden;
  -webkit-font-smoothing: antialiased;
}

#root {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

a {
  color: var(--color-primary-light);
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* スクロールバー */
::-webkit-scrollbar {
  width: 6px;
}
::-webkit-scrollbar-track {
  background: var(--bg-medium);
}
::-webkit-scrollbar-thumb {
  background: var(--bg-light);
  border-radius: 3px;
}

/* ヘッダー */
.header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: var(--header-height);
  background: var(--bg-medium);
  border-bottom: 1px solid rgba(255,255,255,0.08);
  display: flex;
  align-items: center;
  padding: 0 var(--space-md);
  z-index: 1000;
  backdrop-filter: blur(10px);
}

.header__logo {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  font-weight: 700;
  font-size: var(--font-size-lg);
  color: var(--color-secondary);
  cursor: pointer;
}

.header__logo .material-icons-round {
  font-size: 28px;
}

.header__nav {
  display: none;
}

.header__nav-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  padding: var(--space-sm) var(--space-md);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  font-size: var(--font-size-sm);
  font-family: var(--font-family);
  transition: all var(--transition-fast);
  display: flex;
  align-items: center;
  gap: var(--space-xs);
}

.header__nav-btn:hover,
.header__nav-btn.active {
  background: rgba(255,255,255,0.08);
  color: var(--text-primary);
}

.header__nav-btn.active {
  color: var(--color-primary-light);
}

.header__menu-toggle {
  display: none;
  background: none;
  border: none;
  color: var(--text-primary);
  font-size: 24px;
  cursor: pointer;
  padding: var(--space-sm);
}

/* サイドバー */
.sidebar {
  position: fixed;
  top: var(--header-height);
  left: 0;
  width: var(--sidebar-width);
  height: calc(100vh - var(--header-height));
  background: var(--bg-medium);
  border-right: 1px solid rgba(255,255,255,0.06);
  padding: var(--space-md) 0;
  overflow-y: auto;
  z-index: 900;
  transition: transform var(--transition-normal);
}

.sidebar__section {
  padding: var(--space-sm) var(--space-md);
  margin-bottom: var(--space-sm);
}

.sidebar__section-title {
  font-size: var(--font-size-xs);
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: var(--space-sm);
  padding: 0 var(--space-sm);
}

.sidebar__item {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  padding: var(--space-sm) var(--space-md);
  border-radius: var(--border-radius-sm);
  color: var(--text-secondary);
  cursor: pointer;
  transition: all var(--transition-fast);
  font-size: var(--font-size-sm);
  border: none;
  background: none;
  width: 100%;
  text-align: left;
  font-family: var(--font-family);
}

.sidebar__item:hover {
  background: rgba(255,255,255,0.06);
  color: var(--text-primary);
}

.sidebar__item.active {
  background: rgba(26, 115, 232, 0.15);
  color: var(--color-primary-light);
}

.sidebar__item .material-icons-round {
  font-size: 20px;
}

/* メインコンテンツ */
.main-content {
  margin-top: var(--header-height);
  margin-left: var(--sidebar-width);
  padding: var(--space-lg);
  min-height: calc(100vh - var(--header-height));
  transition: margin-left var(--transition-normal);
}

/* ボトムナビ */
.bottom-nav {
  display: none;
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: var(--bottom-nav-height);
  background: var(--bg-medium);
  border-top: 1px solid rgba(255,255,255,0.08);
  z-index: 1000;
}

.bottom-nav__items {
  display: flex;
  justify-content: space-around;
  align-items: center;
  height: 100%;
  padding: 0 var(--space-sm);
}

.bottom-nav__item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  background: none;
  border: none;
  color: var(--text-muted);
  font-size: var(--font-size-xs);
  cursor: pointer;
  padding: var(--space-xs) var(--space-sm);
  border-radius: var(--border-radius-sm);
  transition: color var(--transition-fast);
  font-family: var(--font-family);
  min-width: 56px;
}

.bottom-nav__item .material-icons-round {
  font-size: 22px;
}

.bottom-nav__item.active {
  color: var(--color-primary-light);
}

.bottom-nav__item:hover {
  color: var(--text-primary);
}

/* カード */
.card {
  background: var(--bg-card);
  border: 1px solid rgba(255,255,255,0.06);
  border-radius: var(--border-radius);
  padding: var(--space-lg);
  transition: all var(--transition-fast);
}

.card:hover {
  background: var(--bg-card-hover);
  border-color: rgba(255,255,255,0.1);
}

.card__title {
  font-size: var(--font-size-lg);
  font-weight: 700;
  margin-bottom: var(--space-sm);
}

.card__subtitle {
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
  margin-bottom: var(--space-md);
}

/* ボタン */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-sm);
  padding: var(--space-sm) var(--space-lg);
  border: none;
  border-radius: var(--border-radius-sm);
  font-size: var(--font-size-sm);
  font-family: var(--font-family);
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-fast);
  white-space: nowrap;
}

.btn--primary {
  background: var(--color-primary);
  color: white;
}
.btn--primary:hover {
  background: var(--color-primary-dark);
}

.btn--secondary {
  background: rgba(255,255,255,0.08);
  color: var(--text-primary);
}
.btn--secondary:hover {
  background: rgba(255,255,255,0.14);
}

.btn--success {
  background: var(--color-accent);
  color: white;
}

.btn--danger {
  background: var(--color-danger);
  color: white;
}

.btn--icon {
  padding: var(--space-sm);
  border-radius: 50%;
}

.btn--ghost {
  background: transparent;
  color: var(--text-secondary);
}
.btn--ghost:hover {
  background: rgba(255,255,255,0.08);
}

/* グリッド */
.grid {
  display: grid;
  gap: var(--space-md);
}

.grid--2 { grid-template-columns: repeat(2, 1fr); }
.grid--3 { grid-template-columns: repeat(3, 1fr); }
.grid--4 { grid-template-columns: repeat(4, 1fr); }

/* ページタイトル */
.page-title {
  font-size: var(--font-size-xl);
  font-weight: 700;
  margin-bottom: var(--space-lg);
  display: flex;
  align-items: center;
  gap: var(--space-sm);
}

.page-title .material-icons-round {
  color: var(--color-secondary);
}

/* 地図コンテナ */
.map-container {
  width: 100%;
  height: 500px;
  border-radius: var(--border-radius);
  overflow: hidden;
  position: relative;
  background: var(--bg-card);
}

.map-container--fullscreen {
  position: fixed;
  top: var(--header-height);
  left: var(--sidebar-width);
  right: 0;
  bottom: 0;
  height: auto;
  border-radius: 0;
  z-index: 500;
}

/* GPS情報パネル */
.gps-panel {
  background: rgba(26, 26, 46, 0.95);
  backdrop-filter: blur(10px);
  border-radius: var(--border-radius-sm);
  padding: var(--space-md);
  margin-top: var(--space-md);
  border: 1px solid rgba(255,255,255,0.1);
}

.gps-panel__row {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  font-size: var(--font-size-sm);
}

.gps-panel__label {
  color: var(--text-muted);
  min-width: 60px;
}

.gps-panel__value {
  color: var(--color-accent);
  font-weight: 500;
  font-family: 'Courier New', monospace;
}

/* ステータスバッジ */
.badge {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 8px;
  border-radius: 20px;
  font-size: var(--font-size-xs);
  font-weight: 500;
}

.badge--success {
  background: rgba(0, 200, 83, 0.15);
  color: var(--color-accent);
}

.badge--warning {
  background: rgba(255, 152, 0, 0.15);
  color: var(--color-warning);
}

.badge--error {
  background: rgba(229, 57, 53, 0.15);
  color: var(--color-danger);
}

.badge--info {
  background: rgba(26, 115, 232, 0.15);
  color: var(--color-primary-light);
}

/* 開発ツール */
.dev-log-entry {
  display: flex;
  gap: var(--space-sm);
  padding: var(--space-sm) var(--space-md);
  border-bottom: 1px solid rgba(255,255,255,0.04);
  font-size: var(--font-size-sm);
  font-family: 'Courier New', monospace;
}

.dev-log-entry__time {
  color: var(--text-muted);
  white-space: nowrap;
}

.dev-log-entry__level {
  min-width: 50px;
  font-weight: 700;
}

.dev-log-entry__level--info { color: var(--color-primary-light); }
.dev-log-entry__level--warn { color: var(--color-warning); }
.dev-log-entry__level--error { color: var(--color-danger); }
.dev-log-entry__level--debug { color: var(--text-muted); }

.dev-log-entry__message {
  color: var(--text-secondary);
  word-break: break-all;
}

/* フォーム */
.form-group {
  margin-bottom: var(--space-md);
}

.form-label {
  display: block;
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
  margin-bottom: var(--space-xs);
}

.form-input {
  width: 100%;
  padding: var(--space-sm) var(--space-md);
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: var(--border-radius-sm);
  color: var(--text-primary);
  font-size: var(--font-size-base);
  font-family: var(--font-family);
  transition: border-color var(--transition-fast);
}

.form-input:focus {
  outline: none;
  border-color: var(--color-primary);
}

/* 統計カード */
.stat-card {
  text-align: center;
  padding: var(--space-lg);
}

.stat-card__value {
  font-size: var(--font-size-2xl);
  font-weight: 700;
  color: var(--color-secondary);
}

.stat-card__label {
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
  margin-top: var(--space-xs);
}

/* ローディング */
.loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: var(--space-2xl);
  gap: var(--space-md);
}

.loading__spinner {
  width: 40px;
  height: 40px;
  border: 3px solid rgba(255,255,255,0.1);
  border-top-color: var(--color-primary);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

@keyframes voicePulse {
  0% { box-shadow: 0 0 0 0 rgba(244,67,54,0.5); }
  70% { box-shadow: 0 0 0 10px rgba(244,67,54,0); }
  100% { box-shadow: 0 0 0 0 rgba(244,67,54,0); }
}

/* ファイルツリー */
.file-tree {
  font-family: 'Courier New', monospace;
  font-size: var(--font-size-sm);
  line-height: 1.8;
}

.file-tree__item {
  display: flex;
  align-items: center;
  gap: var(--space-xs);
  padding: 2px 0;
}

.file-tree__icon {
  font-size: 16px;
}

.file-tree__icon--folder { color: var(--color-secondary); }
.file-tree__icon--file { color: var(--text-muted); }
.file-tree__icon--react { color: #61dafb; }
.file-tree__icon--css { color: #264de4; }
.file-tree__icon--js { color: #f7df1e; }
.file-tree__icon--html { color: #e34c26; }
.file-tree__icon--md { color: var(--text-secondary); }

/* タブ */
.tabs {
  display: flex;
  gap: 2px;
  border-bottom: 1px solid rgba(255,255,255,0.08);
  margin-bottom: var(--space-lg);
}

.tab {
  padding: var(--space-sm) var(--space-lg);
  background: none;
  border: none;
  color: var(--text-muted);
  cursor: pointer;
  font-size: var(--font-size-sm);
  font-family: var(--font-family);
  border-bottom: 2px solid transparent;
  transition: all var(--transition-fast);
}

.tab:hover {
  color: var(--text-secondary);
}

.tab.active {
  color: var(--color-primary-light);
  border-bottom-color: var(--color-primary);
}

/* FILE: responsive.css */
/* タブレット */
@media (max-width: 1023px) {
  .sidebar {
    transform: translateX(-100%);
  }

  .sidebar.open {
    transform: translateX(0);
  }

  .main-content {
    margin-left: 0;
  }

  .map-container--fullscreen {
    left: 0;
  }

  .header__menu-toggle {
    display: block;
  }

  .header__nav {
    display: none;
  }

  .grid--3 { grid-template-columns: repeat(2, 1fr); }
  .grid--4 { grid-template-columns: repeat(2, 1fr); }
}

/* モバイル (Android) */
@media (max-width: 767px) {
  html {
    font-size: 14px;
  }

  .sidebar {
    width: 100%;
    transform: translateX(-100%);
  }

  .sidebar.open {
    transform: translateX(0);
  }

  .bottom-nav {
    display: block;
  }

  .main-content {
    margin-left: 0;
    padding: var(--space-md);
    padding-bottom: calc(var(--bottom-nav-height) + var(--space-md));
  }

  .map-container {
    height: 350px;
  }

  .map-container--fullscreen {
    left: 0;
    bottom: var(--bottom-nav-height);
  }

  .grid--2,
  .grid--3,
  .grid--4 {
    grid-template-columns: 1fr;
  }

  .page-title {
    font-size: var(--font-size-lg);
  }

  .card {
    padding: var(--space-md);
  }

  .gps-panel {
    padding: var(--space-sm);
  }

  .header__nav-btn span:not(.material-icons-round) {
    display: none;
  }

  .tabs {
    overflow-x: auto;
    white-space: nowrap;
    -webkit-overflow-scrolling: touch;
  }
}

/* 小型モバイル */
@media (max-width: 375px) {
  .bottom-nav__item {
    min-width: 48px;
    font-size: 10px;
  }

  .bottom-nav__item .material-icons-round {
    font-size: 20px;
  }
}

/* ランドスケープモード */
@media (max-height: 500px) and (orientation: landscape) {
  .header {
    height: 44px;
  }

  .main-content {
    margin-top: 44px;
  }

  .map-container {
    height: 250px;
  }
}

/* PC大画面 */
@media (min-width: 1440px) {
  .main-content {
    max-width: 1200px;
  }

  .grid--4 { grid-template-columns: repeat(4, 1fr); }
}

/* ダークモード対応（システム設定連動） */
@media (prefers-color-scheme: light) {
  /* 将来のライトモード対応用 */
}

/* タッチデバイス対応 */
@media (hover: none) {
  .card:hover {
    background: var(--bg-card);
    border-color: rgba(255,255,255,0.06);
  }

  .btn:active {
    transform: scale(0.97);
  }

  .sidebar__item:active {
    background: rgba(255,255,255,0.08);
  }
}

/* 印刷用 */
@media print {
  .header, .sidebar, .bottom-nav {
    display: none !important;
  }

  .main-content {
    margin: 0 !important;
    padding: 0 !important;
  }
}

</style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>

  <script type="text/javascript">

// ============================================================
// FILE: src/utils/constants.js
// ============================================================
(function() {
// constants.js - アプリケーション定数
//
// TaxiApp 名前空間を定義。全コンポーネント・フック・コンテキストは
// この名前空間に登録される。window直接割り当ては後方互換のためのエイリアス。
window.TaxiApp = window.TaxiApp || {
  components: {},  // UIコンポーネント
  pages: {},       // ページコンポーネント
  hooks: {},       // カスタムフック
  contexts: {},    // React Context
  utils: {},       // ユーティリティ
};

window.APP_CONSTANTS = {
  APP_NAME: 'タクシー売上サポート',
  VERSION: '0.9.4',

  // デフォルト地図設定（東京駅）
  DEFAULT_MAP_CENTER: { lat: 35.6812, lng: 139.7671 },
  DEFAULT_MAP_ZOOM: 15,

  // GPS設定
  GPS_OPTIONS: {
    enableHighAccuracy: true,
    timeout: 15000,
    maximumAge: 0,
  },

  // ルート定義
  ROUTES: {
    DASHBOARD: 'dashboard',
    MAP: 'map',
    REVENUE: 'revenue',
    RIVAL_RIDE: 'rival-ride',
    TRANSIT_INFO: 'transit-info',
    EVENTS: 'events',
    ANALYTICS: 'analytics',
    DATA_MANAGE: 'data-manage',
    SETTINGS: 'settings',
    DEV_TOOLS: 'dev',
    DEV_LOGS: 'dev-logs',
    DEV_STRUCTURE: 'dev-structure',
    DEV_API: 'dev-api',
  },

  // ナビゲーション項目
  NAV_ITEMS: [
    { id: 'dashboard', label: 'ダッシュボード', icon: 'dashboard' },
    { id: 'map', label: '地図', icon: 'map' },
    { id: 'revenue', label: '売上記録', icon: 'receipt_long' },
    { id: 'rival-ride', label: '他社乗車', icon: 'local_taxi' },
    { id: 'analytics', label: '分析', icon: 'analytics' },
    { id: 'data-manage', label: 'データ管理', icon: 'edit_note' },
    { id: 'settings', label: '設定', icon: 'settings' },
  ],

  // 情報ナビゲーション項目
  INFO_NAV_ITEMS: [
    { id: 'transit-info', label: '公共交通機関情報', icon: 'directions_transit' },
    { id: 'events', label: 'イベント', icon: 'event' },
  ],

  // ボトムナビ項目
  BOTTOM_NAV_ITEMS: [
    { id: 'dashboard', label: 'ホーム', icon: 'home' },
    { id: 'map', label: '地図', icon: 'map' },
    { id: 'revenue', label: '売上', icon: 'receipt_long' },
    { id: 'rival-ride', label: '他社', icon: 'local_taxi' },
    { id: 'analytics', label: '分析', icon: 'analytics' },
    { id: 'settings', label: '設定', icon: 'more_horiz' },
  ],

  // ログレベル
  LOG_LEVELS: {
    DEBUG: 'debug',
    INFO: 'info',
    WARN: 'warn',
    ERROR: 'error',
  },

  // localStorage キー
  STORAGE_KEYS: {
    API_KEY: 'taxi_app_google_maps_api_key',
    GEMINI_API_KEY: 'taxi_app_gemini_api_key',
    LOGS: 'taxi_app_logs',
    SETTINGS: 'taxi_app_settings',
    REVENUE_DATA: 'taxi_app_revenue',
    RIVAL_RIDES: 'taxi_app_rival_rides',
    EVENTS: 'taxi_app_events',
    SYNC_SECRET: 'taxi_app_sync_secret',
    TRANSIT_INFO: 'taxi_app_transit_info',
    NOTIFICATION_ENABLED: 'taxi_app_notification_enabled',
  },

  // サイト構造（開発者ツール用）
  SITE_STRUCTURE: {
    name: 'taxi-sales-support/',
    type: 'folder',
    children: [
      {
        name: 'src/',
        type: 'folder',
        children: [
          { name: 'main.jsx', type: 'react', desc: 'エントリーポイント' },
          { name: 'App.jsx', type: 'react', desc: 'ルートコンポーネント・ルーティング' },
          {
            name: 'components/',
            type: 'folder',
            children: [
              {
                name: 'Layout/',
                type: 'folder',
                children: [
                  { name: 'Header.jsx', type: 'react', desc: 'ヘッダーナビゲーション' },
                  { name: 'Sidebar.jsx', type: 'react', desc: 'PC用サイドバー' },
                  { name: 'BottomNav.jsx', type: 'react', desc: 'モバイル用ボトムナビ' },
                  { name: 'Layout.jsx', type: 'react', desc: 'レイアウトラッパー' },
                ],
              },
              {
                name: 'Map/',
                type: 'folder',
                children: [
                  { name: 'GoogleMap.jsx', type: 'react', desc: 'Google Maps本体' },
                  { name: 'GpsTracker.jsx', type: 'react', desc: 'GPS追跡パネル' },
                  { name: 'MapControls.jsx', type: 'react', desc: '地図操作コントロール' },
                ],
              },
              {
                name: 'common/',
                type: 'folder',
                children: [
                  { name: 'Button.jsx', type: 'react', desc: '汎用ボタン' },
                  { name: 'Card.jsx', type: 'react', desc: '汎用カード' },
                  { name: 'Loading.jsx', type: 'react', desc: 'ローディング表示' },
                  { name: 'ErrorBoundary.jsx', type: 'react', desc: 'エラーバウンダリ' },
                ],
              },
            ],
          },
          {
            name: 'pages/',
            type: 'folder',
            children: [
              { name: 'Dashboard.jsx', type: 'react', desc: 'ダッシュボード' },
              { name: 'MapView.jsx', type: 'react', desc: '地図ページ' },
              { name: 'Revenue.jsx', type: 'react', desc: '売上記録' },
              { name: 'Analytics.jsx', type: 'react', desc: '売上分析' },
              { name: 'TransitInfo.jsx', type: 'react', desc: '公共交通機関情報' },
              { name: 'Events.jsx', type: 'react', desc: 'イベント記録' },
              { name: 'DataManage.jsx', type: 'react', desc: 'データ管理（編集・削除）' },
              { name: 'Settings.jsx', type: 'react', desc: 'アプリ設定' },
              {
                name: 'dev/',
                type: 'folder',
                children: [
                  { name: 'DevTools.jsx', type: 'react', desc: '開発者ツールハブ' },
                  { name: 'Structure.jsx', type: 'react', desc: 'サイト構造ビューア' },
                  { name: 'Logs.jsx', type: 'react', desc: 'ログビューア' },
                  { name: 'ApiStatus.jsx', type: 'react', desc: 'API接続状態' },
                ],
              },
            ],
          },
          {
            name: 'context/',
            type: 'folder',
            children: [
              { name: 'AppContext.jsx', type: 'react', desc: 'グローバル状態管理' },
              { name: 'MapContext.jsx', type: 'react', desc: '地図状態管理' },
              { name: 'LogContext.jsx', type: 'react', desc: 'ログ管理' },
            ],
          },
          {
            name: 'hooks/',
            type: 'folder',
            children: [
              { name: 'useGeolocation.js', type: 'js', desc: 'GPS位置情報フック' },
              { name: 'useGoogleMaps.js', type: 'js', desc: 'Google Maps読み込みフック' },
              { name: 'useLogger.js', type: 'js', desc: 'ロガーフック' },
            ],
          },
          {
            name: 'utils/',
            type: 'folder',
            children: [
              { name: 'constants.js', type: 'js', desc: '定数定義・TaxiApp名前空間' },
              { name: 'logger.js', type: 'js', desc: 'ロガーユーティリティ' },
              { name: 'storage.js', type: 'js', desc: 'localStorage管理' },
              { name: 'dataService.js', type: 'js', desc: '売上データ処理・分析・CSV出力' },
              { name: 'geminiService.js', type: 'js', desc: 'Gemini AI API連携' },
            ],
          },
          {
            name: 'styles/',
            type: 'folder',
            children: [
              { name: 'variables.css', type: 'css', desc: 'CSS変数' },
              { name: 'global.css', type: 'css', desc: 'グローバルスタイル' },
              { name: 'responsive.css', type: 'css', desc: 'レスポンシブ対応' },
            ],
          },
        ],
      },
      {
        name: 'docs/',
        type: 'folder',
        children: [
          { name: 'ARCHITECTURE.md', type: 'md', desc: 'アーキテクチャ設計書' },
          { name: 'CHANGELOG.md', type: 'md', desc: '変更履歴' },
          { name: 'DEV_LOG.md', type: 'md', desc: '開発ログ' },
        ],
      },
      {
        name: 'public/',
        type: 'folder',
        children: [
          { name: 'manifest.json', type: 'file', desc: 'PWAマニフェスト' },
          { name: 'sw.js', type: 'js', desc: 'Service Worker（コピー元）' },
        ],
      },
      { name: 'index.html', type: 'html', desc: 'エントリーHTML' },
      { name: 'sw.js', type: 'js', desc: 'Service Worker（ルート配置）' },
      { name: 'package.json', type: 'file', desc: 'プロジェクト情報' },
    ],
  },
};

})();

// ============================================================
// FILE: src/utils/logger.js
// ============================================================
(function() {
// logger.js - アプリケーションロガー
window.AppLogger = (() => {
  const MAX_LOGS = 500;
  let logs = [];
  let listeners = [];

  function loadLogs() {
    try {
      const saved = localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.LOGS);
      if (saved) logs = JSON.parse(saved);
    } catch (e) {
      logs = [];
    }
  }

  function saveLogs() {
    try {
      localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.LOGS, JSON.stringify(logs.slice(-MAX_LOGS)));
    } catch (e) { /* ignore */ }
  }

  function notify() {
    listeners.forEach(fn => fn([...logs]));
  }

  function addLog(level, message, data = null) {
    const entry = {
      id: Date.now() + '_' + Math.random().toString(36).substr(2, 5),
      timestamp: new Date().toISOString(),
      level,
      message,
      data,
    };
    logs.push(entry);
    if (logs.length > MAX_LOGS) logs = logs.slice(-MAX_LOGS);
    saveLogs();
    notify();

    // コンソールにも出力
    const consoleFn = level === 'error' ? console.error
      : level === 'warn' ? console.warn
      : level === 'debug' ? console.debug
      : console.log;
    consoleFn(`[${level.toUpperCase()}] ${message}`, data || '');

    return entry;
  }

  loadLogs();

  return {
    debug: (msg, data) => addLog('debug', msg, data),
    info: (msg, data) => addLog('info', msg, data),
    warn: (msg, data) => addLog('warn', msg, data),
    error: (msg, data) => addLog('error', msg, data),
    getLogs: () => [...logs],
    clearLogs: () => { logs = []; saveLogs(); notify(); },
    subscribe: (fn) => { listeners.push(fn); return () => { listeners = listeners.filter(l => l !== fn); }; },
  };
})();

})();

// ============================================================
// FILE: src/utils/storage.js
// ============================================================
(function() {
// storage.js - localStorage管理
window.AppStorage = {
  get(key, defaultValue = null) {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue;
    } catch {
      return defaultValue;
    }
  },

  set(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value));
      return true;
    } catch {
      return false;
    }
  },

  remove(key) {
    try {
      localStorage.removeItem(key);
      return true;
    } catch {
      return false;
    }
  },

  getApiKey() {
    // APIキーはユーザーが設定画面から入力したもののみ使用
    // ハードコードされたキーは使用しない（セキュリティリスク）
    return this.get(APP_CONSTANTS.STORAGE_KEYS.API_KEY, '');
  },

  setApiKey(key) {
    return this.set(APP_CONSTANTS.STORAGE_KEYS.API_KEY, key);
  },

  getGeminiApiKey() {
    return this.get(APP_CONSTANTS.STORAGE_KEYS.GEMINI_API_KEY, '');
  },

  setGeminiApiKey(key) {
    return this.set(APP_CONSTANTS.STORAGE_KEYS.GEMINI_API_KEY, key);
  },

  getSettings() {
    return this.get(APP_CONSTANTS.STORAGE_KEYS.SETTINGS, {
      gpsAutoTrack: true,
      mapType: 'roadmap',
    });
  },

  setSettings(settings) {
    return this.set(APP_CONSTANTS.STORAGE_KEYS.SETTINGS, settings);
  },
};

})();

// ============================================================
// FILE: src/utils/holidays.js
// ============================================================
(function() {
// holidays.js - 日本の祝日判定ユーティリティ
// 固定祝日・ハッピーマンデー・春分/秋分の日・振替休日・国民の休日に対応

window.JapaneseHolidays = (() => {
  // 曜日名
  const DAY_NAMES = ['日', '月', '火', '水', '木', '金', '土'];

  // 曜日を取得
  function getDayOfWeek(dateStr) {
    const d = new Date(dateStr + 'T00:00:00');
    return DAY_NAMES[d.getDay()];
  }

  // 曜日インデックスを取得 (0=日, 6=土)
  function getDayIndex(dateStr) {
    return new Date(dateStr + 'T00:00:00').getDay();
  }

  // 春分の日を計算（1900-2099年対応）
  function getVernalEquinox(year) {
    if (year < 1900 || year > 2099) return 21;
    if (year <= 1979) return Math.floor(20.8357 + 0.242194 * (year - 1980) - Math.floor((year - 1983) / 4));
    if (year <= 2099) return Math.floor(20.8431 + 0.242194 * (year - 1980) - Math.floor((year - 1980) / 4));
    return 21;
  }

  // 秋分の日を計算（1900-2099年対応）
  function getAutumnalEquinox(year) {
    if (year < 1900 || year > 2099) return 23;
    if (year <= 1979) return Math.floor(23.2588 + 0.242194 * (year - 1980) - Math.floor((year - 1983) / 4));
    if (year <= 2099) return Math.floor(23.2488 + 0.242194 * (year - 1980) - Math.floor((year - 1980) / 4));
    return 23;
  }

  // 第N月曜日の日付を取得
  function getNthMonday(year, month, n) {
    const firstDay = new Date(year, month - 1, 1);
    let dayOfWeek = firstDay.getDay();
    let firstMonday = dayOfWeek <= 1 ? (1 + (1 - dayOfWeek)) : (1 + (8 - dayOfWeek));
    return firstMonday + (n - 1) * 7;
  }

  // その年の祝日一覧を生成（日付文字列 → 祝日名のMap）
  function getHolidaysForYear(year) {
    const holidays = new Map();
    const pad = (n) => String(n).padStart(2, '0');
    const key = (m, d) => `${year}-${pad(m)}-${pad(d)}`;

    // === 固定祝日 ===
    holidays.set(key(1, 1), '元日');
    holidays.set(key(2, 11), '建国記念の日');
    if (year >= 2020) holidays.set(key(2, 23), '天皇誕生日');
    else if (year >= 1989 && year <= 2018) holidays.set(key(12, 23), '天皇誕生日');
    holidays.set(key(4, 29), year >= 2007 ? '昭和の日' : 'みどりの日');
    holidays.set(key(5, 3), '憲法記念日');
    holidays.set(key(5, 4), year >= 2007 ? 'みどりの日' : '国民の休日');
    holidays.set(key(5, 5), 'こどもの日');
    if (year >= 2016) holidays.set(key(8, 11), '山の日');
    holidays.set(key(11, 3), '文化の日');
    holidays.set(key(11, 23), '勤労感謝の日');

    // === ハッピーマンデー ===
    if (year >= 2000) {
      holidays.set(key(1, getNthMonday(year, 1, 2)), '成人の日');
    } else {
      holidays.set(key(1, 15), '成人の日');
    }

    if (year >= 2003) {
      holidays.set(key(7, getNthMonday(year, 7, 3)), '海の日');
    } else if (year >= 1996) {
      holidays.set(key(7, 20), '海の日');
    }

    if (year >= 2003) {
      holidays.set(key(9, getNthMonday(year, 9, 3)), '敬老の日');
    } else if (year >= 1966) {
      holidays.set(key(9, 15), '敬老の日');
    }

    if (year >= 2000) {
      holidays.set(key(10, getNthMonday(year, 10, 2)), 'スポーツの日');
    } else {
      holidays.set(key(10, 10), '体育の日');
    }

    // === 春分の日・秋分の日 ===
    holidays.set(key(3, getVernalEquinox(year)), '春分の日');
    holidays.set(key(9, getAutumnalEquinox(year)), '秋分の日');

    // === 特例（オリンピック等） ===
    if (year === 2020) {
      holidays.delete(key(7, getNthMonday(year, 7, 3)));
      holidays.set(key(7, 23), '海の日');
      holidays.set(key(7, 24), 'スポーツの日');
      holidays.delete(key(10, getNthMonday(year, 10, 2)));
      holidays.delete(key(8, 11));
      holidays.set(key(8, 10), '山の日');
    }
    if (year === 2021) {
      holidays.delete(key(7, getNthMonday(year, 7, 3)));
      holidays.set(key(7, 22), '海の日');
      holidays.set(key(7, 23), 'スポーツの日');
      holidays.delete(key(10, getNthMonday(year, 10, 2)));
      holidays.delete(key(8, 11));
      holidays.set(key(8, 8), '山の日');
    }

    // === 振替休日 ===
    // 祝日が日曜の場合、翌月曜が振替休日
    const baseHolidays = new Map(holidays);
    for (const [dateStr] of baseHolidays) {
      const d = new Date(dateStr + 'T00:00:00');
      if (d.getDay() === 0) { // 日曜日
        let next = new Date(d);
        next.setDate(next.getDate() + 1);
        let nextStr = next.toISOString().split('T')[0];
        // 翌日も祝日なら更に翌日へ
        while (holidays.has(nextStr)) {
          next.setDate(next.getDate() + 1);
          nextStr = next.toISOString().split('T')[0];
        }
        holidays.set(nextStr, '振替休日');
      }
    }

    // === 国民の休日（祝日に挟まれた平日） ===
    const sortedDates = Array.from(holidays.keys()).sort();
    for (let i = 0; i < sortedDates.length - 1; i++) {
      const curr = new Date(sortedDates[i] + 'T00:00:00');
      const next = new Date(sortedDates[i + 1] + 'T00:00:00');
      const diff = (next - curr) / 86400000;
      if (diff === 2) {
        const between = new Date(curr);
        between.setDate(between.getDate() + 1);
        const betweenStr = between.toISOString().split('T')[0];
        if (!holidays.has(betweenStr) && between.getDay() !== 0) {
          holidays.set(betweenStr, '国民の休日');
        }
      }
    }

    return holidays;
  }

  // キャッシュ
  const _cache = {};

  // 指定日が祝日かチェック（祝日名を返す、祝日でなければnull）
  function getHolidayName(dateStr) {
    if (!dateStr) return null;
    const year = parseInt(dateStr.split('-')[0]);
    if (!_cache[year]) {
      _cache[year] = getHolidaysForYear(year);
    }
    return _cache[year].get(dateStr) || null;
  }

  // 日付情報をまとめて取得
  function getDateInfo(dateStr) {
    if (!dateStr) return { dayOfWeek: '', holiday: null, isHoliday: false, isSunday: false, isSaturday: false };
    const dayOfWeek = getDayOfWeek(dateStr);
    const dayIndex = getDayIndex(dateStr);
    const holiday = getHolidayName(dateStr);
    return {
      dayOfWeek,
      holiday,
      isHoliday: !!holiday,
      isSunday: dayIndex === 0,
      isSaturday: dayIndex === 6,
    };
  }

  return {
    getDayOfWeek,
    getHolidayName,
    getDateInfo,
    getHolidaysForYear,
  };
})();

})();

// ============================================================
// FILE: src/utils/notificationService.js
// ============================================================
(function() {
window.NotificationService = (() => {
  function isSupported() {
    return 'Notification' in window;
  }

  function getPermission() {
    return isSupported() ? Notification.permission : 'denied';
  }

  async function requestPermission() {
    if (!isSupported()) return 'denied';
    return await Notification.requestPermission();
  }

  function isEnabled() {
    return localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.NOTIFICATION_ENABLED) === 'true';
  }

  function setEnabled(val) {
    localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.NOTIFICATION_ENABLED, val ? 'true' : 'false');
  }

  function send(title, options = {}) {
    if (!isSupported() || !isEnabled() || getPermission() !== 'granted') return;
    try {
      new Notification(title, { icon: './icons/icon-192.png', ...options });
    } catch (e) {
      AppLogger.warn('通知送信失敗: ' + e.message);
    }
  }

  function sendTroubleAlert(text) {
    if (!text || !isEnabled()) return;
    const keywords = ['遅延', '運休', '事故', '見合わせ', '運転取りやめ', '不通'];
    const hasAlert = keywords.some(kw => text.includes(kw));
    if (hasAlert) {
      send('交通情報アラート', { body: text.slice(0, 200), tag: 'trouble-alert' });
    }
  }

  return { isSupported, getPermission, requestPermission, isEnabled, setEnabled, send, sendTroubleAlert };
})();
})();

// ============================================================
// FILE: src/utils/lightgbmService.js
// ============================================================
(function() {
// LightGBM-style Gradient Boosting Decision Tree for demand prediction
// ブラウザ内で学習・推論を完結させる軽量GBDT実装。
// 特徴: histogram-style split finding, leaf-wise growth, L2 regularization
window.LightGBMService = (() => {
  const WEATHER_CODE = { '晴れ': 0, '曇り': 1, '雨': 2, '雪': 3, '': 4, '未設定': 4 };

  // ── 単一決定木の構築 ──
  // residuals を目的変数として、分散削減基準で分割
  function buildTree(X, residuals, maxDepth, minLeaf, lambda) {
    const nF = X[0].length;

    function leafVal(idx) {
      const g = idx.reduce((s, i) => s + residuals[i], 0);
      return -g / (idx.length + lambda);
    }

    function split(idx, depth) {
      if (depth >= maxDepth || idx.length < minLeaf * 2) {
        return { v: leafVal(idx) };
      }

      let bestGain = 0, bestF = -1, bestTh = 0, bestLI = null, bestRI = null;
      const pSum = idx.reduce((s, i) => s + residuals[i], 0);
      const pH = idx.length;
      const pScore = (pSum * pSum) / (pH + lambda);

      for (let f = 0; f < nF; f++) {
        const sorted = [...idx].sort((a, b) => X[a][f] - X[b][f]);
        let lSum = 0, lH = 0;
        for (let k = 0; k < sorted.length - 1; k++) {
          lSum += residuals[sorted[k]];
          lH++;
          if (lH < minLeaf || (pH - lH) < minLeaf) continue;
          if (X[sorted[k]][f] === X[sorted[k + 1]][f]) continue;

          const rSum = pSum - lSum;
          const rH = pH - lH;
          const gain = (lSum * lSum) / (lH + lambda) + (rSum * rSum) / (rH + lambda) - pScore;

          if (gain > bestGain) {
            bestGain = gain;
            bestF = f;
            bestTh = (X[sorted[k]][f] + X[sorted[k + 1]][f]) / 2;
            bestLI = sorted.slice(0, k + 1);
            bestRI = sorted.slice(k + 1);
          }
        }
      }

      if (bestF === -1) return { v: leafVal(idx) };
      return {
        f: bestF, th: bestTh,
        l: split(bestLI, depth + 1),
        r: split(bestRI, depth + 1),
      };
    }

    return split(Array.from({ length: X.length }, (_, i) => i), 0);
  }

  function predictOne(node, x) {
    if ('v' in node) return node.v;
    return x[node.f] <= node.th ? predictOne(node.l, x) : predictOne(node.r, x);
  }

  // ── 勾配ブースティング学習 ──
  function train(X, y, opts = {}) {
    const { nTrees = 50, maxDepth = 5, lr = 0.1, minLeaf = 2, lambda = 1.0 } = opts;
    const n = X.length;
    if (n < 3) return null;

    const base = y.reduce((s, v) => s + v, 0) / n;
    const preds = new Float64Array(n).fill(base);
    const trees = [];

    for (let t = 0; t < nTrees; t++) {
      const residuals = y.map((yi, i) => yi - preds[i]);
      const tree = buildTree(X, residuals, maxDepth, minLeaf, lambda);
      trees.push(tree);
      for (let i = 0; i < n; i++) {
        preds[i] += lr * predictOne(tree, X[i]);
      }
    }

    return { trees, base, lr };
  }

  function predict(model, x) {
    if (!model) return 0;
    let p = model.base;
    for (const t of model.trees) p += model.lr * predictOne(t, x);
    return Math.max(0, p);
  }

  // ── 学習データ準備 ──
  // 売上データ + 他社乗車データから特徴量を抽出
  // features: [lat, lng, hour, dayOfWeek, weatherCode]
  // target: demand weight (金額 or 固定値)
  function prepareData() {
    const entries = DataService.getEntries();
    const rivals = DataService.getRivalEntries();
    const X = [], y = [];

    entries.forEach(e => {
      const d = new Date(e.timestamp);
      const wc = WEATHER_CODE[e.weather] ?? 4;
      const hr = d.getHours();
      const dow = d.getDay();
      const w = e.amount || 1000;
      if (e.pickupCoords && e.pickupCoords.lat && e.pickupCoords.lng) {
        X.push([e.pickupCoords.lat, e.pickupCoords.lng, hr, dow, wc]);
        y.push(w);
      }
      if (e.dropoffCoords && e.dropoffCoords.lat && e.dropoffCoords.lng) {
        X.push([e.dropoffCoords.lat, e.dropoffCoords.lng, hr, dow, wc]);
        y.push(w);
      }
    });

    rivals.forEach(r => {
      if (!r.locationCoords || !r.locationCoords.lat || !r.locationCoords.lng) return;
      const hr = r.time ? parseInt(r.time.split(':')[0], 10) : 12;
      const dow = r.date ? new Date(r.date).getDay() : 0;
      const wc = WEATHER_CODE[r.weather] ?? 4;
      X.push([r.locationCoords.lat, r.locationCoords.lng, hr, dow, wc]);
      y.push(500);
    });

    if (X.length < 3) return { X, y };

    // 負例（需要ゼロのバックグラウンドサンプル）を追加
    const latMin = Math.min(...X.map(x => x[0])) - 0.015;
    const latMax = Math.max(...X.map(x => x[0])) + 0.015;
    const lngMin = Math.min(...X.map(x => x[1])) - 0.015;
    const lngMax = Math.max(...X.map(x => x[1])) + 0.015;
    const nBg = Math.max(X.length * 2, 40);
    // seeded random for reproducibility
    let seed = 42;
    const rand = () => { seed = (seed * 16807 + 0) % 2147483647; return seed / 2147483647; };
    for (let i = 0; i < nBg; i++) {
      X.push([
        latMin + rand() * (latMax - latMin),
        lngMin + rand() * (lngMax - lngMin),
        Math.floor(rand() * 24),
        Math.floor(rand() * 7),
        Math.floor(rand() * 5),
      ]);
      y.push(0);
    }

    return { X, y };
  }

  // ── モデル学習（公開API）──
  function trainModel(opts) {
    const { X, y } = prepareData();
    if (X.length < 5) return null;
    const model = train(X, y, opts);
    if (model) {
      AppLogger.info(`LightGBM学習完了: ${model.trees.length}本の木, 学習サンプル${X.length}件`);
    }
    return model;
  }

  // ── グリッド予測（ヒートマップ用）──
  // bounds: { north, south, east, west }
  // 現在の条件（hour, dow, weather）で需要スコアを予測
  function predictGrid(model, bounds, hour, dow, weather, step) {
    if (!model || !bounds) return [];
    const wc = WEATHER_CODE[weather] ?? 4;
    // ステップ幅をバウンド幅に応じて自動調整
    const latRange = bounds.north - bounds.south;
    const lngRange = bounds.east - bounds.west;
    const gridStep = step || Math.max(Math.min(latRange, lngRange) / 60, 0.001);
    const points = [];

    for (let lat = bounds.south; lat <= bounds.north; lat += gridStep) {
      for (let lng = bounds.west; lng <= bounds.east; lng += gridStep) {
        const score = predict(model, [lat, lng, hour, dow, wc]);
        if (score > 10) {
          points.push({ lat, lng, weight: score });
        }
      }
    }

    return points;
  }

  // ── モデル情報 ──
  function getModelInfo(model) {
    if (!model) return null;
    return {
      nTrees: model.trees.length,
      basePrediction: Math.round(model.base),
    };
  }

  // ── 単価予測モデル学習 ──
  // features: [lat, lng, hour, dayOfWeek, weatherCode]
  // target: 金額（¥）
  function preparePriceData() {
    const entries = DataService.getEntries();
    const X = [], y = [];

    entries.forEach(e => {
      if (!e.pickupCoords || !e.pickupCoords.lat || !e.pickupCoords.lng) return;
      if (!e.amount || e.amount <= 0) return;
      const d = new Date(e.timestamp);
      const wc = WEATHER_CODE[e.weather] ?? 4;
      const hr = e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : d.getHours();
      const dow = d.getDay();
      X.push([e.pickupCoords.lat, e.pickupCoords.lng, hr, dow, wc]);
      y.push(e.amount);
    });

    return { X, y };
  }

  function trainPriceModel(opts) {
    const { X, y } = preparePriceData();
    if (X.length < 5) return null;
    const model = train(X, y, { nTrees: 40, maxDepth: 4, lr: 0.1, minLeaf: 2, lambda: 1.0, ...opts });
    if (model) {
      AppLogger.info(`単価予測モデル学習完了: ${model.trees.length}本の木, 学習サンプル${X.length}件`);
    }
    return model;
  }

  // ── 単価予測グリッド ──
  function predictPriceGrid(model, bounds, hour, dow, weather, step) {
    if (!model || !bounds) return [];
    const wc = WEATHER_CODE[weather] ?? 4;
    const latRange = bounds.north - bounds.south;
    const lngRange = bounds.east - bounds.west;
    const gridStep = step || Math.max(Math.min(latRange, lngRange) / 40, 0.002);
    const points = [];

    for (let lat = bounds.south; lat <= bounds.north; lat += gridStep) {
      for (let lng = bounds.west; lng <= bounds.east; lng += gridStep) {
        const price = predict(model, [lat, lng, hour, dow, wc]);
        if (price > 100) {
          const tier = price <= 1000 ? 'short' : price <= 1999 ? 'mid' : 'long';
          points.push({ lat, lng, price: Math.round(price), tier });
        }
      }
    }

    return points;
  }

  return { trainModel, trainPriceModel, predict, predictGrid, predictPriceGrid, getModelInfo, WEATHER_CODE };
})();
})();

// ============================================================
// FILE: src/utils/dataService.js
// ============================================================
(function() {
// dataService.js - データ処理層（ビジネスロジック）
//
// 売上データの集計・分析・エクスポートを一元管理するサービス層。
// Dashboard, Analytics, Revenue の全ページがこのサービスを通じてデータにアクセスする。

window.DataService = (() => {
  // ============================================================
  // データ取得
  // ============================================================
  function getEntries() {
    try {
      const saved = localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.REVENUE_DATA);
      return saved ? JSON.parse(saved) : [];
    } catch {
      return [];
    }
  }

  function saveEntries(entries) {
    try {
      localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.REVENUE_DATA, JSON.stringify(entries));
      return true;
    } catch (e) {
      AppLogger.error('売上データの保存に失敗しました', e.message);
      return false;
    }
  }

  // ============================================================
  // ファイル保存・復元（売上データフォルダ）
  // ============================================================
  let _dirHandle = null; // File System Access API用

  // ── IndexedDB でフォルダハンドルを永続化 ──
  const _DB_NAME = 'taxi_app_fs';
  const _DB_STORE = 'handles';
  const _DB_KEY = 'saveDir';

  function _openHandleDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(_DB_NAME, 1);
      req.onupgradeneeded = () => req.result.createObjectStore(_DB_STORE);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function _persistHandle(handle) {
    try {
      const db = await _openHandleDB();
      const tx = db.transaction(_DB_STORE, 'readwrite');
      tx.objectStore(_DB_STORE).put(handle, _DB_KEY);
      await new Promise((r, j) => { tx.oncomplete = r; tx.onerror = j; });
      db.close();
    } catch (e) {
      AppLogger.warn('ハンドル永続化失敗: ' + e.message);
    }
  }

  async function _restoreHandle() {
    try {
      const db = await _openHandleDB();
      const tx = db.transaction(_DB_STORE, 'readonly');
      const req = tx.objectStore(_DB_STORE).get(_DB_KEY);
      const handle = await new Promise((r, j) => { req.onsuccess = () => r(req.result); req.onerror = j; });
      db.close();
      if (handle) {
        _dirHandle = handle;
        AppLogger.info('保存先フォルダを自動復元: ' + handle.name);
      }
    } catch (e) {
      AppLogger.warn('ハンドル復元失敗: ' + e.message);
    }
  }

  // 起動時に自動復元（Promiseを保持し、保存時にawait）
  const _handleReady = _restoreHandle();

  // サブフォルダのハンドルを取得（なければ自動作成）
  async function _getSubFolder(subName) {
    if (!_dirHandle) return null;
    try {
      const perm = await _dirHandle.queryPermission({ mode: 'readwrite' });
      if (perm !== 'granted') {
        const req = await _dirHandle.requestPermission({ mode: 'readwrite' });
        if (req !== 'granted') return null;
      }
      return await _dirHandle.getDirectoryHandle(subName, { create: true });
    } catch (e) {
      AppLogger.warn(`サブフォルダ取得失敗 (${subName}): ` + e.message);
      return null;
    }
  }

  // File System Access APIでサブフォルダにJSONを直接保存
  async function _saveToSubFolder(subName, fileName, entries, version) {
    try {
      const subDir = await _getSubFolder(subName);
      if (!subDir) return false;
      const fileHandle = await subDir.getFileHandle(fileName, { create: true });
      const writable = await fileHandle.createWritable();
      const data = JSON.stringify({ version: version, exportedAt: new Date().toISOString(), count: entries.length, entries: entries }, null, 2);
      await writable.write(data);
      await writable.close();
      AppLogger.info(`ファイル保存完了: ${subName}/${fileName} (${entries.length}件)`);
      return true;
    } catch (e) {
      AppLogger.warn(`フォルダ保存失敗 (${subName}): ` + e.message);
      return false;
    }
  }

  // ダウンロード方式でJSON保存（フォールバック）
  function _downloadBackup(entries) {
    try {
      const dateStr = new Date().toISOString().split('T')[0];
      const data = JSON.stringify({ version: APP_CONSTANTS.VERSION, exportedAt: new Date().toISOString(), count: entries.length, entries: entries }, null, 2);
      const blob = new Blob([data], { type: 'application/json;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `売上記録_${dateStr}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      AppLogger.info(`バックアップダウンロード: ${entries.length}件`);
      return true;
    } catch (e) {
      AppLogger.warn('バックアップ失敗: ' + e.message);
      return false;
    }
  }

  function _downloadRivalBackup(entries) {
    try {
      const dateStr = new Date().toISOString().split('T')[0];
      const data = JSON.stringify({ version: APP_CONSTANTS.VERSION, exportedAt: new Date().toISOString(), count: entries.length, entries: entries }, null, 2);
      const blob = new Blob([data], { type: 'application/json;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `他社乗車記録_${dateStr}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      AppLogger.info(`他社乗車バックアップダウンロード: ${entries.length}件`);
      return true;
    } catch (e) {
      AppLogger.warn('他社乗車バックアップ失敗: ' + e.message);
      return false;
    }
  }

  // 売上記録の自動保存（サブフォルダ「売上記録」）
  async function autoSaveToFile() {
    await _handleReady;
    if (!_dirHandle) return;
    const entries = getEntries();
    if (entries.length === 0) return;
    const dateStr = new Date().toISOString().split('T')[0];
    await _saveToSubFolder('売上記録', `売上記録_${dateStr}.json`, entries, APP_CONSTANTS.VERSION);
  }

  // 他社乗車記録の自動保存（サブフォルダ「他社乗車」）
  async function autoSaveRivalToFile() {
    await _handleReady;
    if (!_dirHandle) return;
    const entries = getRivalEntries();
    if (entries.length === 0) return;
    const dateStr = new Date().toISOString().split('T')[0];
    await _saveToSubFolder('他社乗車', `他社乗車記録_${dateStr}.json`, entries, APP_CONSTANTS.VERSION);
  }

  // 手動JSON保存（ボタン押下時）— フォルダ未設定時はダウンロード
  async function manualSaveToFile() {
    await _handleReady;
    const entries = getEntries();
    if (entries.length === 0) return;
    if (_dirHandle) {
      const dateStr = new Date().toISOString().split('T')[0];
      const ok = await _saveToSubFolder('売上記録', `売上記録_${dateStr}.json`, entries, APP_CONSTANTS.VERSION);
      if (ok) return;
    }
    _downloadBackup(entries);
  }

  async function manualSaveRivalToFile() {
    await _handleReady;
    const entries = getRivalEntries();
    if (entries.length === 0) return;
    if (_dirHandle) {
      const dateStr = new Date().toISOString().split('T')[0];
      const ok = await _saveToSubFolder('他社乗車', `他社乗車記録_${dateStr}.json`, entries, APP_CONSTANTS.VERSION);
      if (ok) return;
    }
    _downloadRivalBackup(entries);
  }

  // 保存先フォルダを選択（File System Access API）
  async function selectSaveFolder() {
    if (!window.showDirectoryPicker) {
      return { success: false, message: 'このブラウザではフォルダ直接保存がサポートされていません。ダウンロード方式で保存します。' };
    }
    try {
      _dirHandle = await window.showDirectoryPicker({ id: 'taxi-save', mode: 'readwrite', startIn: 'documents' });
      await _persistHandle(_dirHandle);
      AppLogger.info('保存先フォルダを設定・永続化: ' + _dirHandle.name)
      return { success: true, folderName: _dirHandle.name };
    } catch (e) {
      if (e.name === 'AbortError') return { success: false, message: 'フォルダ選択がキャンセルされました' };
      return { success: false, message: 'フォルダ選択に失敗: ' + e.message };
    }
  }

  // JSONファイルから復元
  async function importFromFile() {
    return new Promise((resolve) => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) { resolve({ success: false, message: 'ファイルが選択されませんでした' }); return; }
        const reader = new FileReader();
        reader.onload = (ev) => {
          try {
            const data = JSON.parse(ev.target.result);
            let entries = [];
            if (Array.isArray(data)) {
              entries = data;
            } else if (data.entries && Array.isArray(data.entries)) {
              entries = data.entries;
            } else {
              resolve({ success: false, message: 'ファイル形式が正しくありません' }); return;
            }
            // 既存データとマージ（IDで重複排除）
            const existing = getEntries();
            const existingIds = new Set(existing.map(e => e.id));
            let newCount = 0;
            entries.forEach(entry => {
              if (!existingIds.has(entry.id) && entry.amount) {
                existing.push(entry);
                newCount++;
              }
            });
            existing.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            saveEntries(existing);
            AppLogger.info(`ファイルから復元: ${newCount}件追加 (合計${existing.length}件)`);
            resolve({ success: true, message: `${newCount}件の新しい記録を復元しました（合計${existing.length}件）` });
          } catch (err) {
            resolve({ success: false, message: 'ファイルの読み込みに失敗: ' + err.message });
          }
        };
        reader.readAsText(file);
      };
      input.click();
    });
  }

  // 保存フォルダが設定済みかどうか
  function hasSaveFolder() {
    return !!_dirHandle;
  }

  // ============================================================
  // クラウド同期（Vercel Blob Storage）
  // ============================================================
  function _getSyncSecret() {
    return (localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.SYNC_SECRET) || '').trim();
  }

  async function _syncToCloud(type, entries) {
    try {
      const secret = _getSyncSecret();
      const res = await fetch(`/api/data?type=${type}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(secret ? { 'Authorization': `Bearer ${secret}` } : {}),
        },
        body: JSON.stringify({
          version: APP_CONSTANTS.VERSION,
          syncedAt: new Date().toISOString(),
          count: entries.length,
          entries,
        }),
      });
      if (res.ok) {
        AppLogger.info(`クラウド同期完了: ${type} (${entries.length}件)`);
      } else {
        AppLogger.warn(`クラウド同期失敗: ${res.status}`);
      }
    } catch (e) {
      AppLogger.warn('クラウド同期エラー: ' + e.message);
    }
  }

  async function loadFromCloud(type) {
    try {
      const res = await fetch(`/api/data?type=${type}`, {
      });
      if (!res.ok) return null;
      const data = await res.json();
      return data.entries || [];
    } catch (e) {
      AppLogger.warn('クラウド読込エラー: ' + e.message);
      return null;
    }
  }

  async function syncFromCloud(type) {
    const cloudEntries = await loadFromCloud(type);
    if (!cloudEntries || cloudEntries.length === 0) return { merged: 0 };

    const local = type === 'revenue' ? getEntries() : getRivalEntries();
    const localIds = new Set(local.map(e => e.id));
    let merged = 0;
    cloudEntries.forEach(entry => {
      if (!localIds.has(entry.id)) {
        local.push(entry);
        merged++;
      }
    });
    if (merged > 0) {
      local.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      if (type === 'revenue') saveEntries(local);
      else saveRivalEntries(local);
    }
    return { merged, total: local.length };
  }

  async function autoSync() {
    try {
      const [r1, r2] = await Promise.all([
        syncFromCloud('revenue'),
        syncFromCloud('rival'),
      ]);
      const totalMerged = (r1.merged || 0) + (r2.merged || 0);
      if (totalMerged > 0) {
        AppLogger.info(`自動同期完了: 売上+${r1.merged}件, 他社+${r2.merged}件`);
      } else {
        AppLogger.debug('自動同期: 新規データなし');
      }
      return { revenue: r1, rival: r2 };
    } catch (e) {
      AppLogger.warn('自動同期エラー: ' + e.message);
      return null;
    }
  }

  // ============================================================
  // 日付ヘルパー
  // ============================================================
  function toDateStr(isoString) {
    return isoString ? isoString.split('T')[0] : '';
  }

  function toHour(isoString) {
    return isoString ? new Date(isoString).getHours() : 0;
  }

  function getDayOfWeek(isoString) {
    const days = ['日', '月', '火', '水', '木', '金', '土'];
    return days[new Date(isoString).getDay()];
  }

  function getDayOfWeekIndex(isoString) {
    return new Date(isoString).getDay();
  }

  function getWeekStart(date) {
    const d = new Date(date);
    const day = d.getDay();
    const diff = d.getDate() - day + (day === 0 ? -6 : 1);
    d.setDate(diff);
    return toDateStr(d.toISOString());
  }

  function getMonthStr(isoString) {
    const d = new Date(isoString);
    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
  }

  // ============================================================
  // 本日のサマリー（Dashboard用）
  // ============================================================
  function getTodaySummary() {
    const entries = getEntries();
    const today = toDateStr(new Date().toISOString());
    const todayEntries = entries.filter(e => toDateStr(e.timestamp) === today);

    const totalAmount = todayEntries.reduce((sum, e) => sum + (e.amount || 0), 0);
    const rideCount = todayEntries.length;
    const avgAmount = rideCount > 0 ? Math.round(totalAmount / rideCount) : 0;

    // 稼働時間の計算（最初の記録〜最後の記録）
    let workMinutes = 0;
    if (todayEntries.length >= 2) {
      const sorted = [...todayEntries].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      const first = new Date(sorted[0].timestamp);
      const last = new Date(sorted[sorted.length - 1].timestamp);
      workMinutes = Math.round((last - first) / 60000);
    }
    const workHours = Math.floor(workMinutes / 60);
    const workMins = workMinutes % 60;

    return {
      totalAmount,
      rideCount,
      avgAmount,
      workTime: `${workHours}h ${workMins}m`,
      workMinutes,
      entries: todayEntries,
    };
  }

  // ============================================================
  // 全期間サマリー
  // ============================================================
  function getOverallSummary() {
    const entries = getEntries();
    const totalAmount = entries.reduce((sum, e) => sum + (e.amount || 0), 0);
    const rideCount = entries.length;
    const avgAmount = rideCount > 0 ? Math.round(totalAmount / rideCount) : 0;

    // 日数計算
    const uniqueDays = new Set(entries.map(e => toDateStr(e.timestamp)));
    const activeDays = uniqueDays.size;
    const dailyAvg = activeDays > 0 ? Math.round(totalAmount / activeDays) : 0;

    return {
      totalAmount,
      rideCount,
      avgAmount,
      activeDays,
      dailyAvg,
    };
  }

  // ============================================================
  // 日別集計（Analytics用）
  // ============================================================
  function getDailyBreakdown(days = 30) {
    const entries = getEntries();
    const result = {};

    // 過去N日分の枠を作る
    for (let i = days - 1; i >= 0; i--) {
      const d = new Date();
      d.setDate(d.getDate() - i);
      const key = toDateStr(d.toISOString());
      result[key] = { date: key, amount: 0, count: 0 };
    }

    entries.forEach(e => {
      const key = toDateStr(e.timestamp);
      if (result[key]) {
        result[key].amount += e.amount || 0;
        result[key].count += 1;
      }
    });

    return Object.values(result);
  }

  // ============================================================
  // 曜日別集計（Analytics用）
  // ============================================================
  function getDayOfWeekBreakdown() {
    const entries = getEntries();
    const days = ['日', '月', '火', '水', '木', '金', '土'];
    const result = days.map((name, i) => ({ name, index: i, amount: 0, count: 0, avg: 0 }));

    entries.forEach(e => {
      const idx = getDayOfWeekIndex(e.timestamp);
      result[idx].amount += e.amount || 0;
      result[idx].count += 1;
    });

    result.forEach(d => {
      d.avg = d.count > 0 ? Math.round(d.amount / d.count) : 0;
    });

    return result;
  }

  // ============================================================
  // 時間帯別集計（Analytics用）
  // ============================================================
  function getHourlyBreakdown() {
    const entries = getEntries();
    const result = [];

    for (let h = 0; h < 24; h++) {
      result.push({ hour: h, label: `${h}時`, amount: 0, count: 0, avg: 0 });
    }

    entries.forEach(e => {
      const h = toHour(e.timestamp);
      result[h].amount += e.amount || 0;
      result[h].count += 1;
    });

    result.forEach(d => {
      d.avg = d.count > 0 ? Math.round(d.amount / d.count) : 0;
    });

    return result;
  }

  // ============================================================
  // エリア別集計（乗車地・降車地の頻度）
  // ============================================================
  function getAreaBreakdown() {
    const entries = getEntries();
    const pickups = {};
    const dropoffs = {};

    entries.forEach(e => {
      if (e.pickup) {
        pickups[e.pickup] = (pickups[e.pickup] || { name: e.pickup, count: 0, amount: 0 });
        pickups[e.pickup].count += 1;
        pickups[e.pickup].amount += e.amount || 0;
      }
      if (e.dropoff) {
        dropoffs[e.dropoff] = (dropoffs[e.dropoff] || { name: e.dropoff, count: 0, amount: 0 });
        dropoffs[e.dropoff].count += 1;
        dropoffs[e.dropoff].amount += e.amount || 0;
      }
    });

    return {
      pickups: Object.values(pickups).sort((a, b) => b.count - a.count).slice(0, 10),
      dropoffs: Object.values(dropoffs).sort((a, b) => b.count - a.count).slice(0, 10),
    };
  }

  // ============================================================
  // 天候別集計
  // ============================================================
  function getWeatherBreakdown() {
    const entries = getEntries();
    const weathers = ['晴れ', '曇り', '雨', '雪', '未設定'];
    const result = {};
    weathers.forEach(w => { result[w] = { name: w, amount: 0, count: 0, avg: 0 }; });

    entries.forEach(e => {
      const w = e.weather && weathers.includes(e.weather) ? e.weather : '未設定';
      result[w].amount += e.amount || 0;
      result[w].count += 1;
    });

    weathers.forEach(w => {
      result[w].avg = result[w].count > 0 ? Math.round(result[w].amount / result[w].count) : 0;
    });

    return weathers.map(w => result[w]);
  }

  // ============================================================
  // 配車方法別集計
  // ============================================================
  function getSourceBreakdown() {
    const entries = getEntries();
    const sources = ['Go', 'Uber', 'DIDI', '電話', '流し', '未設定'];
    const result = {};
    sources.forEach(s => { result[s] = { name: s, amount: 0, count: 0, avg: 0 }; });

    entries.forEach(e => {
      const s = e.source && sources.includes(e.source) ? e.source : '未設定';
      result[s].amount += e.amount || 0;
      result[s].count += 1;
    });

    sources.forEach(s => {
      result[s].avg = result[s].count > 0 ? Math.round(result[s].amount / result[s].count) : 0;
    });

    return sources.map(s => result[s]);
  }

  // ============================================================
  // 用途別集計
  // ============================================================
  function getPurposeBreakdown() {
    const entries = getEntries();
    const purposes = ['通勤', '通院', '買物', '観光', '出張', '送迎', '空港', '飲食', 'その他', '未設定'];
    const result = {};
    purposes.forEach(p => { result[p] = { name: p, amount: 0, count: 0, avg: 0 }; });

    entries.forEach(e => {
      const p = e.purpose && purposes.includes(e.purpose) ? e.purpose : '未設定';
      result[p].amount += e.amount || 0;
      result[p].count += 1;
    });

    purposes.forEach(p => {
      result[p].avg = result[p].count > 0 ? Math.round(result[p].amount / result[p].count) : 0;
    });

    return purposes.map(p => result[p]);
  }

  // ============================================================
  // エリア×時間帯クロス集計
  // ============================================================
  function getAreaTimeBreakdown() {
    const entries = getEntries();
    const areaMap = {};

    entries.forEach(e => {
      const area = e.pickup || '';
      if (!area) return;
      const hour = e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : toHour(e.timestamp);

      if (!areaMap[area]) {
        areaMap[area] = { area, hours: {}, totalCount: 0, totalAmount: 0 };
      }
      areaMap[area].totalCount += 1;
      areaMap[area].totalAmount += e.amount || 0;

      if (!areaMap[area].hours[hour]) {
        areaMap[area].hours[hour] = { hour, count: 0, amount: 0 };
      }
      areaMap[area].hours[hour].count += 1;
      areaMap[area].hours[hour].amount += e.amount || 0;
    });

    return Object.values(areaMap)
      .sort((a, b) => b.totalCount - a.totalCount)
      .slice(0, 10)
      .map(a => ({
        area: a.area,
        totalCount: a.totalCount,
        totalAmount: a.totalAmount,
        hours: Array.from({ length: 24 }, (_, h) => a.hours[h] || { hour: h, count: 0, amount: 0 }),
      }));
  }

  // ============================================================
  // 客単価分析
  // ============================================================
  function getUnitPriceAnalysis() {
    const entries = getEntries();
    const dayNames = ['日', '月', '火', '水', '木', '金', '土'];

    const byDow = {};
    dayNames.forEach(d => { byDow[d] = { name: d, total: 0, count: 0, avg: 0 }; });

    const byHour = {};
    for (let h = 0; h < 24; h++) { byHour[h] = { name: h + '時', hour: h, total: 0, count: 0, avg: 0 }; }

    const weathers = ['晴れ', '曇り', '雨', '雪', '未設定'];
    const byWeather = {};
    weathers.forEach(w => { byWeather[w] = { name: w, total: 0, count: 0, avg: 0 }; });

    const purposes = ['通勤', '通院', '買物', '観光', '出張', '送迎', '空港', '飲食', 'その他', '未設定'];
    const byPurpose = {};
    purposes.forEach(p => { byPurpose[p] = { name: p, total: 0, count: 0, avg: 0 }; });

    const passengerLabels = ['1人', '2人', '3人以上'];
    const byPassengers = {};
    passengerLabels.forEach(p => { byPassengers[p] = { name: p, total: 0, count: 0, avg: 0 }; });

    entries.forEach(e => {
      const amt = e.amount || 0;

      const dow = getDayOfWeek(e.timestamp);
      byDow[dow].total += amt;
      byDow[dow].count += 1;

      const hr = e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : toHour(e.timestamp);
      byHour[hr].total += amt;
      byHour[hr].count += 1;

      const w = e.weather && weathers.includes(e.weather) ? e.weather : '未設定';
      byWeather[w].total += amt;
      byWeather[w].count += 1;

      const p = e.purpose && purposes.includes(e.purpose) ? e.purpose : '未設定';
      byPurpose[p].total += amt;
      byPurpose[p].count += 1;

      const pNum = parseInt(e.passengers, 10) || 0;
      const pKey = pNum <= 1 ? '1人' : pNum === 2 ? '2人' : '3人以上';
      byPassengers[pKey].total += amt;
      byPassengers[pKey].count += 1;
    });

    const calcAvg = obj => { Object.values(obj).forEach(v => { v.avg = v.count > 0 ? Math.round(v.total / v.count) : 0; }); };
    calcAvg(byDow); calcAvg(byHour); calcAvg(byWeather); calcAvg(byPurpose); calcAvg(byPassengers);

    return {
      byDayOfWeek: dayNames.map(d => byDow[d]),
      byHour: Array.from({ length: 24 }, (_, h) => byHour[h]),
      byWeather: weathers.map(w => byWeather[w]),
      byPurpose: purposes.map(p => byPurpose[p]),
      byPassengers: passengerLabels.map(p => byPassengers[p]),
    };
  }

  // ============================================================
  // 今日のおすすめ（業務推奨）
  // ============================================================
  function getBusinessRecommendation() {
    const now = new Date();
    const currentHour = now.getHours();
    const currentDow = getDayOfWeek(now.toISOString());
    const currentDowIndex = now.getDay();

    const entries = getEntries();

    // 現在の時間帯で売上が高いエリアTOP3
    const areaByHour = {};
    entries.forEach(e => {
      const hr = e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : toHour(e.timestamp);
      if (hr === currentHour && e.pickup) {
        if (!areaByHour[e.pickup]) areaByHour[e.pickup] = { name: e.pickup, amount: 0, count: 0 };
        areaByHour[e.pickup].amount += e.amount || 0;
        areaByHour[e.pickup].count += 1;
      }
    });
    const topAreas = Object.values(areaByHour).sort((a, b) => b.amount - a.amount).slice(0, 3);

    // 今日の曜日で平均単価が高い時間帯TOP3
    const hourByDow = {};
    for (let h = 0; h < 24; h++) hourByDow[h] = { hour: h, name: h + '時', total: 0, count: 0, avg: 0 };
    entries.forEach(e => {
      const dow = getDayOfWeekIndex(e.timestamp);
      if (dow === currentDowIndex) {
        const hr = e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : toHour(e.timestamp);
        hourByDow[hr].total += e.amount || 0;
        hourByDow[hr].count += 1;
      }
    });
    Object.values(hourByDow).forEach(v => { v.avg = v.count > 0 ? Math.round(v.total / v.count) : 0; });
    const topHours = Object.values(hourByDow).filter(v => v.count > 0).sort((a, b) => b.avg - a.avg).slice(0, 3);

    // 推定客単価（曜日+時間帯の平均）
    let estTotal = 0, estCount = 0;
    entries.forEach(e => {
      const dow = getDayOfWeekIndex(e.timestamp);
      const hr = e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : toHour(e.timestamp);
      if (dow === currentDowIndex && hr === currentHour) {
        estTotal += e.amount || 0;
        estCount += 1;
      }
    });
    const estimatedUnitPrice = estCount > 0 ? Math.round(estTotal / estCount) : 0;

    return {
      topAreas,
      topHours,
      estimatedUnitPrice,
      currentCondition: { dayOfWeek: currentDow, hour: currentHour },
    };
  }

  // ============================================================
  // 配車方法×エリア×単価ランク クロス分析
  // ============================================================
  function getSourceAreaPriceBreakdown() {
    const entries = getEntries();
    const sources = ['Go', 'Uber', 'DIDI', '電話', '流し'];
    const priceTiers = [
      { key: 'short', label: '¥1,000以下', min: 0, max: 1000 },
      { key: 'mid', label: '¥1,001〜1,999', min: 1001, max: 1999 },
      { key: 'long', label: '¥2,000以上', min: 2000, max: Infinity },
    ];

    // 配車方法×エリアごとの集計
    const sourceAreaMap = {};
    // 配車方法×単価ランクの集計
    const sourceTierMap = {};
    sources.forEach(s => {
      sourceTierMap[s] = {};
      priceTiers.forEach(t => { sourceTierMap[s][t.key] = { count: 0, amount: 0 }; });
    });
    // エリア×単価ランクの集計
    const areaTierMap = {};

    entries.forEach(e => {
      const src = e.source && sources.includes(e.source) ? e.source : null;
      const area = e.pickup || '';
      const amt = e.amount || 0;
      const tier = amt <= 1000 ? 'short' : amt <= 1999 ? 'mid' : 'long';

      // 配車方法×エリア
      if (src && area) {
        const key = src + '::' + area;
        if (!sourceAreaMap[key]) sourceAreaMap[key] = { source: src, area, count: 0, amount: 0, avg: 0, tiers: { short: 0, mid: 0, long: 0 } };
        sourceAreaMap[key].count += 1;
        sourceAreaMap[key].amount += amt;
        sourceAreaMap[key].tiers[tier] += 1;
      }

      // 配車方法×単価ランク
      if (src) {
        sourceTierMap[src][tier].count += 1;
        sourceTierMap[src][tier].amount += amt;
      }

      // エリア×単価ランク
      if (area) {
        if (!areaTierMap[area]) {
          areaTierMap[area] = { area, total: 0, tiers: {} };
          priceTiers.forEach(t => { areaTierMap[area].tiers[t.key] = { count: 0, amount: 0 }; });
        }
        areaTierMap[area].total += 1;
        areaTierMap[area].tiers[tier].count += 1;
        areaTierMap[area].tiers[tier].amount += amt;
      }
    });

    // 平均算出
    Object.values(sourceAreaMap).forEach(v => { v.avg = v.count > 0 ? Math.round(v.amount / v.count) : 0; });

    // 配車方法×エリア: 上位をソート
    const sourceAreaList = Object.values(sourceAreaMap).sort((a, b) => b.count - a.count).slice(0, 30);

    // 配車方法×単価ランク: 構造化
    const sourceTierList = sources.map(s => ({
      source: s,
      tiers: priceTiers.map(t => ({
        ...t,
        count: sourceTierMap[s][t.key].count,
        amount: sourceTierMap[s][t.key].amount,
        avg: sourceTierMap[s][t.key].count > 0 ? Math.round(sourceTierMap[s][t.key].amount / sourceTierMap[s][t.key].count) : 0,
      })),
      totalCount: priceTiers.reduce((sum, t) => sum + sourceTierMap[s][t.key].count, 0),
    }));

    // エリア×単価ランク: 上位エリア
    const areaTierList = Object.values(areaTierMap)
      .sort((a, b) => b.total - a.total)
      .slice(0, 10)
      .map(a => ({
        area: a.area,
        total: a.total,
        tiers: priceTiers.map(t => ({
          ...t,
          count: a.tiers[t.key].count,
          amount: a.tiers[t.key].amount,
          pct: a.total > 0 ? Math.round((a.tiers[t.key].count / a.total) * 100) : 0,
        })),
      }));

    // エリア×配車方法マトリクス（平均単価）: 上位エリア×全配車方法
    const topAreas = areaTierList.map(a => a.area);
    const matrixData = topAreas.map(area => {
      const row = { area };
      sources.forEach(src => {
        const key = src + '::' + area;
        const d = sourceAreaMap[key];
        row[src] = d ? { count: d.count, avg: d.avg, tiers: d.tiers } : { count: 0, avg: 0, tiers: { short: 0, mid: 0, long: 0 } };
      });
      return row;
    });

    return { priceTiers, sources, sourceAreaList, sourceTierList, areaTierList, matrixData };
  }

  // ============================================================
  // 単価ランク別ヒートマップデータ（地図用）
  // ============================================================
  function getPriceTierHeatmapData(filterSource) {
    const entries = getEntries();
    const points = [];

    entries.forEach(e => {
      if (!e.pickupCoords || !e.pickupCoords.lat || !e.pickupCoords.lng) return;
      if (filterSource && e.source !== filterSource) return;
      const amt = e.amount || 0;
      const tier = amt <= 1000 ? 'short' : amt <= 1999 ? 'mid' : 'long';
      points.push({
        lat: e.pickupCoords.lat,
        lng: e.pickupCoords.lng,
        amount: amt,
        tier,
        source: e.source || '未設定',
        area: e.pickup || '',
        hour: e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : toHour(e.timestamp),
      });
    });

    return points;
  }

  // ============================================================
  // 現在地周辺の推定単価（地図パネル用）
  // ============================================================
  function getNearbyEstimate(lat, lng, radiusKm) {
    radiusKm = radiusKm || 2;
    const entries = getEntries();
    const now = new Date();
    const currentHour = now.getHours();
    const currentDow = now.getDay();
    const nearby = [];

    entries.forEach(e => {
      if (!e.pickupCoords || !e.pickupCoords.lat || !e.pickupCoords.lng) return;
      const dLat = e.pickupCoords.lat - lat;
      const dLng = e.pickupCoords.lng - lng;
      const dist = Math.sqrt(dLat * dLat + dLng * dLng) * 111; // 粗い距離(km)
      if (dist <= radiusKm) {
        nearby.push(e);
      }
    });

    if (nearby.length === 0) return { count: 0, avgPrice: 0, tierCounts: { short: 0, mid: 0, long: 0 }, sources: {}, topArea: '' };

    let total = 0;
    const tierCounts = { short: 0, mid: 0, long: 0 };
    const sources = {};
    const areaCounts = {};

    nearby.forEach(e => {
      const amt = e.amount || 0;
      total += amt;
      const tier = amt <= 1000 ? 'short' : amt <= 1999 ? 'mid' : 'long';
      tierCounts[tier] += 1;
      const src = e.source || '未設定';
      sources[src] = (sources[src] || 0) + 1;
      if (e.pickup) areaCounts[e.pickup] = (areaCounts[e.pickup] || 0) + 1;
    });

    const topArea = Object.entries(areaCounts).sort((a, b) => b[1] - a[1])[0];

    return {
      count: nearby.length,
      avgPrice: Math.round(total / nearby.length),
      tierCounts,
      sources,
      topArea: topArea ? topArea[0] : '',
    };
  }

  // ============================================================
  // ヒートマップデータ
  // ============================================================
  function getHeatmapData() {
    const entries = getEntries();
    const rivals = getRivalEntries();
    const points = [];

    entries.forEach(e => {
      if (e.pickupCoords && e.pickupCoords.lat && e.pickupCoords.lng) {
        points.push({ lat: e.pickupCoords.lat, lng: e.pickupCoords.lng, weight: e.amount || 1000 });
      }
      if (e.dropoffCoords && e.dropoffCoords.lat && e.dropoffCoords.lng) {
        points.push({ lat: e.dropoffCoords.lat, lng: e.dropoffCoords.lng, weight: e.amount || 1000 });
      }
    });

    rivals.forEach(r => {
      if (r.locationCoords && r.locationCoords.lat && r.locationCoords.lng) {
        points.push({ lat: r.locationCoords.lat, lng: r.locationCoords.lng, weight: 500 });
      }
    });

    return points;
  }

  // ============================================================
  // 週別集計
  // ============================================================
  function getWeeklyBreakdown(weeks = 12) {
    const entries = getEntries();
    const result = {};

    for (let i = weeks - 1; i >= 0; i--) {
      const d = new Date();
      d.setDate(d.getDate() - (i * 7));
      const key = getWeekStart(d);
      result[key] = { week: key, amount: 0, count: 0 };
    }

    entries.forEach(e => {
      const key = getWeekStart(new Date(e.timestamp));
      if (result[key]) {
        result[key].amount += e.amount || 0;
        result[key].count += 1;
      }
    });

    return Object.values(result);
  }

  // ============================================================
  // 月別集計
  // ============================================================
  function getMonthlyBreakdown() {
    const entries = getEntries();
    const result = {};

    entries.forEach(e => {
      const key = getMonthStr(e.timestamp);
      if (!result[key]) {
        result[key] = { month: key, amount: 0, count: 0 };
      }
      result[key].amount += e.amount || 0;
      result[key].count += 1;
    });

    return Object.values(result).sort((a, b) => a.month.localeCompare(b.month));
  }

  // ============================================================
  // CSVエクスポート
  // ============================================================
  function exportCSV() {
    const entries = getEntries();
    if (entries.length === 0) return null;

    const header = 'ID,日付,曜日,祝日,日時,天候,金額,乗車地,乗車時間,降車地,降車時間,人数,性別,用途,配車方法,メモ';
    const rows = entries.map(e => {
      const entryDate = e.date || toDateStr(e.timestamp);
      const dateInfo = JapaneseHolidays.getDateInfo(entryDate);
      const dayOfWeek = e.dayOfWeek || dateInfo.dayOfWeek;
      const holiday = e.holiday || dateInfo.holiday || '';
      const dateTime = new Date(e.timestamp).toLocaleString('ja-JP');
      const weather = (e.weather || '').replace(/,/g, '、');
      const pickup = (e.pickup || '').replace(/,/g, '、');
      const pickupTime = e.pickupTime || '';
      const dropoff = (e.dropoff || '').replace(/,/g, '、');
      const dropoffTime = e.dropoffTime || '';
      const passengers = e.passengers || '';
      const gender = e.gender || '';
      const purpose = (e.purpose || '').replace(/,/g, '、');
      const source = e.source || '';
      const memo = (e.memo || '').replace(/,/g, '、');
      return `${e.id},${entryDate},${dayOfWeek},${holiday},${dateTime},${weather},${e.amount},${pickup},${pickupTime},${dropoff},${dropoffTime},${passengers},${gender},${purpose},${source},${memo}`;
    });

    const csv = '\uFEFF' + header + '\n' + rows.join('\n'); // BOM付きUTF-8
    return csv;
  }

  function downloadCSV() {
    const csv = exportCSV();
    if (!csv) {
      AppLogger.warn('エクスポート対象のデータがありません');
      return false;
    }

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    const dateStr = new Date().toISOString().split('T')[0];
    link.href = url;
    link.download = `taxi_revenue_${dateStr}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    AppLogger.info(`CSVエクスポート完了: ${getEntries().length}件`);
    return true;
  }

  // ============================================================
  // データバリデーション
  // ============================================================
  function validateEntry(form) {
    const errors = [];
    const amount = parseInt(form.amount);

    if (form.noPassenger) {
      // 乗客なしの場合は金額バリデーションをスキップ
      return { valid: true, errors: [] };
    }

    if (!form.amount || isNaN(amount)) {
      errors.push('金額を入力してください');
    } else if (amount <= 0) {
      errors.push('金額は1円以上を入力してください');
    } else if (amount > 1000000) {
      errors.push('金額が大きすぎます（100万円以下にしてください）');
    }

    return { valid: errors.length === 0, errors };
  }

  // ============================================================
  // データ変更通知ヘルパー
  // ============================================================
  function _notifyDataChanged(type) {
    window.dispatchEvent(new CustomEvent('taxi-data-changed', { detail: { type } }));
  }

  // ============================================================
  // CRUD操作
  // ============================================================
  function addEntry(form) {
    const validation = validateEntry(form);
    if (!validation.valid) return { success: false, errors: validation.errors };

    const entries = getEntries();
    const entryDate = form.date || new Date().toISOString().split('T')[0];
    const dateInfo = JapaneseHolidays.getDateInfo(entryDate);
    const entry = {
      id: Date.now() + '_' + Math.random().toString(36).substr(2, 5),
      amount: parseInt(form.amount),
      date: entryDate,
      dayOfWeek: dateInfo.dayOfWeek,
      holiday: dateInfo.holiday || '',
      weather: form.weather || '',
      pickup: form.pickup || '',
      pickupTime: form.pickupTime || '',
      dropoff: form.dropoff || '',
      dropoffTime: form.dropoffTime || '',
      passengers: form.passengers || '',
      gender: form.gender || '',
      purpose: form.purpose || '',
      memo: form.memo || '',
      source: form.source || '',
      pickupCoords: form.pickupCoords || null,
      dropoffCoords: form.dropoffCoords || null,
      noPassenger: form.noPassenger || false,
      timestamp: new Date().toISOString(),
    };

    entries.unshift(entry);
    saveEntries(entries);
    const holidayStr = dateInfo.holiday ? ` [${dateInfo.holiday}]` : '';
    AppLogger.info(`売上記録追加: ¥${entry.amount} (${entry.date} ${dateInfo.dayOfWeek}${holidayStr}, ${entry.weather || '天候未設定'})`);
    // 自動ファイル保存
    autoSaveToFile();
    _syncToCloud('revenue', entries);
    _notifyDataChanged('revenue');
    return { success: true, entry };
  }

  function deleteEntry(id) {
    const entries = getEntries();
    const filtered = entries.filter(e => e.id !== id);
    saveEntries(filtered);
    AppLogger.info('売上記録を削除しました');
    autoSaveToFile();
    _syncToCloud('revenue', filtered);
    _notifyDataChanged('revenue');
    return true;
  }

  function updateEntry(id, updates) {
    const entries = getEntries();
    const idx = entries.findIndex(e => e.id === id);
    if (idx === -1) return { success: false, errors: ['記録が見つかりません'] };
    if (updates.amount != null) {
      const amt = parseInt(updates.amount);
      if (isNaN(amt) || amt < 1 || amt > 1000000) return { success: false, errors: ['金額は1〜1,000,000の範囲で入力してください'] };
      updates.amount = amt;
    }
    entries[idx] = { ...entries[idx], ...updates };
    saveEntries(entries);
    AppLogger.info('売上記録を更新しました');
    autoSaveToFile();
    _syncToCloud('revenue', entries);
    _notifyDataChanged('revenue');
    return { success: true, entry: entries[idx] };
  }

  function clearAllEntries() {
    saveEntries([]);
    _syncToCloud('revenue', []);
    AppLogger.info('全売上データを削除しました');
    _notifyDataChanged('revenue');
    return true;
  }

  // ============================================================
  // 他社乗車データ CRUD
  // ============================================================
  function getRivalEntries() {
    try {
      const saved = localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.RIVAL_RIDES);
      return saved ? JSON.parse(saved) : [];
    } catch {
      return [];
    }
  }

  function saveRivalEntries(entries) {
    try {
      localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.RIVAL_RIDES, JSON.stringify(entries));
      return true;
    } catch (e) {
      AppLogger.error('他社乗車データの保存に失敗しました', e.message);
      return false;
    }
  }

  function addRivalEntry(form) {
    if (!form.location || !form.location.trim()) {
      return { success: false, errors: ['乗車場所を入力してください'] };
    }
    const entries = getRivalEntries();
    const entryDate = form.date || new Date().toISOString().split('T')[0];
    const dateInfo = JapaneseHolidays.getDateInfo(entryDate);
    const entry = {
      id: Date.now() + '_' + Math.random().toString(36).substr(2, 5),
      date: entryDate,
      dayOfWeek: dateInfo.dayOfWeek,
      holiday: dateInfo.holiday || '',
      time: form.time || '',
      weather: form.weather || '',
      location: form.location.trim(),
      locationCoords: form.locationCoords || null,
      memo: form.memo || '',
      timestamp: new Date().toISOString(),
    };
    entries.unshift(entry);
    saveRivalEntries(entries);
    const holidayStr = dateInfo.holiday ? ` [${dateInfo.holiday}]` : '';
    AppLogger.info(`他社乗車記録追加: ${entry.location} (${entry.date} ${dateInfo.dayOfWeek}${holidayStr})`);
    autoSaveRivalToFile();
    _syncToCloud('rival', entries);
    _notifyDataChanged('rival');
    return { success: true, entry };
  }

  function deleteRivalEntry(id) {
    const entries = getRivalEntries();
    const filtered = entries.filter(e => e.id !== id);
    saveRivalEntries(filtered);
    AppLogger.info('他社乗車記録を削除しました');
    autoSaveRivalToFile();
    _syncToCloud('rival', filtered);
    _notifyDataChanged('rival');
    return true;
  }

  function updateRivalEntry(id, updates) {
    const entries = getRivalEntries();
    const idx = entries.findIndex(e => e.id === id);
    if (idx === -1) return { success: false, errors: ['記録が見つかりません'] };
    if (updates.location != null && !updates.location.trim()) return { success: false, errors: ['乗車場所を入力してください'] };
    entries[idx] = { ...entries[idx], ...updates };
    saveRivalEntries(entries);
    AppLogger.info('他社乗車記録を更新しました');
    autoSaveRivalToFile();
    _syncToCloud('rival', entries);
    _notifyDataChanged('rival');
    return { success: true, entry: entries[idx] };
  }

  function clearAllRivalEntries() {
    saveRivalEntries([]);
    _syncToCloud('rival', []);
    AppLogger.info('全他社乗車データを削除しました');
    _notifyDataChanged('rival');
    return true;
  }

  // ============================================================
  // 他社乗車分析
  // ============================================================
  function getRivalHourlyBreakdown() {
    const entries = getRivalEntries();
    const result = [];
    for (let h = 0; h < 24; h++) {
      result.push({ hour: h, label: `${h}時`, count: 0 });
    }
    entries.forEach(e => {
      if (e.time) {
        const hour = parseInt(e.time.split(':')[0], 10);
        if (hour >= 0 && hour < 24) result[hour].count += 1;
      }
    });
    return result;
  }

  function getRivalDayOfWeekBreakdown() {
    const days = ['日', '月', '火', '水', '木', '金', '土'];
    const result = days.map((name, i) => ({ name, index: i, count: 0 }));
    const entries = getRivalEntries();
    entries.forEach(e => {
      if (e.date) {
        const idx = new Date(e.date).getDay();
        if (idx >= 0 && idx < 7) result[idx].count += 1;
      }
    });
    return result;
  }

  function getRivalLocationBreakdown() {
    const entries = getRivalEntries();
    const locs = {};
    entries.forEach(e => {
      if (e.location) {
        if (!locs[e.location]) locs[e.location] = { name: e.location, count: 0 };
        locs[e.location].count += 1;
      }
    });
    return Object.values(locs).sort((a, b) => b.count - a.count).slice(0, 10);
  }

  function getRivalWeatherBreakdown() {
    const weathers = ['晴れ', '曇り', '雨', '雪', '未設定'];
    const result = {};
    weathers.forEach(w => { result[w] = { name: w, count: 0 }; });
    const entries = getRivalEntries();
    entries.forEach(e => {
      const w = e.weather && weathers.includes(e.weather) ? e.weather : '未設定';
      result[w].count += 1;
    });
    return weathers.map(w => result[w]);
  }

  function downloadRivalCSV() {
    const entries = getRivalEntries();
    if (entries.length === 0) {
      AppLogger.warn('エクスポート対象の他社乗車データがありません');
      return false;
    }
    const header = 'ID,日付,曜日,祝日,時間,天候,乗車場所,メモ';
    const rows = entries.map(e => {
      const weather = (e.weather || '').replace(/,/g, '、');
      const location = (e.location || '').replace(/,/g, '、');
      const memo = (e.memo || '').replace(/,/g, '、');
      return `${e.id},${e.date},${e.dayOfWeek},${e.holiday},${e.time},${weather},${location},${memo}`;
    });
    const csv = '\uFEFF' + header + '\n' + rows.join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    const dateStr = new Date().toISOString().split('T')[0];
    link.href = url;
    link.download = `rival_rides_${dateStr}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    AppLogger.info(`他社乗車CSVエクスポート完了: ${entries.length}件`);
    return true;
  }

  // ============================================================
  // イベントデータ CRUD
  // ============================================================
  function getEvents() {
    try {
      const saved = localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.EVENTS);
      return saved ? JSON.parse(saved) : [];
    } catch {
      return [];
    }
  }

  function saveEvents(entries) {
    try {
      localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.EVENTS, JSON.stringify(entries));
      return true;
    } catch (e) {
      AppLogger.error('イベントデータの保存に失敗しました', e.message);
      return false;
    }
  }

  function addEvent(form) {
    if (!form.name || !form.name.trim()) {
      return { success: false, errors: ['イベント名を入力してください'] };
    }
    const entries = getEvents();
    const entryDate = form.date || new Date().toISOString().split('T')[0];
    const dateInfo = JapaneseHolidays.getDateInfo(entryDate);
    const entry = {
      id: Date.now() + '_' + Math.random().toString(36).substr(2, 5),
      name: form.name.trim(),
      date: entryDate,
      dayOfWeek: dateInfo.dayOfWeek,
      holiday: dateInfo.holiday || '',
      startTime: form.startTime || '',
      endTime: form.endTime || '',
      location: form.location || '',
      locationCoords: form.locationCoords || null,
      scale: form.scale || '',
      impact: form.impact || '',
      memo: form.memo || '',
      timestamp: new Date().toISOString(),
    };
    entries.unshift(entry);
    saveEvents(entries);
    const holidayStr = dateInfo.holiday ? ` [${dateInfo.holiday}]` : '';
    AppLogger.info(`イベント記録追加: ${entry.name} (${entry.date} ${dateInfo.dayOfWeek}${holidayStr})`);
    return { success: true, entry };
  }

  function deleteEvent(id) {
    const entries = getEvents();
    const filtered = entries.filter(e => e.id !== id);
    saveEvents(filtered);
    AppLogger.info('イベント記録を削除しました');
    return true;
  }

  function clearAllEvents() {
    saveEvents([]);
    AppLogger.info('全イベントデータを削除しました');
    return true;
  }

  // 公共交通機関情報の自動保存（サブフォルダ「公共交通機関情報」）
  async function autoSaveTransitToFile(transitData) {
    await _handleReady;
    if (!_dirHandle) return;
    if (!transitData || Object.keys(transitData).length === 0) return;
    const now = new Date();
    const dateTimeStr = now.getFullYear()
      + '-' + String(now.getMonth() + 1).padStart(2, '0')
      + '-' + String(now.getDate()).padStart(2, '0')
      + '_' + String(now.getHours()).padStart(2, '0')
      + String(now.getMinutes()).padStart(2, '0');
    await _saveToSubFolder('公共交通機関情報', `交通情報_${dateTimeStr}.json`, [transitData], '0.6.0');
  }

  // ============================================================
  // 公開API
  // ============================================================
  return {
    // データ取得
    getEntries,
    saveEntries,

    // サマリー
    getTodaySummary,
    getOverallSummary,

    // 分析
    getDailyBreakdown,
    getDayOfWeekBreakdown,
    getHourlyBreakdown,
    getAreaBreakdown,
    getWeeklyBreakdown,
    getMonthlyBreakdown,
    getWeatherBreakdown,
    getSourceBreakdown,
    getPurposeBreakdown,
    getAreaTimeBreakdown,
    getUnitPriceAnalysis,
    getBusinessRecommendation,
    getSourceAreaPriceBreakdown,
    getPriceTierHeatmapData,
    getNearbyEstimate,
    getHeatmapData,

    // CRUD
    addEntry,
    updateEntry,
    deleteEntry,
    clearAllEntries,
    validateEntry,

    // エクスポート
    exportCSV,
    downloadCSV,

    // ファイル保存・復元
    autoSaveToFile,
    manualSaveToFile,
    selectSaveFolder,
    importFromFile,
    hasSaveFolder,

    // 他社乗車
    getRivalEntries,
    saveRivalEntries,
    addRivalEntry,
    updateRivalEntry,
    deleteRivalEntry,
    clearAllRivalEntries,
    downloadRivalCSV,
    autoSaveRivalToFile,
    manualSaveRivalToFile,
    getRivalHourlyBreakdown,
    getRivalDayOfWeekBreakdown,
    getRivalLocationBreakdown,
    getRivalWeatherBreakdown,

    // クラウド同期
    loadFromCloud,
    syncFromCloud,
    autoSync,

    // イベント
    getEvents,
    saveEvents,
    addEvent,
    deleteEvent,
    clearAllEvents,

    // 公共交通機関情報
    autoSaveTransitToFile,
  };
})();

})();

// ============================================================
// FILE: src/utils/geminiService.js
// ============================================================
(function() {
// geminiService.js - Gemini AI API連携サービス
//
// Google Gemini 2.0 Flash を使用してAI検索を行うサービス層。
// 公共交通機関情報やイベント情報の検索に使用する。

window.GeminiService = (() => {
  const API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent';

  // Gemini APIにリクエストを送信
  async function callGemini(apiKey, prompt) {
    if (!apiKey) {
      return { success: false, error: 'Gemini APIキーが設定されていません' };
    }

    try {
      const response = await fetch(API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-goog-api-key': apiKey,
        },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
          generationConfig: {
            temperature: 0.3,
            maxOutputTokens: 2048,
          },
        }),
      });

      if (!response.ok) {
        const errData = await response.json().catch(() => ({}));
        const errMsg = errData.error?.message || `HTTPエラー: ${response.status}`;
        if (response.status === 400) return { success: false, error: 'APIキーが無効です。正しいキーを設定してください。' };
        if (response.status === 429) return { success: false, error: 'API利用制限に達しました。しばらく待ってから再試行してください。' };
        return { success: false, error: errMsg };
      }

      const data = await response.json();
      const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
      if (!text) {
        return { success: false, error: '応答が空でした' };
      }

      return { success: true, text };
    } catch (e) {
      AppLogger.error('Gemini API呼び出しエラー', e.message);
      return { success: false, error: `通信エラー: ${e.message}` };
    }
  }

  // 公共交通機関の運行情報を検索
  async function searchTransitInfo(apiKey, query) {
    const today = new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
    const prompt = `あなたはタクシードライバー向けの交通情報アシスタントです。
今日は${today}です。

以下の質問に対して、タクシー営業に役立つ公共交通機関の情報を簡潔に回答してください。
- 鉄道の運行状況、遅延、運休の情報
- バス路線の状況
- 終電・始発の時刻
- タクシー需要が増える可能性のあるポイント

回答は箇条書きで分かりやすくお願いします。推測や不確実な情報には「※推定」と明記してください。

質問: ${query}`;

    const result = await callGemini(apiKey, prompt);
    if (result.success) {
      AppLogger.info(`Gemini交通情報検索: ${query}`);
    }
    return result;
  }

  // 周辺イベント情報を検索
  async function searchEvents(apiKey, query, area) {
    const today = new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
    const areaStr = area ? `エリア: ${area}\n` : '';
    const prompt = `あなたはタクシードライバー向けのイベント情報アシスタントです。
今日は${today}です。
${areaStr}
以下の質問に対して、タクシー需要に影響する可能性のあるイベント情報を回答してください。
各イベントについて以下の形式で回答してください:
- イベント名
- 日時（分かれば）
- 場所
- 規模の目安（小/中/大/特大）
- タクシー需要への影響予測（需要増/需要減/不明）

推測や不確実な情報には「※推定」と明記してください。

質問: ${query}`;

    const result = await callGemini(apiKey, prompt);
    if (result.success) {
      AppLogger.info(`Geminiイベント検索: ${query}`);
    }
    return result;
  }

  // 大容量レスポンス用のGemini API呼び出し
  async function callGeminiLarge(apiKey, prompt) {
    if (!apiKey) {
      return { success: false, error: 'Gemini APIキーが設定されていません' };
    }

    try {
      const response = await fetch(API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-goog-api-key': apiKey,
        },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
          generationConfig: {
            temperature: 0.2,
            maxOutputTokens: 8192,
          },
        }),
      });

      if (!response.ok) {
        const errData = await response.json().catch(() => ({}));
        const errMsg = errData.error?.message || `HTTPエラー: ${response.status}`;
        if (response.status === 400) return { success: false, error: 'APIキーが無効です。正しいキーを設定してください。' };
        if (response.status === 429) return { success: false, error: 'API利用制限に達しました。しばらく待ってから再試行してください。' };
        return { success: false, error: errMsg };
      }

      const data = await response.json();
      const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
      if (!text) {
        return { success: false, error: '応答が空でした' };
      }

      return { success: true, text };
    } catch (e) {
      AppLogger.error('Gemini API呼び出しエラー', e.message);
      return { success: false, error: `通信エラー: ${e.message}` };
    }
  }

  // 電車の運行時刻・運行情報を取得
  async function fetchTrainInfo(apiKey, region) {
    const today = new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
    const area = region || '東京都内および近郊';
    const prompt = `あなたは公共交通機関の情報提供アシスタントです。
今日は${today}です。
ユーザーの現在地: ${area}

「${area}」およびその近郊で利用される主要鉄道路線について、本日の運行情報を網羅的に提供してください。

以下を含めてください:
- この地域を走るJR線の主要路線
- この地域を走る私鉄の主要路線
- この地域を走る地下鉄・モノレール等の路線

各路線について以下を記載してください:
- 始発時刻と終電時刻（主要駅基準）
- 本日の運行ダイヤ（平日/休日ダイヤ）
- ピーク時の運行間隔
- 現在の運行状況（通常運行/遅延/運休など）

見やすい表形式や箇条書きで整理してください。
※情報が確認できない場合は「※一般的な時刻」と明記してください。`;

    const result = await callGeminiLarge(apiKey, prompt);
    if (result.success) {
      AppLogger.info(`Gemini: 電車運行情報を取得 (${area})`);
    }
    return result;
  }

  // バスの運行時刻・運行情報を取得
  async function fetchBusInfo(apiKey, region) {
    const today = new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
    const area = region || '東京都内';
    const prompt = `あなたは公共交通機関の情報提供アシスタントです。
今日は${today}です。
ユーザーの現在地: ${area}

「${area}」およびその近郊の主要バス路線について、本日の運行情報を網羅的に提供してください。

以下を含めてください:
- この地域の公営バス（市バス・都営バス等）の主要系統
- この地域の民営バス会社の主要路線
- この地域発着の高速バス・空港バスの主要路線
- この地域の深夜バス（該当する場合）

各路線・会社について以下を記載してください:
- 主要路線名と区間
- 始発・終バスの時刻
- 本日のダイヤ（平日/休日）
- 運行間隔（ピーク時/日中/夜間）
- 現在の運行状況

見やすい表形式や箇条書きで整理してください。
※情報が確認できない場合は「※一般的な時刻」と明記してください。`;

    const result = await callGeminiLarge(apiKey, prompt);
    if (result.success) {
      AppLogger.info(`Gemini: バス運行情報を取得 (${area})`);
    }
    return result;
  }

  // 飛行機の運航時刻・運航情報を取得
  async function fetchFlightInfo(apiKey, region) {
    const today = new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
    const area = region || '東京都';
    const prompt = `あなたは公共交通機関の情報提供アシスタントです。
今日は${today}です。
ユーザーの現在地: ${area}

「${area}」から最も近い主要空港について、本日のフライト情報を網羅的に提供してください。

まず「${area}」の最寄りの主要空港を特定し、各空港について以下を提供してください:
- 国内線: 主要路線の出発・到着便
- 国際線: 主要路線の出発・到着便（該当する場合）
- 各ターミナルの利用航空会社

以下の情報も含めてください:
- 早朝便（始発〜7時）と深夜便（21時以降）の一覧（タクシー需要が高い時間帯）
- ピーク時間帯（到着便が集中する時間）
- 現在の運航状況（通常運航/遅延/欠航など）
- 天候による影響（ある場合）

見やすい表形式や箇条書きで整理してください。
※情報が確認できない場合は「※一般的なスケジュール」と明記してください。`;

    const result = await callGeminiLarge(apiKey, prompt);
    if (result.success) {
      AppLogger.info(`Gemini: 飛行機運航情報を取得 (${area})`);
    }
    return result;
  }

  // 遅延・トラブル情報を取得
  async function fetchTroubleInfo(apiKey, region) {
    const today = new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
    const now = new Date().toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
    const area = region || '東京都内';
    const prompt = `あなたは公共交通機関の情報提供アシスタントです。
今日は${today}、現在時刻は${now}です。
ユーザーの現在地: ${area}

「${area}」およびその近郊で現在発生している公共交通機関の遅延・トラブル・運休情報をすべて提供してください。

【確認対象】
1. 鉄道（この地域のJR・私鉄・地下鉄すべて）
2. バス（公営バス・民営バス・高速バス）
3. 航空（最寄り空港の発着便）
4. その他（モノレール・新交通システム等）

【各トラブルについて以下を記載】
- 路線名・区間
- トラブルの種類（遅延/運休/運転見合わせ/徐行運転/振替輸送等）
- 原因（人身事故/車両故障/天候/信号故障等）
- 発生時刻（分かれば）
- 復旧見込み（分かれば）
- 影響度（小/中/大）
- タクシー需要への影響（需要増のエリア・駅を具体的に）

【追加情報】
- 本日予定されている計画運休・工事運休
- 天候による今後の影響予測
- 振替輸送の実施状況

タクシードライバーの営業に役立つ観点でまとめてください。
トラブルがない場合は「現在、大きなトラブルは報告されていません」と回答してください。
※リアルタイム情報が不明な場合は「※最新情報は各社公式サイトで確認してください」と明記してください。`;

    const result = await callGeminiLarge(apiKey, prompt);
    if (result.success) {
      AppLogger.info(`Gemini: 遅延・トラブル情報を取得 (${area})`);
    }
    return result;
  }

  // APIキーの接続テスト
  async function testConnection(apiKey) {
    const result = await callGemini(apiKey, 'こんにちは。接続テストです。「接続成功」と一言だけ返答してください。');
    return result;
  }

  return {
    callGemini,
    searchTransitInfo,
    searchEvents,
    callGeminiLarge,
    fetchTrainInfo,
    fetchBusInfo,
    fetchFlightInfo,
    fetchTroubleInfo,
    testConnection,
  };
})();
})();

// ============================================================
// FILE: src/context/LogContext.jsx
// ============================================================
(function() {
// LogContext.jsx - ログ状態管理
const { createContext, useState, useEffect, useContext } = React;

window.LogContext = createContext(null);

window.LogProvider = ({ children }) => {
  const [logs, setLogs] = useState(AppLogger.getLogs());

  useEffect(() => {
    const unsub = AppLogger.subscribe(setLogs);
    return unsub;
  }, []);

  const value = {
    logs,
    addLog: AppLogger.info,
    addDebug: AppLogger.debug,
    addWarn: AppLogger.warn,
    addError: AppLogger.error,
    clearLogs: AppLogger.clearLogs,
  };

  return React.createElement(LogContext.Provider, { value }, children);
};

window.useLogContext = () => useContext(LogContext);

})();

// ============================================================
// FILE: src/context/MapContext.jsx
// ============================================================
(function() {
// MapContext.jsx - 地図・GPS状態管理
const { createContext, useState, useCallback, useContext } = React;

window.MapContext = createContext(null);

window.MapProvider = ({ children }) => {
  const [currentPosition, setCurrentPosition] = useState(null);
  const [mapCenter, setMapCenter] = useState(APP_CONSTANTS.DEFAULT_MAP_CENTER);
  const [zoom, setZoom] = useState(APP_CONSTANTS.DEFAULT_MAP_ZOOM);
  const [isTracking, setIsTracking] = useState(false);
  const [gpsError, setGpsError] = useState(null);
  const [accuracy, setAccuracy] = useState(null);
  const [speed, setSpeed] = useState(null);
  const [heading, setHeading] = useState(null);

  const updatePosition = useCallback((position) => {
    const pos = {
      lat: position.coords.latitude,
      lng: position.coords.longitude,
    };
    setCurrentPosition(pos);
    setAccuracy(position.coords.accuracy);
    setSpeed(position.coords.speed);
    setHeading(position.coords.heading);
    setGpsError(null);
  }, []);

  const value = {
    currentPosition,
    setCurrentPosition,
    mapCenter,
    setMapCenter,
    zoom,
    setZoom,
    isTracking,
    setIsTracking,
    gpsError,
    setGpsError,
    accuracy,
    speed,
    heading,
    updatePosition,
  };

  return React.createElement(MapContext.Provider, { value }, children);
};

window.useMapContext = () => useContext(MapContext);

})();

// ============================================================
// FILE: src/context/AppContext.jsx
// ============================================================
(function() {
// AppContext.jsx - アプリ全体の状態管理（ハッシュルーティング対応）
const { createContext, useState, useEffect, useCallback, useContext } = React;

window.AppContext = createContext(null);

// ハッシュからページ名を取得するヘルパー
function getPageFromHash() {
  const hash = window.location.hash.replace('#/', '').replace('#', '');
  const validRoutes = Object.values(APP_CONSTANTS.ROUTES);
  return validRoutes.includes(hash) ? hash : APP_CONSTANTS.ROUTES.DASHBOARD;
}

window.AppProvider = ({ children }) => {
  const [currentPage, setCurrentPage] = useState(getPageFromHash);
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [apiKey, setApiKeyState] = useState(AppStorage.getApiKey());
  const [geminiApiKey, setGeminiApiKeyState] = useState(AppStorage.getGeminiApiKey());

  const setApiKey = useCallback((key) => {
    AppStorage.setApiKey(key);
    setApiKeyState(key);
    AppLogger.info('Google Maps APIキーが更新されました');
  }, []);

  const setGeminiApiKey = useCallback((key) => {
    AppStorage.setGeminiApiKey(key);
    setGeminiApiKeyState(key);
    AppLogger.info('Gemini APIキーが更新されました');
  }, []);

  // ページ遷移（ハッシュを更新 → hashchangeで状態も更新）
  const navigate = useCallback((page) => {
    window.location.hash = `#/${page}`;
    setSidebarOpen(false);
    AppLogger.debug(`ページ遷移: ${page}`);
  }, []);

  // ブラウザの戻る/進むボタン対応
  useEffect(() => {
    const handleHashChange = () => {
      const page = getPageFromHash();
      setCurrentPage(page);
    };
    window.addEventListener('hashchange', handleHashChange);
    return () => window.removeEventListener('hashchange', handleHashChange);
  }, []);

  // 初期ハッシュが空の場合にセット
  useEffect(() => {
    if (!window.location.hash) {
      window.location.hash = `#/${APP_CONSTANTS.ROUTES.DASHBOARD}`;
    }
  }, []);

  // ── 自動同期（SYNC_SECRET設定時のみ） ──
  useEffect(() => {
    const secret = (localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.SYNC_SECRET) || '').trim();
    if (!secret) return;

    // A. アプリ起動時に自動同期
    DataService.autoSync();

    // B. ページ復帰時（タブ切替から戻った時）に自動同期
    const handleVisibility = () => {
      if (document.visibilityState === 'visible') {
        DataService.autoSync();
      }
    };
    document.addEventListener('visibilitychange', handleVisibility);

    // C. 5分間隔の定期同期
    const intervalId = setInterval(() => {
      DataService.autoSync();
    }, 5 * 60 * 1000);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibility);
      clearInterval(intervalId);
    };
  }, []);

  const value = {
    currentPage,
    navigate,
    sidebarOpen,
    setSidebarOpen,
    apiKey,
    setApiKey,
    geminiApiKey,
    setGeminiApiKey,
  };

  return React.createElement(AppContext.Provider, { value }, children);
};

window.useAppContext = () => useContext(AppContext);

})();

// ============================================================
// FILE: src/hooks/useGeolocation.js
// ============================================================
(function() {
// useGeolocation.js - GPS位置情報カスタムフック
window.useGeolocation = () => {
  const { useState, useEffect, useRef, useCallback } = React;
  const mapCtx = useMapContext();
  const [watchId, setWatchId] = useState(null);
  const watchIdRef = useRef(null);

  const isSupported = 'geolocation' in navigator;

  const getCurrentPosition = useCallback(() => {
    if (!isSupported) {
      mapCtx.setGpsError('このブラウザはGPSに対応していません');
      AppLogger.error('Geolocation API 非対応');
      return;
    }

    AppLogger.info('現在地を取得中（高精度モード）...');

    // getAccuratePositionを使い、複数回のGPS測位から最良の結果を取得
    getAccuratePosition({ accuracyThreshold: 100, timeout: 15000, maxWaitAfterFix: 5000 })
      .then((position) => {
        mapCtx.updatePosition(position);
        const pos = { lat: position.coords.latitude, lng: position.coords.longitude };
        mapCtx.setMapCenter(pos);
        AppLogger.info(`現在地取得成功: ${pos.lat.toFixed(6)}, ${pos.lng.toFixed(6)} 精度: ${Math.round(position.coords.accuracy)}m`);
      })
      .catch((error) => {
        const msg = error.message || getErrorMessage(error);
        mapCtx.setGpsError(msg);
        AppLogger.error(`GPS取得エラー: ${msg}`);
      });
  }, [isSupported, mapCtx]);

  const startTracking = useCallback(() => {
    if (!isSupported) return;

    AppLogger.info('GPS追跡を開始');
    mapCtx.setIsTracking(true);

    const id = navigator.geolocation.watchPosition(
      (position) => {
        mapCtx.updatePosition(position);
      },
      (error) => {
        const msg = getErrorMessage(error);
        mapCtx.setGpsError(msg);
        AppLogger.warn(`GPS追跡エラー: ${msg}`);
      },
      APP_CONSTANTS.GPS_OPTIONS
    );

    watchIdRef.current = id;
    setWatchId(id);
  }, [isSupported, mapCtx]);

  const stopTracking = useCallback(() => {
    if (watchIdRef.current !== null) {
      navigator.geolocation.clearWatch(watchIdRef.current);
      watchIdRef.current = null;
      setWatchId(null);
    }
    mapCtx.setIsTracking(false);
    AppLogger.info('GPS追跡を停止');
  }, [mapCtx]);

  useEffect(() => {
    return () => {
      if (watchIdRef.current !== null) {
        navigator.geolocation.clearWatch(watchIdRef.current);
      }
    };
  }, []);

  return {
    isSupported,
    getCurrentPosition,
    startTracking,
    stopTracking,
    isTracking: mapCtx.isTracking,
  };
};

function getErrorMessage(error) {
  switch (error.code) {
    case error.PERMISSION_DENIED:
      return '位置情報の権限が拒否されました';
    case error.POSITION_UNAVAILABLE:
      return '位置情報を取得できません';
    case error.TIMEOUT:
      return '位置情報の取得がタイムアウトしました';
    default:
      return '位置情報の取得中にエラーが発生しました';
  }
}

// 高精度GPS取得ユーティリティ
window.getAccuratePosition = (options = {}) => {
  const {
    accuracyThreshold = 50,
    timeout = 20000,
    maxWaitAfterFix = 8000,
  } = options;

  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject({ code: 0, message: 'このブラウザではGPS機能が使えません' });
      return;
    }

    let bestPosition = null;
    let watchId = null;
    let overallTimer = null;
    let waitTimer = null;
    let settled = false;

    const cleanup = () => {
      if (watchId !== null) navigator.geolocation.clearWatch(watchId);
      if (overallTimer) clearTimeout(overallTimer);
      if (waitTimer) clearTimeout(waitTimer);
      watchId = null;
      overallTimer = null;
      waitTimer = null;
    };

    const doResolve = (pos) => {
      if (settled) return;
      settled = true;
      cleanup();
      AppLogger.info(`GPS確定: 精度${pos.coords.accuracy.toFixed(0)}m (${pos.coords.latitude.toFixed(6)}, ${pos.coords.longitude.toFixed(6)})`);
      resolve(pos);
    };

    const doReject = (err) => {
      if (settled) return;
      settled = true;
      cleanup();
      reject(err);
    };

    const finish = () => {
      if (bestPosition) {
        doResolve(bestPosition);
      } else {
        doReject({ code: 2, message: '現在地を取得できませんでした。' });
      }
    };

    overallTimer = setTimeout(finish, timeout);

    watchId = navigator.geolocation.watchPosition(
      (position) => {
        if (settled) return;
        const acc = position.coords.accuracy;
        AppLogger.info(`GPS受信: 精度${acc.toFixed(0)}m lat=${position.coords.latitude.toFixed(6)} lng=${position.coords.longitude.toFixed(6)}`);

        if (!bestPosition || acc < bestPosition.coords.accuracy) {
          bestPosition = position;
        }

        if (acc <= accuracyThreshold) {
          doResolve(position);
          return;
        }

        if (!waitTimer) {
          waitTimer = setTimeout(finish, maxWaitAfterFix);
        }
      },
      (error) => {
        // Permission denied は即座にreject（リトライしても無駄）
        if (error.code === 1) {
          doReject(error);
          return;
        }
        // その他のエラー（TIMEOUT/POSITION_UNAVAILABLE）は一時的な場合があるので
        // bestPositionがあればそれを使い、なければ全体タイムアウトに任せる
        AppLogger.warn(`GPS一時エラー: code=${error.code} ${error.message || ''}`);
        if (bestPosition) {
          doResolve(bestPosition);
        }
        // bestPositionがなければoverallTimerのfinish()でrejectされる
      },
      { enableHighAccuracy: true, timeout: Math.min(timeout, 15000), maximumAge: 0 }
    );
  });
};

})();

// ============================================================
// FILE: src/hooks/useGoogleMaps.js
// ============================================================
(function() {
// useGoogleMaps.js - Google Maps API管理フック
//
// GoogleMap.jsx内のローダーロジックをフックとして公開し、
// 複数コンポーネントからGoogle Maps APIの状態を参照可能にする。

window.useGoogleMaps = () => {
  const { useState, useEffect, useCallback } = React;
  const { apiKey } = useAppContext();
  const [isLoaded, setIsLoaded] = useState(!!(window.google && window.google.maps));
  const [error, setError] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  // Google Maps API をロード
  const loadApi = useCallback(() => {
    if (!apiKey) {
      setError(null);
      setIsLoaded(false);
      return;
    }

    if (window.google && window.google.maps) {
      setIsLoaded(true);
      setError(null);
      return;
    }

    setIsLoading(true);

    // 既存のスクリプトがあるかチェック
    const existingScript = document.querySelector('script[src*="maps.googleapis.com"]');
    if (existingScript) {
      // ロード完了を待つ
      const check = setInterval(() => {
        if (window.google && window.google.maps) {
          clearInterval(check);
          setIsLoaded(true);
          setIsLoading(false);
          setError(null);
        }
      }, 100);
      return;
    }

    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&language=ja&region=JP`;
    script.async = true;
    script.onload = () => {
      setIsLoaded(true);
      setIsLoading(false);
      setError(null);
      AppLogger.info('Google Maps API ロード完了 (useGoogleMaps)');
    };
    script.onerror = () => {
      setError('Google Maps API の読み込みに失敗しました。APIキーを確認してください。');
      setIsLoading(false);
      AppLogger.error('Google Maps API ロード失敗 (useGoogleMaps)');
    };
    document.head.appendChild(script);
  }, [apiKey]);

  useEffect(() => {
    loadApi();
  }, [loadApi]);

  return {
    isLoaded,
    isLoading,
    error,
    apiKey,
    reload: loadApi,
  };
};

})();

// ============================================================
// FILE: src/hooks/useLogger.js
// ============================================================
(function() {
// useLogger.js - ロギング用カスタムフック
//
// AppLogger をReactコンポーネントから便利に使うためのフック。
// コンポーネント名を自動的にプレフィックスとして付加する。

window.useLogger = (componentName = '') => {
  const { useCallback, useMemo } = React;

  const prefix = componentName ? `[${componentName}] ` : '';

  const logger = useMemo(() => ({
    debug: (msg, data) => AppLogger.debug(`${prefix}${msg}`, data),
    info: (msg, data) => AppLogger.info(`${prefix}${msg}`, data),
    warn: (msg, data) => AppLogger.warn(`${prefix}${msg}`, data),
    error: (msg, data) => AppLogger.error(`${prefix}${msg}`, data),
  }), [prefix]);

  // コンポーネントのマウント/アンマウントをログ
  const logMount = useCallback(() => {
    if (componentName) {
      AppLogger.debug(`${prefix}マウント`);
    }
  }, [prefix, componentName]);

  const logUnmount = useCallback(() => {
    if (componentName) {
      AppLogger.debug(`${prefix}アンマウント`);
    }
  }, [prefix, componentName]);

  return {
    ...logger,
    logMount,
    logUnmount,
    getLogs: AppLogger.getLogs,
    clearLogs: AppLogger.clearLogs,
    subscribe: AppLogger.subscribe,
  };
};

})();

// ============================================================
// FILE: src/components/common/Loading.jsx
// ============================================================
(function() {
// Loading.jsx - ローディング表示
window.Loading = ({ message = '読み込み中...' }) => {
  return React.createElement('div', { className: 'loading' },
    React.createElement('div', { className: 'loading__spinner' }),
    React.createElement('span', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)' } }, message)
  );
};

})();

// ============================================================
// FILE: src/components/common/Card.jsx
// ============================================================
(function() {
// Card.jsx - 汎用カード
window.Card = ({ title, subtitle, children, className = '', onClick, style }) => {
  return React.createElement('div', {
    className: `card ${className}`,
    onClick,
    style: { ...style, cursor: onClick ? 'pointer' : 'default' },
  },
    title && React.createElement('div', { className: 'card__title' }, title),
    subtitle && React.createElement('div', { className: 'card__subtitle' }, subtitle),
    children
  );
};

})();

// ============================================================
// FILE: src/components/common/Button.jsx
// ============================================================
(function() {
// Button.jsx - 汎用ボタン
window.Button = ({ children, variant = 'primary', icon, onClick, disabled, className = '', style }) => {
  return React.createElement('button', {
    className: `btn btn--${variant} ${className}`,
    onClick,
    disabled,
    style,
  },
    icon && React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, icon),
    children
  );
};

})();

// ============================================================
// FILE: src/components/common/ErrorBoundary.jsx
// ============================================================
(function() {
// ErrorBoundary.jsx - エラーバウンダリ（白画面クラッシュ防止）
// React Error Boundary はクラスコンポーネントが必要
window.ErrorBoundary = class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({ errorInfo });
    // ログに記録
    if (window.AppLogger) {
      AppLogger.error(`ErrorBoundary: ${error.message}`);
    }
    console.error('[ErrorBoundary]', error, errorInfo);
  }

  handleReset() {
    this.setState({ hasError: false, error: null, errorInfo: null });
  }

  handleReload() {
    window.location.reload();
  }

  render() {
    if (this.state.hasError) {
      return React.createElement('div', {
        style: {
          display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
          minHeight: '60vh', padding: '24px', textAlign: 'center',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '64px', color: 'var(--color-danger)', marginBottom: '16px' },
        }, 'error_outline'),

        React.createElement('h2', {
          style: { color: 'var(--text-primary)', marginBottom: '8px', fontSize: 'var(--font-size-xl)' },
        }, 'エラーが発生しました'),

        React.createElement('p', {
          style: { color: 'var(--text-secondary)', marginBottom: '24px', maxWidth: '400px', fontSize: 'var(--font-size-sm)' },
        }, 'アプリケーションで予期しないエラーが発生しました。再試行するか、ページを再読み込みしてください。'),

        // エラー詳細（開発時のみ表示を想定）
        this.state.error && React.createElement('details', {
          style: {
            marginBottom: '24px', textAlign: 'left', maxWidth: '500px', width: '100%',
            background: 'rgba(229,57,53,0.08)', borderRadius: '8px', padding: '12px',
            fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)',
          },
        },
          React.createElement('summary', {
            style: { cursor: 'pointer', color: 'var(--text-secondary)', marginBottom: '8px' },
          }, 'エラー詳細を表示'),
          React.createElement('pre', {
            style: { whiteSpace: 'pre-wrap', wordBreak: 'break-all', margin: 0 },
          }, String(this.state.error)),
          this.state.errorInfo && React.createElement('pre', {
            style: { whiteSpace: 'pre-wrap', wordBreak: 'break-all', margin: '8px 0 0', fontSize: '11px' },
          }, this.state.errorInfo.componentStack)
        ),

        // アクションボタン
        React.createElement('div', { style: { display: 'flex', gap: '12px' } },
          React.createElement('button', {
            onClick: () => this.handleReset(),
            style: {
              padding: '10px 24px', borderRadius: '8px', border: 'none', cursor: 'pointer',
              background: 'var(--color-primary)', color: '#fff', fontWeight: 500,
              fontSize: 'var(--font-size-sm)',
            },
          }, '再試行'),
          React.createElement('button', {
            onClick: () => this.handleReload(),
            style: {
              padding: '10px 24px', borderRadius: '8px', border: '1px solid rgba(255,255,255,0.15)',
              cursor: 'pointer', background: 'transparent', color: 'var(--text-secondary)',
              fontWeight: 500, fontSize: 'var(--font-size-sm)',
            },
          }, 'ページ再読み込み')
        )
      );
    }

    return this.props.children;
  }
};

})();

// ============================================================
// FILE: src/components/Map/GoogleMap.jsx
// ============================================================
(function() {
// GoogleMap.jsx - Google Maps 本体コンポーネント（TrafficLayer対応・高速ロード版）
const { useState, useEffect, useRef, useCallback } = React;

// ============================================================
// Google Maps スクリプトローダー（シングルトン）
// ============================================================
window._gmapLoader = {
  status: 'idle',
  loadedKey: null,
  callbacks: [],

  reset() {
    this.status = 'idle';
    this.loadedKey = null;
    this.callbacks = [];
    const s = document.querySelector('script[src*="maps.googleapis.com"]');
    if (s) s.remove();
    if (window.google) {
      try { delete window.google; } catch (e) { window.google = undefined; }
    }
  },

  load(apiKey) {
    return new Promise((resolve, reject) => {
      if (this.loadedKey && this.loadedKey !== apiKey) {
        this.reset();
      }
      if (window.google && window.google.maps && this.status === 'loaded' && this.loadedKey === apiKey) {
        resolve();
        return;
      }
      this.callbacks.push({ resolve, reject });
      if (this.status === 'loading') return;
      if (this.status === 'error') {
        const s = document.querySelector('script[src*="maps.googleapis.com"]');
        if (s) s.remove();
        if (window.google) {
          try { delete window.google; } catch (e) { window.google = undefined; }
        }
      }
      this.status = 'loading';
      const script = document.createElement('script');
      script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&language=ja&region=JP&v=weekly&libraries=visualization`;
      script.async = true;
      script.onload = () => {
        this.status = 'loaded';
        this.loadedKey = apiKey;
        this.callbacks.forEach(cb => cb.resolve());
        this.callbacks = [];
      };
      script.onerror = () => {
        this.status = 'error';
        this.loadedKey = null;
        script.remove();
        this.callbacks.forEach(cb => cb.reject(new Error('SCRIPT_LOAD_ERROR')));
        this.callbacks = [];
      };
      document.head.appendChild(script);
    });
  }
};

// Google Maps API エラー検出（console.errorからエラータイプを捕捉）
let _gmapErrorType = '';
const _origConsoleError = console.error;
console.error = function() {
  const msg = Array.from(arguments).join(' ');
  if (msg.includes('Google Maps JavaScript API error:')) {
    _gmapErrorType = msg.replace(/.*Google Maps JavaScript API error:\s*/, '').trim();
    if (typeof AppLogger !== 'undefined') {
      AppLogger.error('Google Maps APIエラー検出: ' + _gmapErrorType);
    }
  }
  _origConsoleError.apply(console, arguments);
};

window.gm_authFailure = () => {
  window._gmapLoader.status = 'error';
  window._gmapLoader.loadedKey = null;
  if (typeof AppLogger !== 'undefined') {
    AppLogger.error('Google Maps API 認証失敗 (gm_authFailure): エラータイプ=' + (_gmapErrorType || '不明'));
  }
  window.dispatchEvent(new CustomEvent('gmaps_auth_error', { detail: _gmapErrorType }));
};

// ============================================================
// メインコンポーネント
// ============================================================
window.GoogleMapView = ({ fullscreen = false }) => {
  const { apiKey } = useAppContext();
  const { mapCenter, zoom, currentPosition, accuracy, setMapCenter, setZoom } = useMapContext();
  const mapRef = useRef(null);
  const mapInstanceRef = useRef(null);
  const markerRef = useRef(null);
  const accuracyCircleRef = useRef(null);
  const trafficLayerRef = useRef(null);
  const heatmapLayerRef = useRef(null);
  const aiHeatmapLayerRef = useRef(null);
  const aiModelRef = useRef(null);
  const [mapLoaded, setMapLoaded] = useState(false);
  const [mapError, setMapError] = useState(null);
  const [showTraffic, setShowTraffic] = useState(true);
  const [showHeatmap, setShowHeatmap] = useState(false);
  const [showAiHeatmap, setShowAiHeatmap] = useState(false);
  const [aiTraining, setAiTraining] = useState(false);
  const [showPriceTier, setShowPriceTier] = useState(false);
  const [priceTierSource, setPriceTierSource] = useState('all');
  const priceTierMarkersRef = useRef([]);
  const [nearbyEstimate, setNearbyEstimate] = useState(null);
  const [showPricePredict, setShowPricePredict] = useState(false);
  const [priceTraining, setPriceTraining] = useState(false);
  const priceModelRef = useRef(null);
  const pricePredictMarkersRef = useRef([]);
  const [simHour, setSimHour] = useState(new Date().getHours());
  const [simMode, setSimMode] = useState(false);
  const initDone = useRef(false);
  const firstGpsDone = useRef(false);

  const [errorDetail, setErrorDetail] = useState(null);

  // Google Maps API 認証エラーを検知
  useEffect(() => {
    const handler = (e) => {
      const errorType = e.detail || _gmapErrorType || '';
      setErrorDetail(errorType);
      let msg = '';
      if (errorType.includes('ApiNotActivatedMapError')) {
        msg = '【Maps JavaScript API が無効です】\nGoogle Cloud Console → APIとサービス → ライブラリ\n→「Maps JavaScript API」を検索して「有効にする」を押してください。';
      } else if (errorType.includes('InvalidKeyMapError')) {
        msg = '【APIキーが無効です】\n設定画面でAPIキーが正しくコピーされているか確認してください。';
      } else if (errorType.includes('MissingKeyMapError')) {
        msg = '【APIキーがありません】\n設定画面からGoogle Maps APIキーを入力してください。';
      } else if (errorType.includes('RefererNotAllowedMapError')) {
        msg = '【HTTPリファラー制限エラー】\nGoogle Cloud Console → 認証情報 → APIキー → アプリケーションの制限\n→ リファラーに以下を追加してください:\n' + window.location.origin + '/*';
      } else if (errorType.includes('BillingNotEnabledMapError') || errorType.includes('OverQueryLimitMapError')) {
        msg = '【課金が有効になっていません】\nGoogle Cloud Console → お支払い → 請求先アカウントを設定してください。\n（月$200の無料枠あり）';
      } else if (errorType.includes('ExpiredKeyMapError')) {
        msg = '【APIキーの有効期限切れ】\nGoogle Cloud Console で新しいAPIキーを作成してください。';
      } else {
        msg = 'Google Maps API の認証に失敗しました。\n\n確認事項:\n1. APIキーが正しいか\n2. Maps JavaScript API が有効か\n3. Billing（課金）が設定されているか\n4. APIキーの制限設定';
        if (errorType) msg += '\n\nエラータイプ: ' + errorType;
      }
      setMapError(msg);
      setMapLoaded(false);
    };
    window.addEventListener('gmaps_auth_error', handler);
    return () => window.removeEventListener('gmaps_auth_error', handler);
  }, []);

  // Google Maps API をロード
  useEffect(() => {
    if (!apiKey) {
      setMapError(null);
      setMapLoaded(false);
      return;
    }

    // APIキー変更時にマップ状態をリセット
    initDone.current = false;
    mapInstanceRef.current = null;
    markerRef.current = null;
    accuracyCircleRef.current = null;
    trafficLayerRef.current = null;
    firstGpsDone.current = false;
    setMapLoaded(false);
    setMapError(null);

    let cancelled = false;
    window._gmapLoader.load(apiKey)
      .then(() => {
        if (!cancelled) {
          setMapLoaded(true);
          setMapError(null);
          AppLogger.info('Google Maps API ロード完了');
        }
      })
      .catch(() => {
        if (!cancelled) {
          setMapError('Google Maps API の読み込みに失敗しました。\nAPIキーとネットワーク接続を確認してください。');
          AppLogger.error('Google Maps API ロード失敗');
        }
      });
    return () => { cancelled = true; };
  }, [apiKey]);

  // マップ初期化
  useEffect(() => {
    if (!mapLoaded || !mapRef.current || !window.google || !window.google.maps || initDone.current) return;
    initDone.current = true;

    try {
      // GPS位置があればそこを初期中心に、なければデフォルト
      const initCenter = currentPosition || mapCenter;
      const initZoom = currentPosition ? 15 : zoom;

      const map = new google.maps.Map(mapRef.current, {
        center: initCenter,
        zoom: initZoom,
        mapTypeId: 'roadmap',
        disableDefaultUI: false,
        zoomControl: true,
        mapTypeControl: true,
        mapTypeControlOptions: {
          style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
          position: google.maps.ControlPosition.TOP_LEFT,
        },
        streetViewControl: false,
        fullscreenControl: false,
        scaleControl: true,
        gestureHandling: 'greedy',
      });
      mapInstanceRef.current = map;

      // 交通情報レイヤーを即座に追加
      const trafficLayer = new google.maps.TrafficLayer();
      trafficLayer.setMap(map);
      trafficLayerRef.current = trafficLayer;

      // GPS位置があれば初回マーカーも配置
      if (currentPosition) {
        firstGpsDone.current = true;
        _placeMarker(map, currentPosition);
      }

      // イベントリスナー（スロットリング付き）
      let centerTimer = null;
      map.addListener('center_changed', () => {
        clearTimeout(centerTimer);
        centerTimer = setTimeout(() => {
          const c = map.getCenter();
          setMapCenter({ lat: c.lat(), lng: c.lng() });
        }, 300);
      });
      map.addListener('zoom_changed', () => {
        setZoom(map.getZoom());
      });

      AppLogger.info('Google Maps 初期化完了（TrafficLayer有効）');
    } catch (e) {
      setMapError('Google Maps の初期化に失敗しました: ' + e.message);
      AppLogger.error('Google Maps 初期化エラー: ' + e.message);
    }
  }, [mapLoaded]);

  // 精度に応じた色を決定
  function _getAccuracyColor(acc) {
    if (!acc || acc <= 100) return '#4285F4';   // 青: 高精度
    if (acc <= 500) return '#F9A825';           // 黄: 中精度
    return '#E53935';                           // 赤: 低精度
  }

  // マーカー配置用のヘルパー
  function _placeMarker(map, pos) {
    const color = _getAccuracyColor(accuracy);
    if (!markerRef.current) {
      markerRef.current = new google.maps.Marker({
        position: pos,
        map: map,
        title: '現在地',
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 10,
          fillColor: color,
          fillOpacity: 1,
          strokeColor: '#ffffff',
          strokeWeight: 3,
        },
        zIndex: 999,
      });
      accuracyCircleRef.current = new google.maps.Circle({
        map: map,
        center: pos,
        radius: accuracy || 50,
        fillColor: color,
        fillOpacity: accuracy && accuracy > 500 ? 0.12 : 0.08,
        strokeColor: color,
        strokeOpacity: 0.3,
        strokeWeight: 1,
        clickable: false,
      });
    }
  }

  // 交通レイヤーの表示/非表示
  useEffect(() => {
    if (!trafficLayerRef.current || !mapInstanceRef.current) return;
    trafficLayerRef.current.setMap(showTraffic ? mapInstanceRef.current : null);
  }, [showTraffic]);

  // ヒートマップレイヤーの表示/非表示
  useEffect(() => {
    if (!mapInstanceRef.current || !window.google || !window.google.maps.visualization) return;
    const map = mapInstanceRef.current;

    if (showHeatmap) {
      const points = DataService.getHeatmapData();
      if (points.length === 0) return;
      const heatData = points.map(p => ({
        location: new google.maps.LatLng(p.lat, p.lng),
        weight: p.weight,
      }));
      if (heatmapLayerRef.current) {
        heatmapLayerRef.current.setMap(null);
      }
      heatmapLayerRef.current = new google.maps.visualization.HeatmapLayer({
        data: heatData,
        map: map,
        radius: 30,
        opacity: 0.7,
      });
    } else {
      if (heatmapLayerRef.current) {
        heatmapLayerRef.current.setMap(null);
        heatmapLayerRef.current = null;
      }
    }

    return () => {
      if (heatmapLayerRef.current) {
        heatmapLayerRef.current.setMap(null);
        heatmapLayerRef.current = null;
      }
    };
  }, [showHeatmap]);

  // AI予測ヒートマップの表示/非表示
  useEffect(() => {
    if (!mapInstanceRef.current || !window.google || !window.google.maps.visualization) return;
    const map = mapInstanceRef.current;

    if (!showAiHeatmap) {
      if (aiHeatmapLayerRef.current) {
        aiHeatmapLayerRef.current.setMap(null);
        aiHeatmapLayerRef.current = null;
      }
      return;
    }

    setAiTraining(true);
    // 非同期で学習・予測（UIブロック回避）
    setTimeout(() => {
      try {
        // モデルをキャッシュ、データ変更時はnullリセット
        if (!aiModelRef.current) {
          aiModelRef.current = LightGBMService.trainModel();
        }

        if (!aiModelRef.current) {
          setAiTraining(false);
          AppLogger.warn('AI予測: GPS付きデータが不足しています（5件以上必要）');
          setShowAiHeatmap(false);
          return;
        }

        // 現在の条件を取得（シミュレーションモード対応）
        const now = new Date();
        const hour = simMode ? simHour : now.getHours();
        const dow = now.getDay();
        const entries = DataService.getEntries();
        const latestWeather = entries.length > 0 ? (entries[0].weather || '') : '';

        // マップの表示範囲を取得
        const bounds = map.getBounds();
        if (!bounds) { setAiTraining(false); return; }
        const ne = bounds.getNorthEast();
        const sw = bounds.getSouthWest();
        const mapBounds = { north: ne.lat(), south: sw.lat(), east: ne.lng(), west: sw.lng() };

        const points = LightGBMService.predictGrid(aiModelRef.current, mapBounds, hour, dow, latestWeather);

        if (aiHeatmapLayerRef.current) {
          aiHeatmapLayerRef.current.setMap(null);
        }

        if (points.length > 0) {
          const heatData = points.map(p => ({
            location: new google.maps.LatLng(p.lat, p.lng),
            weight: p.weight,
          }));
          aiHeatmapLayerRef.current = new google.maps.visualization.HeatmapLayer({
            data: heatData,
            map: map,
            radius: 25,
            opacity: 0.6,
            gradient: [
              'rgba(0, 0, 0, 0)',
              'rgba(66, 133, 244, 0.3)',
              'rgba(0, 200, 255, 0.5)',
              'rgba(0, 230, 118, 0.6)',
              'rgba(255, 235, 59, 0.7)',
              'rgba(255, 152, 0, 0.85)',
              'rgba(244, 67, 54, 1)',
            ],
          });
          const info = LightGBMService.getModelInfo(aiModelRef.current);
          AppLogger.info(`AI需要予測: ${points.length}グリッド表示, ${info.nTrees}本の木, 基準値¥${info.basePrediction}`);
        } else {
          AppLogger.info('AI需要予測: 現在の条件では需要予測なし');
        }
      } catch (e) {
        AppLogger.error('AI予測エラー: ' + e.message);
      }
      setAiTraining(false);
    }, 50);

    return () => {
      if (aiHeatmapLayerRef.current) {
        aiHeatmapLayerRef.current.setMap(null);
        aiHeatmapLayerRef.current = null;
      }
    };
  }, [showAiHeatmap, simHour, simMode]);

  // 単価ランクマーカーレイヤーの表示/非表示
  useEffect(() => {
    // 既存マーカーをクリア
    priceTierMarkersRef.current.forEach(m => m.setMap(null));
    priceTierMarkersRef.current = [];
    setNearbyEstimate(null);

    if (!showPriceTier || !mapInstanceRef.current || !window.google) return;
    const map = mapInstanceRef.current;
    const src = priceTierSource === 'all' ? null : priceTierSource;
    const points = DataService.getPriceTierHeatmapData(src);

    if (points.length === 0) return;

    const tierColors = { short: '#4CAF50', mid: '#FFC107', long: '#F44336' };
    const tierLabels = { short: '短', mid: '中', long: '長' };

    points.forEach(p => {
      const marker = new google.maps.Marker({
        position: { lat: p.lat, lng: p.lng },
        map: map,
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          fillColor: tierColors[p.tier],
          fillOpacity: 0.7,
          strokeColor: '#fff',
          strokeWeight: 1,
          scale: p.tier === 'long' ? 10 : p.tier === 'mid' ? 8 : 6,
        },
        title: `¥${p.amount.toLocaleString()} (${p.source}) ${p.area}`,
        zIndex: p.tier === 'long' ? 3 : p.tier === 'mid' ? 2 : 1,
      });
      priceTierMarkersRef.current.push(marker);
    });

    // 現在位置の周辺推定
    const pos = currentPosition || mapCenter;
    if (pos && pos.lat && pos.lng) {
      setNearbyEstimate(DataService.getNearbyEstimate(pos.lat, pos.lng, 2));
    }

    return () => {
      priceTierMarkersRef.current.forEach(m => m.setMap(null));
      priceTierMarkersRef.current = [];
    };
  }, [showPriceTier, priceTierSource]);

  // AI単価予測レイヤーの表示/非表示
  useEffect(() => {
    pricePredictMarkersRef.current.forEach(m => m.setMap(null));
    pricePredictMarkersRef.current = [];

    if (!showPricePredict || !mapInstanceRef.current || !window.google) return;
    const map = mapInstanceRef.current;

    setPriceTraining(true);
    setTimeout(() => {
      try {
        if (!priceModelRef.current) {
          priceModelRef.current = LightGBMService.trainPriceModel();
        }
        if (!priceModelRef.current) {
          setPriceTraining(false);
          AppLogger.warn('単価予測: GPS+金額付きデータが不足しています（5件以上必要）');
          setShowPricePredict(false);
          return;
        }

        const bounds = map.getBounds();
        if (!bounds) { setPriceTraining(false); return; }
        const ne = bounds.getNorthEast();
        const sw = bounds.getSouthWest();
        const mapBounds = { north: ne.lat(), south: sw.lat(), east: ne.lng(), west: sw.lng() };

        const hour = simMode ? simHour : new Date().getHours();
        const dow = new Date().getDay();
        const entries = DataService.getEntries();
        const weather = entries.length > 0 ? (entries[0].weather || '') : '';

        const points = LightGBMService.predictPriceGrid(priceModelRef.current, mapBounds, hour, dow, weather);

        const tierColors = { short: '#4CAF50', mid: '#FFC107', long: '#F44336' };

        points.forEach(p => {
          const marker = new google.maps.Marker({
            position: { lat: p.lat, lng: p.lng },
            map: map,
            icon: {
              path: google.maps.SymbolPath.CIRCLE,
              fillColor: tierColors[p.tier],
              fillOpacity: 0.45,
              strokeColor: tierColors[p.tier],
              strokeWeight: 0.5,
              scale: p.tier === 'long' ? 14 : p.tier === 'mid' ? 11 : 8,
            },
            title: '予測単価: ¥' + p.price.toLocaleString(),
            clickable: false,
            zIndex: p.tier === 'long' ? 3 : p.tier === 'mid' ? 2 : 1,
          });
          pricePredictMarkersRef.current.push(marker);
        });

        const info = LightGBMService.getModelInfo(priceModelRef.current);
        AppLogger.info('AI単価予測: ' + points.length + 'グリッド表示, ' + info.nTrees + '本の木');
      } catch (e) {
        AppLogger.error('単価予測エラー: ' + e.message);
      }
      setPriceTraining(false);
    }, 50);

    return () => {
      pricePredictMarkersRef.current.forEach(m => m.setMap(null));
      pricePredictMarkersRef.current = [];
    };
  }, [showPricePredict, simHour, simMode]);

  // データ変更時にアクティブなレイヤーを自動更新
  useEffect(() => {
    const handler = () => {
      if (!mapInstanceRef.current || !window.google) return;
      const map = mapInstanceRef.current;

      // ヒートマップ再描画
      if (showHeatmap && window.google.maps.visualization) {
        const points = DataService.getHeatmapData();
        if (points.length > 0) {
          const heatData = points.map(p => ({
            location: new google.maps.LatLng(p.lat, p.lng),
            weight: p.weight,
          }));
          if (heatmapLayerRef.current) {
            heatmapLayerRef.current.setData(heatData);
          } else {
            heatmapLayerRef.current = new google.maps.visualization.HeatmapLayer({
              data: heatData, map: map, radius: 30, opacity: 0.7,
            });
          }
        } else if (heatmapLayerRef.current) {
          heatmapLayerRef.current.setData([]);
        }
      }

      // 単価マップ再描画
      if (showPriceTier) {
        priceTierMarkersRef.current.forEach(m => m.setMap(null));
        priceTierMarkersRef.current = [];
        const src = priceTierSource === 'all' ? null : priceTierSource;
        const pts = DataService.getPriceTierHeatmapData(src);
        const tierColors = { short: '#4CAF50', mid: '#FFC107', long: '#F44336' };
        pts.forEach(p => {
          const marker = new google.maps.Marker({
            position: { lat: p.lat, lng: p.lng },
            map: map,
            icon: {
              path: google.maps.SymbolPath.CIRCLE,
              fillColor: tierColors[p.tier],
              fillOpacity: 0.7,
              strokeColor: '#fff',
              strokeWeight: 1,
              scale: p.tier === 'long' ? 10 : p.tier === 'mid' ? 8 : 6,
            },
            title: `¥${p.amount.toLocaleString()} (${p.source}) ${p.area}`,
            zIndex: p.tier === 'long' ? 3 : p.tier === 'mid' ? 2 : 1,
          });
          priceTierMarkersRef.current.push(marker);
        });
        // 周辺推定更新
        const pos = currentPosition || mapCenter;
        if (pos && pos.lat && pos.lng) {
          setNearbyEstimate(DataService.getNearbyEstimate(pos.lat, pos.lng, 2));
        }
      }
    };
    window.addEventListener('taxi-data-changed', handler);
    return () => window.removeEventListener('taxi-data-changed', handler);
  }, [showHeatmap, showPriceTier, priceTierSource, currentPosition, mapCenter]);

  // 現在位置マーカー更新
  useEffect(() => {
    if (!mapInstanceRef.current || !currentPosition || !window.google) return;
    const map = mapInstanceRef.current;
    const color = _getAccuracyColor(accuracy);

    if (!markerRef.current) {
      _placeMarker(map, currentPosition);
    } else {
      markerRef.current.setPosition(currentPosition);
      // 精度に応じてマーカーの色を更新
      markerRef.current.setIcon({
        path: google.maps.SymbolPath.CIRCLE,
        scale: 10,
        fillColor: color,
        fillOpacity: 1,
        strokeColor: '#ffffff',
        strokeWeight: 3,
      });
      if (accuracyCircleRef.current) {
        accuracyCircleRef.current.setCenter(currentPosition);
        accuracyCircleRef.current.setOptions({
          radius: accuracy || 50,
          fillColor: color,
          strokeColor: color,
          fillOpacity: accuracy && accuracy > 500 ? 0.12 : 0.08,
        });
      }
    }

    // 初回GPS取得時: 中心を移動しズームを精度に応じて設定
    if (!firstGpsDone.current) {
      firstGpsDone.current = true;
      map.setCenter(currentPosition);
      // 精度が低い場合はズームを下げる
      const initZoom = accuracy && accuracy > 1000 ? 13 : accuracy && accuracy > 500 ? 14 : 15;
      map.setZoom(initZoom);
      AppLogger.info(`初回GPS: ${currentPosition.lat.toFixed(6)}, ${currentPosition.lng.toFixed(6)} 精度${Math.round(accuracy || 0)}m → zoom ${initZoom}`);
    } else {
      // 2回目以降はスムーズにパン
      map.panTo(currentPosition);
    }
  }, [currentPosition, accuracy]);

  // ============================================================
  // APIキーなしのデモモード
  // ============================================================
  if (!apiKey) {
    return React.createElement('div', {
      className: `map-container ${fullscreen ? 'map-container--fullscreen' : ''}`,
      style: {
        display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
        background: 'linear-gradient(135deg, var(--bg-medium), var(--bg-light))',
      },
    },
      React.createElement('span', {
        className: 'material-icons-round',
        style: { fontSize: '64px', color: 'var(--color-secondary)', marginBottom: '16px' },
      }, 'map'),
      React.createElement('h3', {
        style: { marginBottom: '8px', color: 'var(--text-primary)' },
      }, 'Google Maps デモモード'),
      React.createElement('p', {
        style: { color: 'var(--text-secondary)', textAlign: 'center', maxWidth: '400px', fontSize: 'var(--font-size-sm)' },
      }, '設定画面からGoogle Maps APIキーを入力すると、実際の地図と交通渋滞情報が表示されます。'),
      React.createElement('div', {
        style: {
          marginTop: '16px', padding: '12px 20px',
          background: 'rgba(255,255,255,0.06)', borderRadius: '8px',
          fontFamily: 'monospace', fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)',
        },
      },
        React.createElement('div', null, `中心: ${mapCenter.lat.toFixed(4)}, ${mapCenter.lng.toFixed(4)}`),
        React.createElement('div', null, `ズーム: ${zoom}`),
        currentPosition && React.createElement('div', {
          style: { color: 'var(--color-accent)', marginTop: '4px' },
        }, `GPS: ${currentPosition.lat.toFixed(6)}, ${currentPosition.lng.toFixed(6)}`)
      ),
      React.createElement(Button, {
        variant: 'primary', icon: 'settings',
        onClick: () => document.dispatchEvent(new CustomEvent('navigate', { detail: 'settings' })),
        style: { marginTop: '16px' },
      }, '設定を開く')
    );
  }

  // ============================================================
  // エラー画面
  // ============================================================
  if (mapError) {
    return React.createElement('div', {
      className: `map-container ${fullscreen ? 'map-container--fullscreen' : ''}`,
      style: { display: 'flex', alignItems: 'center', justifyContent: 'center', flexDirection: 'column', gap: '12px', padding: '24px', overflow: 'auto' },
    },
      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '48px', color: 'var(--color-danger)' } }, 'error'),
      React.createElement('p', { style: { color: 'var(--color-danger)', textAlign: 'center', whiteSpace: 'pre-line', fontSize: 'var(--font-size-sm)', lineHeight: '1.8' } }, mapError),
      React.createElement('div', {
        style: { marginTop: '8px', padding: '8px 14px', background: 'rgba(255,255,255,0.06)', borderRadius: '6px', fontSize: '11px', color: 'var(--text-muted)', wordBreak: 'break-all' },
      },
        React.createElement('div', null, '現在のURL: ' + window.location.origin),
        errorDetail && React.createElement('div', { style: { marginTop: '4px', color: 'var(--color-secondary)' } }, 'Error: ' + errorDetail)
      ),
      React.createElement('div', { style: { display: 'flex', gap: '8px', marginTop: '8px' } },
        React.createElement(Button, {
          variant: 'primary', icon: 'refresh',
          onClick: () => { window._gmapLoader.reset(); _gmapErrorType = ''; setErrorDetail(null); setMapError(null); setMapLoaded(false); },
        }, '再試行'),
        React.createElement(Button, {
          variant: 'secondary', icon: 'settings',
          onClick: () => document.dispatchEvent(new CustomEvent('navigate', { detail: 'settings' })),
        }, '設定を確認')
      )
    );
  }

  // ============================================================
  // メイン地図表示
  // ============================================================
  return React.createElement('div', null,
    // 地図コンテナ
    React.createElement('div', {
      ref: mapRef,
      className: `map-container ${fullscreen ? 'map-container--fullscreen' : ''}`,
      style: { minHeight: '450px', position: 'relative' },
    },
      !mapLoaded && React.createElement(Loading, { message: '地図を読み込み中...' }),
      // 精度低下警告オーバーレイ（地図上に表示）
      mapLoaded && accuracy && accuracy > 1000 && React.createElement('div', {
        style: {
          position: 'absolute', top: '8px', left: '50%', transform: 'translateX(-50%)',
          zIndex: 5, background: 'rgba(229,57,53,0.9)', color: '#fff',
          padding: '6px 14px', borderRadius: '20px', fontSize: '11px', fontWeight: '700',
          display: 'flex', alignItems: 'center', gap: '4px', whiteSpace: 'nowrap',
          boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
        },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'gps_off'),
        `位置精度: 約${Math.round(accuracy / 100) / 10}km（低精度）`
      )
    ),

    // マップ操作パネル（マップの外・下に表示）
    mapLoaded && React.createElement('div', {
      style: {
        marginTop: 'var(--space-md)',
        background: 'rgba(26, 26, 46, 0.95)',
        borderRadius: 'var(--border-radius-sm)',
        padding: 'var(--space-md)',
        border: '1px solid rgba(255,255,255,0.1)',
      },
    },
      // ボタン行
      React.createElement('div', {
        style: {
          display: 'flex', flexWrap: 'wrap', gap: '8px', alignItems: 'center',
        },
      },
        // 渋滞情報トグルボタン
        React.createElement('button', {
          onClick: () => setShowTraffic(prev => !prev),
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 14px', borderRadius: '8px',
            fontSize: '12px', fontWeight: '700',
            color: '#fff', cursor: 'pointer',
            border: showTraffic ? 'none' : '1px solid rgba(255,255,255,0.2)',
            background: showTraffic ? '#ef4444' : 'rgba(255,255,255,0.08)',
            transition: 'all 0.2s ease',
          },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'traffic'),
          `渋滞情報 ${showTraffic ? 'ON' : 'OFF'}`
        ),

        // 現在地に移動ボタン
        currentPosition && React.createElement('button', {
          onClick: () => {
            if (mapInstanceRef.current && currentPosition) {
              mapInstanceRef.current.setCenter(currentPosition);
              mapInstanceRef.current.setZoom(15);
            }
          },
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 14px', borderRadius: '8px',
            fontSize: '12px', fontWeight: '700',
            color: '#fff', cursor: 'pointer',
            border: '1px solid rgba(255,255,255,0.2)',
            background: 'rgba(255,255,255,0.08)',
            transition: 'all 0.2s ease',
          },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'my_location'),
          '現在地'
        ),

        // Google Mapsで開く
        React.createElement('a', {
          href: `https://www.google.com/maps/@${mapCenter.lat},${mapCenter.lng},${zoom}z/data=!5m1!1e1`,
          target: '_blank', rel: 'noreferrer',
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 14px', borderRadius: '8px',
            fontSize: '12px', fontWeight: '700', textDecoration: 'none',
            color: '#fff', border: '1px solid rgba(255,255,255,0.2)',
            background: 'rgba(255,255,255,0.08)',
          },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'open_in_new'),
          'Google Mapsで開く'
        ),

        // 需要ヒートマップトグル
        React.createElement('button', {
          onClick: () => {
            const pts = DataService.getHeatmapData();
            if (pts.length === 0 && !showHeatmap) {
              AppLogger.warn('GPS付き乗車データを記録するとヒートマップが表示されます');
              return;
            }
            setShowHeatmap(prev => !prev);
          },
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 14px', borderRadius: '8px',
            fontSize: '12px', fontWeight: '700',
            color: '#fff', cursor: 'pointer',
            border: showHeatmap ? 'none' : '1px solid rgba(255,255,255,0.2)',
            background: showHeatmap ? '#f59e0b' : 'rgba(255,255,255,0.08)',
            transition: 'all 0.2s ease',
          },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'whatshot'),
          `ヒートマップ ${showHeatmap ? 'ON' : 'OFF'}`
        ),

        // AI需要予測トグル
        React.createElement('button', {
          onClick: () => {
            if (showAiHeatmap) {
              setShowAiHeatmap(false);
            } else {
              aiModelRef.current = null; // 再学習
              setShowAiHeatmap(true);
            }
          },
          disabled: aiTraining,
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 14px', borderRadius: '8px',
            fontSize: '12px', fontWeight: '700',
            color: '#fff', cursor: aiTraining ? 'wait' : 'pointer',
            border: showAiHeatmap ? 'none' : '1px solid rgba(255,255,255,0.2)',
            background: showAiHeatmap ? '#8b5cf6' : 'rgba(255,255,255,0.08)',
            transition: 'all 0.2s ease',
            opacity: aiTraining ? 0.7 : 1,
          },
        },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '16px', animation: aiTraining ? 'spin 1s linear infinite' : 'none' },
          }, aiTraining ? 'sync' : 'psychology'),
          aiTraining ? 'LightGBM 学習中...' : `AI予測 ${showAiHeatmap ? 'ON' : 'OFF'}`
        ),

        // 単価マップトグル
        React.createElement('button', {
          onClick: () => {
            const pts = DataService.getPriceTierHeatmapData(null);
            if (pts.length === 0 && !showPriceTier) {
              AppLogger.warn('GPS付き乗車データを記録すると単価マップが表示されます');
              return;
            }
            setShowPriceTier(prev => !prev);
          },
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 14px', borderRadius: '8px',
            fontSize: '12px', fontWeight: '700',
            color: '#fff', cursor: 'pointer',
            border: showPriceTier ? 'none' : '1px solid rgba(255,255,255,0.2)',
            background: showPriceTier ? '#10b981' : 'rgba(255,255,255,0.08)',
            transition: 'all 0.2s ease',
          },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'paid'),
          `単価マップ ${showPriceTier ? 'ON' : 'OFF'}`
        ),

        // AI単価予測トグル
        React.createElement('button', {
          onClick: () => {
            if (showPricePredict) {
              setShowPricePredict(false);
            } else {
              priceModelRef.current = null;
              setShowPricePredict(true);
            }
          },
          disabled: priceTraining,
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 14px', borderRadius: '8px',
            fontSize: '12px', fontWeight: '700',
            color: '#fff', cursor: priceTraining ? 'wait' : 'pointer',
            border: showPricePredict ? 'none' : '1px solid rgba(255,255,255,0.2)',
            background: showPricePredict ? '#ec4899' : 'rgba(255,255,255,0.08)',
            transition: 'all 0.2s ease',
            opacity: priceTraining ? 0.7 : 1,
          },
        },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '16px', animation: priceTraining ? 'spin 1s linear infinite' : 'none' },
          }, priceTraining ? 'sync' : 'auto_awesome'),
          priceTraining ? '単価学習中...' : `AI単価予測 ${showPricePredict ? 'ON' : 'OFF'}`
        )
      ),

      // 時間帯シミュレーション スライダー
      (showAiHeatmap || showPricePredict) && React.createElement('div', {
        style: {
          marginTop: '8px', padding: '10px 12px', borderRadius: '8px',
          background: 'rgba(236,72,153,0.08)', border: '1px solid rgba(236,72,153,0.25)',
        },
      },
        React.createElement('div', {
          style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '6px' },
        },
          React.createElement('div', {
            style: { display: 'flex', alignItems: 'center', gap: '6px' },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: '#ec4899' } }, 'schedule'),
            React.createElement('span', { style: { fontSize: '12px', fontWeight: 600, color: '#ec4899' } }, '時間帯シミュレーション')
          ),
          React.createElement('button', {
            onClick: () => {
              const next = !simMode;
              setSimMode(next);
              if (!next) {
                setSimHour(new Date().getHours());
              }
            },
            style: {
              padding: '3px 10px', borderRadius: '12px', border: 'none', cursor: 'pointer',
              fontSize: '11px', fontWeight: 600, fontFamily: 'var(--font-family)',
              background: simMode ? '#ec4899' : 'rgba(255,255,255,0.1)',
              color: simMode ? '#fff' : 'var(--text-secondary)',
            },
          }, simMode ? 'シミュレーションON' : 'OFF（現在時刻）')
        ),

        // スライダー
        React.createElement('div', {
          style: { display: 'flex', alignItems: 'center', gap: '8px' },
        },
          React.createElement('span', { style: { fontSize: '11px', color: 'var(--text-muted)', minWidth: '24px' } }, '0時'),
          React.createElement('input', {
            type: 'range', min: 0, max: 23, step: 1,
            value: simHour,
            onChange: (e) => { setSimMode(true); setSimHour(parseInt(e.target.value, 10)); },
            style: { flex: 1, accentColor: '#ec4899' },
          }),
          React.createElement('span', { style: { fontSize: '11px', color: 'var(--text-muted)', minWidth: '30px' } }, '23時')
        ),

        React.createElement('div', {
          style: { textAlign: 'center', marginTop: '4px' },
        },
          React.createElement('span', {
            style: { fontSize: '16px', fontWeight: 700, color: simMode ? '#ec4899' : 'var(--text-secondary)' },
          }, simHour + '時台'),
          !simMode && React.createElement('span', {
            style: { fontSize: '11px', color: 'var(--text-muted)', marginLeft: '8px' },
          }, '（現在時刻）'),
          simMode && React.createElement('span', {
            style: { fontSize: '11px', color: '#ec4899', marginLeft: '8px' },
          }, (() => {
            const diff = simHour - new Date().getHours();
            if (diff === 0) return '（現在）';
            return diff > 0 ? '（' + diff + '時間後）' : '（' + Math.abs(diff) + '時間前）';
          })())
        )
      ),

      // AI予測 情報メッセージ
      showAiHeatmap && !aiTraining && React.createElement('div', {
        style: {
          marginTop: '8px', padding: '8px 12px', borderRadius: '6px',
          background: 'rgba(139,92,246,0.1)', border: '1px solid rgba(139,92,246,0.3)',
          fontSize: 'var(--font-size-xs)', color: '#a78bfa',
          display: 'flex', alignItems: 'center', gap: '6px',
        },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'psychology'),
        (() => {
          const now = new Date();
          const days = ['日', '月', '火', '水', '木', '金', '土'];
          const entries = DataService.getEntries();
          const w = entries.length > 0 ? (entries[0].weather || '未設定') : '未設定';
          const hr = simMode ? simHour : now.getHours();
          return `LightGBM予測: ${days[now.getDay()]}曜 ${hr}時 ${w} の需要分布${simMode ? ' (シミュレーション)' : ''}`;
        })()
      ),

      // ヒートマップ データなしメッセージ
      showHeatmap && DataService.getHeatmapData().length === 0 && React.createElement('div', {
        style: {
          marginTop: '8px', padding: '8px 12px', borderRadius: '6px',
          background: 'rgba(245,158,11,0.1)', border: '1px solid rgba(245,158,11,0.3)',
          fontSize: 'var(--font-size-xs)', color: '#f59e0b',
          display: 'flex', alignItems: 'center', gap: '6px',
        },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'info'),
        'GPS付き乗車データを記録するとヒートマップが表示されます'
      ),

      // AI単価予測 情報メッセージ
      showPricePredict && !priceTraining && React.createElement('div', {
        style: {
          marginTop: '8px', padding: '8px 12px', borderRadius: '6px',
          background: 'rgba(236,72,153,0.1)', border: '1px solid rgba(236,72,153,0.3)',
          fontSize: 'var(--font-size-xs)', color: '#f472b6',
        },
      },
        React.createElement('div', {
          style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '4px' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'auto_awesome'),
          (() => {
            const hr = simMode ? simHour : new Date().getHours();
            const days = ['日', '月', '火', '水', '木', '金', '土'];
            return 'AI単価予測: ' + days[new Date().getDay()] + '曜 ' + hr + '時' + (simMode ? ' (シミュレーション)' : '');
          })()
        ),
        React.createElement('div', {
          style: { display: 'flex', gap: '10px', fontSize: '10px', color: 'var(--text-secondary)' },
        },
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '3px' } },
            React.createElement('span', { style: { width: '8px', height: '8px', borderRadius: '50%', background: '#4CAF50', display: 'inline-block' } }),
            '¥1,000以下'
          ),
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '3px' } },
            React.createElement('span', { style: { width: '10px', height: '10px', borderRadius: '50%', background: '#FFC107', display: 'inline-block' } }),
            '¥1,001〜1,999'
          ),
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '3px' } },
            React.createElement('span', { style: { width: '12px', height: '12px', borderRadius: '50%', background: '#F44336', display: 'inline-block' } }),
            '¥2,000以上'
          )
        )
      ),

      // 単価マップ表示時: 配車方法フィルター + 周辺推定 + 凡例
      showPriceTier && React.createElement('div', {
        style: {
          marginTop: '8px', padding: '10px 12px', borderRadius: '8px',
          background: 'rgba(16,185,129,0.08)', border: '1px solid rgba(16,185,129,0.25)',
        },
      },
        // 配車方法フィルター
        React.createElement('div', {
          style: { display: 'flex', gap: '4px', flexWrap: 'wrap', marginBottom: '8px' },
        },
          React.createElement('span', {
            style: { fontSize: '11px', fontWeight: 600, color: 'var(--text-secondary)', display: 'flex', alignItems: 'center', marginRight: '4px' },
          }, '配車方法:'),
          ...['all', 'Go', 'Uber', 'DIDI', '電話', '流し'].map(s =>
            React.createElement('button', {
              key: s,
              onClick: () => setPriceTierSource(s),
              style: {
                padding: '3px 10px', borderRadius: '12px', border: 'none', cursor: 'pointer',
                fontSize: '11px', fontWeight: 600, fontFamily: 'var(--font-family)',
                background: priceTierSource === s ? '#10b981' : 'rgba(255,255,255,0.1)',
                color: priceTierSource === s ? '#fff' : 'var(--text-secondary)',
                transition: 'all 0.15s ease',
              },
            }, s === 'all' ? '全て' : s)
          )
        ),

        // 周辺推定
        nearbyEstimate && nearbyEstimate.count > 0 && React.createElement('div', {
          style: {
            padding: '8px', borderRadius: '6px', background: 'rgba(0,0,0,0.2)',
            marginBottom: '8px',
          },
        },
          React.createElement('div', {
            style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '6px' },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: '#10b981' } }, 'near_me'),
            React.createElement('span', { style: { fontSize: '12px', fontWeight: 600, color: '#10b981' } }, '現在地周辺（半径2km）')
          ),
          React.createElement('div', {
            style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '6px', fontSize: '11px' },
          },
            React.createElement('div', null,
              React.createElement('span', { style: { color: 'var(--text-muted)' } }, '推定客単価 '),
              React.createElement('span', { style: { fontWeight: 700, color: '#fff', fontSize: '14px' } }, '¥' + nearbyEstimate.avgPrice.toLocaleString())
            ),
            React.createElement('div', null,
              React.createElement('span', { style: { color: 'var(--text-muted)' } }, '過去データ '),
              React.createElement('span', { style: { fontWeight: 600, color: '#fff' } }, nearbyEstimate.count + '件')
            ),
            React.createElement('div', null,
              React.createElement('span', { style: { color: 'var(--text-muted)' } }, '単価構成 '),
              React.createElement('span', { style: { color: '#4CAF50' } }, '短' + nearbyEstimate.tierCounts.short),
              ' ',
              React.createElement('span', { style: { color: '#FFC107' } }, '中' + nearbyEstimate.tierCounts.mid),
              ' ',
              React.createElement('span', { style: { color: '#F44336' } }, '長' + nearbyEstimate.tierCounts.long)
            ),
            nearbyEstimate.topArea && React.createElement('div', null,
              React.createElement('span', { style: { color: 'var(--text-muted)' } }, '最多エリア '),
              React.createElement('span', { style: { fontWeight: 600, color: '#fff' } }, nearbyEstimate.topArea)
            )
          ),
          // 配車方法内訳
          Object.keys(nearbyEstimate.sources).length > 0 && React.createElement('div', {
            style: { marginTop: '6px', display: 'flex', gap: '6px', flexWrap: 'wrap' },
          },
            ...Object.entries(nearbyEstimate.sources).sort((a, b) => b[1] - a[1]).map(([src, cnt]) =>
              React.createElement('span', {
                key: src,
                style: { fontSize: '10px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(255,255,255,0.1)', color: 'var(--text-secondary)' },
              }, src + ' ' + cnt + '件')
            )
          )
        ),

        // 凡例
        React.createElement('div', {
          style: { display: 'flex', gap: '12px', alignItems: 'center', fontSize: '11px' },
        },
          React.createElement('span', { style: { fontWeight: 600, color: 'var(--text-secondary)' } }, '凡例:'),
          ...[
            { c: '#4CAF50', l: '¥1,000以下', s: 6 },
            { c: '#FFC107', l: '¥1,001〜1,999', s: 8 },
            { c: '#F44336', l: '¥2,000以上', s: 10 },
          ].map(item =>
            React.createElement('span', {
              key: item.l,
              style: { display: 'flex', alignItems: 'center', gap: '3px' },
            },
              React.createElement('span', {
                style: { display: 'inline-block', width: item.s * 2 + 'px', height: item.s * 2 + 'px', borderRadius: '50%', background: item.c, opacity: 0.7 },
              }),
              React.createElement('span', { style: { color: 'var(--text-secondary)' } }, item.l)
            )
          )
        )
      ),

      // 渋滞凡例
      showTraffic && React.createElement('div', {
        style: {
          marginTop: '10px', paddingTop: '10px',
          borderTop: '1px solid rgba(255,255,255,0.08)',
          display: 'flex', flexWrap: 'wrap', gap: '10px', alignItems: 'center',
        },
      },
        React.createElement('span', {
          style: { fontSize: '11px', fontWeight: '600', color: 'var(--text-secondary)' },
        }, '渋滞:'),
        ...[
          { c: '#22c55e', l: 'スムーズ' },
          { c: '#f59e0b', l: 'やや混雑' },
          { c: '#f97316', l: '混雑' },
          { c: '#ef4444', l: '渋滞' },
          { c: '#7f1d1d', l: '大渋滞' },
        ].map(item =>
          React.createElement('span', {
            key: item.l,
            style: { display: 'flex', alignItems: 'center', gap: '3px' },
          },
            React.createElement('span', {
              style: { display: 'inline-block', width: '18px', height: '4px', borderRadius: '2px', background: item.c },
            }),
            React.createElement('span', { style: { fontSize: '10px', color: 'var(--text-secondary)' } }, item.l)
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/components/Map/GpsTracker.jsx
// ============================================================
(function() {
// GpsTracker.jsx - GPS追跡パネル
window.GpsTracker = () => {
  const { currentPosition, isTracking, gpsError, accuracy, speed, heading } = useMapContext();
  const geo = useGeolocation();

  const formatCoord = (val) => val ? val.toFixed(6) : '---';
  const formatAccuracy = (val) => {
    if (!val) return '---';
    const m = Math.round(val);
    if (m <= 100) return `${m}m (高精度)`;
    if (m <= 500) return `${m}m (中精度)`;
    return `${m}m (低精度)`;
  };
  const formatSpeed = (val) => val !== null && val !== undefined ? `${(val * 3.6).toFixed(1)} km/h` : '---';
  const formatHeading = (val) => {
    if (val === null || val === undefined) return '---';
    const dirs = ['北', '北東', '東', '南東', '南', '南西', '西', '北西'];
    return dirs[Math.round(val / 45) % 8] + ` (${Math.round(val)}°)`;
  };

  return React.createElement('div', { className: 'gps-panel' },
    // ステータス行
    React.createElement('div', {
      style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' },
    },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: isTracking ? 'var(--color-accent)' : 'var(--text-muted)' },
        }, isTracking ? 'gps_fixed' : 'gps_not_fixed'),
        React.createElement('span', {
          className: `badge ${isTracking ? 'badge--success' : 'badge--warning'}`,
        }, isTracking ? 'GPS追跡中' : 'GPS停止中')
      ),
      React.createElement('div', { style: { display: 'flex', gap: '4px' } },
        !isTracking && React.createElement(Button, {
          variant: 'primary',
          icon: 'my_location',
          onClick: () => { geo.getCurrentPosition(); },
          style: { padding: '4px 12px', fontSize: '12px' },
        }, '現在地'),
        React.createElement(Button, {
          variant: isTracking ? 'danger' : 'success',
          icon: isTracking ? 'stop' : 'play_arrow',
          onClick: () => isTracking ? geo.stopTracking() : geo.startTracking(),
          style: { padding: '4px 12px', fontSize: '12px' },
        }, isTracking ? '停止' : '追跡開始')
      )
    ),

    // エラー表示
    gpsError && React.createElement('div', {
      style: { color: 'var(--color-danger)', fontSize: 'var(--font-size-xs)', marginBottom: '6px', display: 'flex', alignItems: 'center', gap: '4px' },
    },
      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'warning'),
      gpsError
    ),

    // PC環境での精度警告
    accuracy && accuracy > 500 && React.createElement('div', {
      style: {
        color: accuracy > 1000 ? 'var(--color-danger)' : 'var(--color-warning)',
        fontSize: 'var(--font-size-xs)', marginBottom: '6px',
        display: 'flex', alignItems: 'center', gap: '4px',
        background: accuracy > 1000 ? 'rgba(229,57,53,0.1)' : 'rgba(249,168,37,0.1)',
        padding: '4px 8px', borderRadius: '4px',
      },
    },
      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'info'),
      'PCではGPSがないため位置精度が低くなります。スマートフォンでの利用を推奨します。'
    ),

    // 位置情報
    React.createElement('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px 16px' } },
      React.createElement('div', { className: 'gps-panel__row' },
        React.createElement('span', { className: 'gps-panel__label' }, '緯度'),
        React.createElement('span', { className: 'gps-panel__value' }, formatCoord(currentPosition?.lat))
      ),
      React.createElement('div', { className: 'gps-panel__row' },
        React.createElement('span', { className: 'gps-panel__label' }, '経度'),
        React.createElement('span', { className: 'gps-panel__value' }, formatCoord(currentPosition?.lng))
      ),
      React.createElement('div', { className: 'gps-panel__row' },
        React.createElement('span', { className: 'gps-panel__label' }, '精度'),
        React.createElement('span', {
          className: 'gps-panel__value',
          style: { color: !accuracy ? undefined : accuracy <= 100 ? 'var(--color-accent)' : accuracy <= 500 ? 'var(--color-warning)' : 'var(--color-danger)' },
        }, formatAccuracy(accuracy))
      ),
      React.createElement('div', { className: 'gps-panel__row' },
        React.createElement('span', { className: 'gps-panel__label' }, '速度'),
        React.createElement('span', { className: 'gps-panel__value' }, formatSpeed(speed))
      ),
      React.createElement('div', { className: 'gps-panel__row' },
        React.createElement('span', { className: 'gps-panel__label' }, '方角'),
        React.createElement('span', { className: 'gps-panel__value' }, formatHeading(heading))
      )
    )
  );
};

})();

// ============================================================
// FILE: src/components/Map/MapControls.jsx
// ============================================================
(function() {
// MapControls.jsx - 地図操作コントロール
//
// 地図上に表示する操作ボタン群（渋滞情報トグル、現在地移動、外部マップ起動）

window.MapControls = ({
  showTraffic,
  onToggleTraffic,
  onCenterToPosition,
  currentPosition,
  mapCenter,
  zoom,
}) => {
  const controlBtnBase = {
    display: 'flex',
    alignItems: 'center',
    gap: '6px',
    padding: '8px 14px',
    borderRadius: '8px',
    fontSize: '12px',
    fontWeight: '700',
    color: '#fff',
    cursor: 'pointer',
    border: '1px solid rgba(255,255,255,0.2)',
    background: 'rgba(26,26,46,0.85)',
    boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
    backdropFilter: 'blur(8px)',
    transition: 'all 0.2s ease',
  };

  return React.createElement('div', {
    style: {
      position: 'absolute',
      top: '12px',
      right: '12px',
      display: 'flex',
      flexDirection: 'column',
      gap: '6px',
      zIndex: 5,
    },
  },
    // 渋滞情報トグル
    React.createElement('button', {
      onClick: onToggleTraffic,
      style: {
        ...controlBtnBase,
        border: showTraffic ? 'none' : controlBtnBase.border,
        background: showTraffic ? '#ef4444' : controlBtnBase.background,
      },
    },
      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'traffic'),
      `渋滞情報 ${showTraffic ? 'ON' : 'OFF'}`
    ),

    // 現在地に移動
    currentPosition && React.createElement('button', {
      onClick: onCenterToPosition,
      style: controlBtnBase,
    },
      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'my_location'),
      '現在地'
    ),

    // Google Mapsで開く
    React.createElement('a', {
      href: `https://www.google.com/maps/@${mapCenter.lat},${mapCenter.lng},${zoom}z/data=!5m1!1e1`,
      target: '_blank',
      rel: 'noreferrer',
      style: { ...controlBtnBase, textDecoration: 'none' },
    },
      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'open_in_new'),
      'Google Mapsで開く'
    )
  );
};

// 渋滞凡例コンポーネント
window.TrafficLegend = ({ visible }) => {
  if (!visible) return null;

  const items = [
    { c: '#22c55e', l: 'スムーズ' },
    { c: '#f59e0b', l: 'やや混雑' },
    { c: '#f97316', l: '混雑' },
    { c: '#ef4444', l: '渋滞' },
    { c: '#7f1d1d', l: '大渋滞' },
  ];

  return React.createElement('div', {
    style: {
      position: 'absolute',
      bottom: '12px',
      left: '12px',
      background: 'rgba(255,255,255,0.92)',
      borderRadius: '8px',
      padding: '6px 10px',
      display: 'flex',
      gap: '8px',
      alignItems: 'center',
      boxShadow: '0 1px 4px rgba(0,0,0,0.2)',
      zIndex: 5,
    },
  },
    React.createElement('span', {
      style: { fontSize: '11px', fontWeight: '600', color: '#333' },
    }, '渋滞:'),
    ...items.map(item =>
      React.createElement('span', {
        key: item.l,
        style: { display: 'flex', alignItems: 'center', gap: '3px' },
      },
        React.createElement('span', {
          style: { display: 'inline-block', width: '18px', height: '4px', borderRadius: '2px', background: item.c },
        }),
        React.createElement('span', { style: { fontSize: '10px', color: '#555' } }, item.l)
      )
    )
  );
};

})();

// ============================================================
// FILE: src/components/Layout/Header.jsx
// ============================================================
(function() {
// Header.jsx - ヘッダーナビゲーション
window.Header = () => {
  const { currentPage, navigate, sidebarOpen, setSidebarOpen } = useAppContext();

  return React.createElement('header', { className: 'header' },
    // メニュートグル（モバイル）
    React.createElement('button', {
      className: 'header__menu-toggle',
      onClick: () => setSidebarOpen(!sidebarOpen),
    },
      React.createElement('span', { className: 'material-icons-round' }, sidebarOpen ? 'close' : 'menu')
    ),

    // ロゴ
    React.createElement('div', {
      className: 'header__logo',
      onClick: () => navigate('dashboard'),
    },
      React.createElement('span', { className: 'material-icons-round' }, 'local_taxi'),
      React.createElement('span', null, 'タクシー売上サポート')
    ),

    // ナビゲーション（PC用）
    React.createElement('nav', { className: 'header__nav' },
      APP_CONSTANTS.NAV_ITEMS.map(item =>
        React.createElement('button', {
          key: item.id,
          className: `header__nav-btn ${currentPage === item.id ? 'active' : ''}`,
          onClick: () => navigate(item.id),
        },
          React.createElement('span', { className: 'material-icons-round' }, item.icon),
          React.createElement('span', null, item.label)
        )
      ),
      // 情報セクション セパレーター + 項目
      React.createElement('span', {
        style: { display: 'inline-block', width: '1px', height: '24px', background: 'rgba(255,255,255,0.1)', margin: '0 4px', verticalAlign: 'middle' },
      }),
      APP_CONSTANTS.INFO_NAV_ITEMS.map(item =>
        React.createElement('button', {
          key: item.id,
          className: `header__nav-btn ${currentPage === item.id ? 'active' : ''}`,
          onClick: () => navigate(item.id),
        },
          React.createElement('span', { className: 'material-icons-round' }, item.icon),
          React.createElement('span', null, item.label)
        )
      ),
      // 開発者ツールボタン
      React.createElement('button', {
        className: `header__nav-btn ${currentPage.startsWith('dev') ? 'active' : ''}`,
        onClick: () => navigate('dev'),
        style: { marginLeft: '8px', borderLeft: '1px solid rgba(255,255,255,0.1)', paddingLeft: '16px' },
      },
        React.createElement('span', { className: 'material-icons-round' }, 'code'),
        React.createElement('span', null, '開発者')
      )
    )
  );
};

})();

// ============================================================
// FILE: src/components/Layout/Sidebar.jsx
// ============================================================
(function() {
// Sidebar.jsx - PC用サイドバー
window.Sidebar = () => {
  const { currentPage, navigate, sidebarOpen } = useAppContext();

  const devItems = [
    { id: 'dev', label: '開発者ツール', icon: 'code' },
    { id: 'dev-structure', label: 'サイト構造', icon: 'account_tree' },
    { id: 'dev-logs', label: 'ログビューア', icon: 'terminal' },
    { id: 'dev-api', label: 'API状態', icon: 'cloud' },
  ];

  return React.createElement('aside', {
    className: `sidebar ${sidebarOpen ? 'open' : ''}`,
  },
    // メインナビ
    React.createElement('div', { className: 'sidebar__section' },
      React.createElement('div', { className: 'sidebar__section-title' }, 'メインメニュー'),
      APP_CONSTANTS.NAV_ITEMS.map(item =>
        React.createElement('button', {
          key: item.id,
          className: `sidebar__item ${currentPage === item.id ? 'active' : ''}`,
          onClick: () => navigate(item.id),
        },
          React.createElement('span', { className: 'material-icons-round' }, item.icon),
          item.label
        )
      )
    ),

    // 情報
    React.createElement('div', { className: 'sidebar__section' },
      React.createElement('div', { className: 'sidebar__section-title' }, '情報'),
      APP_CONSTANTS.INFO_NAV_ITEMS.map(item =>
        React.createElement('button', {
          key: item.id,
          className: `sidebar__item ${currentPage === item.id ? 'active' : ''}`,
          onClick: () => navigate(item.id),
        },
          React.createElement('span', { className: 'material-icons-round' }, item.icon),
          item.label
        )
      )
    ),

    // 開発者ツール
    React.createElement('div', { className: 'sidebar__section' },
      React.createElement('div', { className: 'sidebar__section-title' }, '開発者ツール'),
      devItems.map(item =>
        React.createElement('button', {
          key: item.id,
          className: `sidebar__item ${currentPage === item.id ? 'active' : ''}`,
          onClick: () => navigate(item.id),
        },
          React.createElement('span', { className: 'material-icons-round' }, item.icon),
          item.label
        )
      )
    ),

    // バージョン
    React.createElement('div', {
      style: {
        padding: 'var(--space-md)',
        marginTop: 'auto',
        fontSize: 'var(--font-size-xs)',
        color: 'var(--text-muted)',
        textAlign: 'center',
      },
    }, `v${APP_CONSTANTS.VERSION}`)
  );
};

})();

// ============================================================
// FILE: src/components/Layout/BottomNav.jsx
// ============================================================
(function() {
// BottomNav.jsx - モバイル用ボトムナビゲーション
window.BottomNav = () => {
  const { currentPage, navigate } = useAppContext();

  return React.createElement('nav', { className: 'bottom-nav' },
    React.createElement('div', { className: 'bottom-nav__items' },
      APP_CONSTANTS.BOTTOM_NAV_ITEMS.map(item =>
        React.createElement('button', {
          key: item.id,
          className: `bottom-nav__item ${currentPage === item.id ? 'active' : ''}`,
          onClick: () => navigate(item.id),
        },
          React.createElement('span', { className: 'material-icons-round' }, item.icon),
          React.createElement('span', null, item.label)
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/components/Layout/Layout.jsx
// ============================================================
(function() {
// Layout.jsx - レイアウトラッパー
window.Layout = ({ children }) => {
  const { sidebarOpen, setSidebarOpen } = useAppContext();

  return React.createElement(React.Fragment, null,
    React.createElement(Header),
    React.createElement(Sidebar),
    React.createElement('main', { className: 'main-content' }, children),
    React.createElement(BottomNav),

    // オーバーレイ（モバイルサイドバー表示時）
    sidebarOpen && React.createElement('div', {
      style: {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: 'rgba(0,0,0,0.5)',
        zIndex: 800,
      },
      onClick: () => setSidebarOpen(false),
    })
  );
};

})();

// ============================================================
// FILE: src/pages/Dashboard.jsx
// ============================================================
(function() {
// Dashboard.jsx - ダッシュボード（DataServiceからリアルタイムデータ取得）
window.DashboardPage = () => {
  const { useState, useEffect, useMemo } = React;
  const { navigate } = useAppContext();
  const { currentPosition, isTracking } = useMapContext();

  // DataServiceからリアルタイムデータを取得
  const [refreshKey, setRefreshKey] = useState(0);

  // localStorageの変更を監視して自動更新
  useEffect(() => {
    const handleStorage = (e) => {
      if (e.key === APP_CONSTANTS.STORAGE_KEYS.REVENUE_DATA) {
        setRefreshKey(k => k + 1);
      }
    };
    window.addEventListener('storage', handleStorage);

    // 画面に戻った時も更新
    const handleVisibility = () => {
      if (!document.hidden) setRefreshKey(k => k + 1);
    };
    document.addEventListener('visibilitychange', handleVisibility);

    return () => {
      window.removeEventListener('storage', handleStorage);
      document.removeEventListener('visibilitychange', handleVisibility);
    };
  }, []);

  const todaySummary = useMemo(() => DataService.getTodaySummary(), [refreshKey]);
  const overallSummary = useMemo(() => DataService.getOverallSummary(), [refreshKey]);

  const hourlyRate = useMemo(() => {
    if (todaySummary.workMinutes > 0 && todaySummary.rideCount >= 2) {
      return Math.round(todaySummary.totalAmount / (todaySummary.workMinutes / 60));
    }
    return null;
  }, [refreshKey]);

  const stats = [
    {
      label: '本日の売上（税込）',
      value: `¥${todaySummary.totalAmount.toLocaleString()}`,
      sub: `税抜¥${Math.floor(todaySummary.totalAmount / 1.1).toLocaleString()} 税¥${(todaySummary.totalAmount - Math.floor(todaySummary.totalAmount / 1.1)).toLocaleString()}`,
      icon: 'payments',
      color: 'var(--color-secondary)',
    },
    {
      label: '乗車回数',
      value: `${todaySummary.rideCount}回`,
      icon: 'people',
      color: 'var(--color-primary-light)',
    },
    {
      label: '平均単価',
      value: `¥${todaySummary.avgAmount.toLocaleString()}`,
      icon: 'price_check',
      color: 'var(--color-accent)',
    },
    {
      label: '稼働時間',
      value: todaySummary.workTime,
      icon: 'schedule',
      color: 'var(--color-warning)',
    },
  ];

  const quickActions = [
    { label: '地図を開く', icon: 'map', page: 'map', color: 'var(--color-primary)' },
    { label: '売上を記録', icon: 'add_circle', page: 'revenue', color: 'var(--color-accent)' },
    { label: '分析を見る', icon: 'analytics', page: 'analytics', color: 'var(--color-secondary)' },
    { label: '開発者ツール', icon: 'code', page: 'dev', color: 'var(--color-warning)' },
  ];

  return React.createElement('div', null,
    // タイトル
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'dashboard'),
      'ダッシュボード'
    ),

    // GPS状態
    React.createElement(Card, {
      style: { marginBottom: 'var(--space-md)', padding: 'var(--space-md)' },
    },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '12px' } },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '24px', color: isTracking ? 'var(--color-accent)' : 'var(--text-muted)' },
        }, isTracking ? 'gps_fixed' : 'gps_off'),
        React.createElement('div', null,
          React.createElement('div', { style: { fontWeight: 500, fontSize: 'var(--font-size-sm)' } },
            isTracking ? 'GPS追跡中' : 'GPS未接続'
          ),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } },
            currentPosition
              ? `${currentPosition.lat.toFixed(4)}, ${currentPosition.lng.toFixed(4)}`
              : '地図ページでGPSを有効にしてください'
          )
        )
      )
    ),

    // リアルタイム時給
    hourlyRate !== null && React.createElement(Card, {
      style: {
        marginBottom: 'var(--space-md)', padding: 'var(--space-lg)',
        background: 'linear-gradient(135deg, rgba(249,168,37,0.15), rgba(255,152,0,0.08))',
        border: '1px solid rgba(249,168,37,0.3)',
        textAlign: 'center',
      },
    },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', marginBottom: '4px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '28px', color: 'var(--color-secondary)' } }, 'speed'),
        React.createElement('span', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } }, 'リアルタイム時給')
      ),
      React.createElement('div', {
        style: { fontSize: '2rem', fontWeight: 700, color: 'var(--color-secondary)' },
      }, `¥${hourlyRate.toLocaleString()}/h`)
    ),

    // 本日の統計カード
    React.createElement('div', { className: 'grid grid--4', style: { marginBottom: 'var(--space-lg)' } },
      stats.map((stat, i) =>
        React.createElement(Card, { key: i, className: 'stat-card' },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '32px', color: stat.color, marginBottom: '8px' },
          }, stat.icon),
          React.createElement('div', { className: 'stat-card__value' }, stat.value),
          stat.sub && React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)', marginTop: '2px' } }, stat.sub),
          React.createElement('div', { className: 'stat-card__label' }, stat.label)
        )
      )
    ),

    // 累計情報
    overallSummary.rideCount > 0 && React.createElement(Card, {
      style: { marginBottom: 'var(--space-lg)', padding: 'var(--space-md)' },
    },
      React.createElement('div', { style: { fontWeight: 500, fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' } },
        '累計実績'
      ),
      React.createElement('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '12px', textAlign: 'center' } },
        React.createElement('div', null,
          React.createElement('div', { style: { fontSize: 'var(--font-size-lg)', fontWeight: 700, color: 'var(--color-secondary)' } },
            `¥${overallSummary.totalAmount.toLocaleString()}`
          ),
          React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(overallSummary.totalAmount / 1.1).toLocaleString()}`),
          React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税¥${(overallSummary.totalAmount - Math.floor(overallSummary.totalAmount / 1.1)).toLocaleString()}`),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, '累計売上（税込）')
        ),
        React.createElement('div', null,
          React.createElement('div', { style: { fontSize: 'var(--font-size-lg)', fontWeight: 700 } },
            `${overallSummary.rideCount}回`
          ),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, '累計乗車')
        ),
        React.createElement('div', null,
          React.createElement('div', { style: { fontSize: 'var(--font-size-lg)', fontWeight: 700 } },
            `¥${overallSummary.dailyAvg.toLocaleString()}`
          ),
          React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(overallSummary.dailyAvg / 1.1).toLocaleString()}`),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, '日平均売上（税込）')
        ),
        React.createElement('div', null,
          React.createElement('div', { style: { fontSize: 'var(--font-size-lg)', fontWeight: 700 } },
            `${overallSummary.activeDays}日`
          ),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, '稼働日数')
        )
      )
    ),

    // 最近の売上（本日分）
    todaySummary.entries.length > 0 && React.createElement(Card, {
      title: `本日の記録（${todaySummary.entries.length}件）`,
      style: { marginBottom: 'var(--space-lg)' },
    },
      todaySummary.entries.slice(0, 5).map(entry =>
        React.createElement('div', {
          key: entry.id,
          style: {
            display: 'flex', justifyContent: 'space-between', alignItems: 'center',
            padding: '8px 0', borderBottom: '1px solid rgba(255,255,255,0.06)',
          },
        },
          React.createElement('div', null,
            React.createElement('div', { style: { fontSize: 'var(--font-size-sm)' } },
              `${entry.pickup || '---'} → ${entry.dropoff || '---'}`
            ),
            React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } },
              new Date(entry.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })
            )
          ),
          React.createElement('div', { style: { textAlign: 'right' } },
            entry.noPassenger
              ? React.createElement('div', { style: { fontWeight: 700, color: '#d32f2f' } }, '¥0（待機）')
              : React.createElement('div', { style: { fontWeight: 700, color: 'var(--color-secondary)' } }, `¥${entry.amount.toLocaleString()}`),
            !entry.noPassenger && React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(entry.amount / 1.1).toLocaleString()} 税¥${(entry.amount - Math.floor(entry.amount / 1.1)).toLocaleString()}`)
          )
        )
      ),
      todaySummary.entries.length > 5 && React.createElement(Button, {
        variant: 'secondary', icon: 'arrow_forward',
        onClick: () => navigate('revenue'),
        style: { marginTop: 'var(--space-sm)', width: '100%' },
      }, 'すべての記録を見る')
    ),

    // クイックアクション
    React.createElement('h2', {
      style: { fontSize: 'var(--font-size-lg)', marginBottom: 'var(--space-md)', fontWeight: 500 },
    }, 'クイックアクション'),

    React.createElement('div', { className: 'grid grid--4' },
      quickActions.map((action, i) =>
        React.createElement(Card, {
          key: i,
          onClick: () => navigate(action.page),
          style: { textAlign: 'center', cursor: 'pointer', padding: 'var(--space-lg)' },
        },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '36px', color: action.color, marginBottom: '8px' },
          }, action.icon),
          React.createElement('div', { style: { fontWeight: 500, fontSize: 'var(--font-size-sm)' } }, action.label)
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/MapView.jsx
// ============================================================
(function() {
// MapView.jsx - 地図ページ
window.MapViewPage = () => {
  const { useState } = React;
  const [isFullscreen, setIsFullscreen] = useState(false);

  return React.createElement('div', null,
    !isFullscreen && React.createElement('div', {
      style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 'var(--space-md)' },
    },
      React.createElement('h1', { className: 'page-title', style: { marginBottom: 0 } },
        React.createElement('span', { className: 'material-icons-round' }, 'map'),
        '地図'
      ),
      React.createElement(Button, {
        variant: 'secondary',
        icon: 'fullscreen',
        onClick: () => setIsFullscreen(true),
      }, '全画面')
    ),

    // 地図コンテナ
    React.createElement('div', { style: { position: 'relative' } },
      React.createElement(GoogleMapView, { fullscreen: isFullscreen }),

      // 全画面時の閉じるボタン
      isFullscreen && React.createElement(Button, {
        variant: 'secondary',
        icon: 'fullscreen_exit',
        onClick: () => setIsFullscreen(false),
        style: {
          position: 'absolute',
          top: '12px',
          right: '12px',
          zIndex: 10,
          background: 'rgba(26,26,46,0.9)',
        },
      }, '閉じる')
    ),

    // GPS追跡パネル（マップの外側・下に表示）
    React.createElement(GpsTracker)
  );
};

})();

// ============================================================
// FILE: src/pages/Revenue.jsx
// ============================================================
(function() {
// Revenue.jsx - 売上記録ページ（DataService統合・バリデーション・CSVエクスポート）
// v0.3.2: DataServiceのCRUDメソッドに一元化。ローカルstate独自管理を廃止し、
//         DataServiceを唯一のデータソースとして使用する。
// v0.3.4: 乗車地・降車地のGPS現在地取得機能を追加
// v0.3.5: 日付・天候フィールドを追加
// v0.3.6: 乗車時間・降車時間フィールドを追加
// v0.3.7: 日付・曜日・天候の自動取得
window.RevenuePage = () => {
  const { useState, useEffect, useCallback, useRef, useMemo } = React;

  // 本日の日付をデフォルト値に
  const todayDefault = new Date().toISOString().split('T')[0];

  // 現在時刻をHH:MM形式で取得
  const getNowTime = () => {
    const now = new Date();
    return `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
  };

  // WMO天気コードを天候カテゴリに変換
  const wmoToWeather = (code) => {
    if (code === undefined || code === null) return '';
    // 0-1: 晴れ, 2-3: 曇り, 45-67: 雨系, 71-77,85-86: 雪系
    if (code <= 1) return '晴れ';
    if (code <= 3 || code === 45 || code === 48) return '曇り';
    if ((code >= 51 && code <= 67) || (code >= 80 && code <= 82) || code === 95 || code === 96 || code === 99) return '雨';
    if ((code >= 71 && code <= 77) || code === 85 || code === 86) return '雪';
    return '曇り'; // デフォルト
  };

  // DataServiceから最新データを取得するためのrefreshKey
  const [refreshKey, setRefreshKey] = useState(0);
  const [form, setForm] = useState({ date: todayDefault, weather: '', amount: '', pickup: '', pickupTime: '', dropoff: '', dropoffTime: '', passengers: '1', gender: '', purpose: '', memo: '', source: '' });
  const [errors, setErrors] = useState([]);
  const [saved, setSaved] = useState(false);
  const [gpsLoading, setGpsLoading] = useState({ pickup: false, dropoff: false });
  const [gpsInfo, setGpsInfo] = useState({ pickup: null, dropoff: null });
  const [weatherLoading, setWeatherLoading] = useState(false);
  const weatherFetched = useRef(false);

  const { apiKey } = useAppContext();

  // ページ読み込み時に天気を自動取得
  useEffect(() => {
    if (weatherFetched.current) return;
    weatherFetched.current = true;

    const fetchWeather = () => {
      if (!navigator.geolocation) {
        AppLogger.warn('天気自動取得: GPS利用不可');
        return;
      }
      setWeatherLoading(true);
      getAccuratePosition({ accuracyThreshold: 500, timeout: 10000, maxWaitAfterFix: 3000 })
        .then((position) => {
          const lat = position.coords.latitude.toFixed(4);
          const lng = position.coords.longitude.toFixed(4);
          const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true&timezone=Asia%2FTokyo`;
          return fetch(url).then(res => res.json());
        })
        .then(data => {
          setWeatherLoading(false);
          if (data && data.current_weather) {
            const w = wmoToWeather(data.current_weather.weathercode);
            if (w) {
              setForm(prev => prev.weather ? prev : { ...prev, weather: w });
              AppLogger.info(`天気自動取得成功: ${w} (WMO code: ${data.current_weather.weathercode})`);
            }
          }
        })
        .catch(err => {
          setWeatherLoading(false);
          AppLogger.warn('天気取得用GPS失敗: ' + (err.message || ''));
        });
    };
    fetchWeather();
  }, []);

  // データは常にDataServiceから取得（単一のデータソース）
  const entries = useMemo(() => DataService.getEntries(), [refreshKey]);

  // localStorageの変更を監視して自動更新
  useEffect(() => {
    const handleStorage = (e) => {
      if (e.key === APP_CONSTANTS.STORAGE_KEYS.REVENUE_DATA) {
        setRefreshKey(k => k + 1);
      }
    };
    window.addEventListener('storage', handleStorage);

    const handleVisibility = () => {
      if (!document.hidden) setRefreshKey(k => k + 1);
    };
    document.addEventListener('visibilitychange', handleVisibility);

    return () => {
      window.removeEventListener('storage', handleStorage);
      document.removeEventListener('visibilitychange', handleVisibility);
    };
  }, []);

  // GPS現在地を取得して住所に変換
  const getGpsLocation = useCallback((field) => {
    if (!navigator.geolocation) {
      setErrors(['このブラウザではGPS機能が使えません']);
      return;
    }

    setGpsLoading(prev => ({ ...prev, [field]: true }));
    setErrors([]);

    getAccuratePosition({ accuracyThreshold: 30, timeout: 20000, maxWaitAfterFix: 8000 })
      .then((position) => {
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;
        const acc = Math.round(position.coords.accuracy);
        setGpsInfo(prev => ({ ...prev, [field]: { ...((prev && prev[field]) || {}), lat, lng, accuracy: acc } }));

        // Google Maps Geocoding APIで逆ジオコーディング
        if (apiKey && window.google && window.google.maps) {
          const geocoder = new google.maps.Geocoder();
          geocoder.geocode({ location: { lat, lng } }, (results, status) => {
            setGpsLoading(prev => ({ ...prev, [field]: false }));
            if (status === 'OK' && results[0]) {
              // 住所コンポーネントから簡潔な住所を生成
              const address = _formatAddress(results[0]);
              const fullAddress = results[0].formatted_address.replace(/、日本$/, '').replace(/^日本、/, '');
              const timeField = field === 'pickup' ? 'pickupTime' : 'dropoffTime';
              setForm(prev => ({ ...prev, [field]: address, [timeField]: getNowTime() }));
              setGpsInfo(prev => ({ ...prev, [field]: { ...(prev[field] || {}), lat, lng, address: fullAddress } }));
              AppLogger.info(`GPS逆ジオコーディング成功 (${field}): ${address}`);
            } else {
              // Google Geocoding失敗時はNominatimにフォールバック
              const timeField2 = field === 'pickup' ? 'pickupTime' : 'dropoffTime';
              const nomUrl2 = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=ja`;
              fetch(nomUrl2)
                .then(res2 => res2.json())
                .then(data2 => {
                  if (data2 && data2.address) {
                    const a2 = data2.address;
                    const parts2 = [a2.city || a2.town || a2.village || a2.county || '', a2.suburb || a2.neighbourhood || a2.quarter || '', a2.road || ''].filter(Boolean);
                    const shortAddr2 = parts2.join(' ') || data2.display_name.split(',').slice(0, 3).join(' ');
                    setForm(prev => ({ ...prev, [field]: shortAddr2, [timeField2]: getNowTime() }));
                    setGpsInfo(prev => ({ ...prev, [field]: { ...(prev[field] || {}), lat, lng, address: data2.display_name || shortAddr2 } }));
                  } else {
                    const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                    setForm(prev => ({ ...prev, [field]: coordStr, [timeField2]: getNowTime() }));
                    setGpsInfo(prev => ({ ...prev, [field]: { ...(prev[field] || {}), lat, lng, address: null } }));
                  }
                })
                .catch(() => {
                  const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                  setForm(prev => ({ ...prev, [field]: coordStr, [timeField2]: getNowTime() }));
                  setGpsInfo(prev => ({ ...prev, [field]: { ...(prev[field] || {}), lat, lng, address: null } }));
                });
              AppLogger.warn(`Google逆ジオコーディング失敗、Nominatimにフォールバック`);
            }
          });
        } else {
          // APIキーなし or Google Maps未ロードの場合はNominatim（OpenStreetMap）で逆ジオコーディング
          const timeField3 = field === 'pickup' ? 'pickupTime' : 'dropoffTime';
          const nomUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=ja`;
          fetch(nomUrl)
            .then(res => res.json())
            .then(data => {
              setGpsLoading(prev => ({ ...prev, [field]: false }));
              if (data && data.address) {
                // 日本の住所形式で組み立て
                const a = data.address;
                const parts = [a.city || a.town || a.village || a.county || '', a.suburb || a.neighbourhood || a.quarter || '', a.road || ''].filter(Boolean);
                const shortAddr = parts.join(' ') || data.display_name.split(',').slice(0, 3).join(' ');
                const fullAddr = data.display_name || shortAddr;
                setForm(prev => ({ ...prev, [field]: shortAddr, [timeField3]: getNowTime() }));
                setGpsInfo(prev => ({ ...prev, [field]: { ...(prev[field] || {}), lat, lng, address: fullAddr } }));
                AppLogger.info(`Nominatim逆ジオコーディング成功 (${field}): ${shortAddr}`);
              } else {
                const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                setForm(prev => ({ ...prev, [field]: coordStr, [timeField3]: getNowTime() }));
                setGpsInfo(prev => ({ ...prev, [field]: { ...(prev[field] || {}), lat, lng, address: null } }));
                AppLogger.warn(`Nominatim逆ジオコーディング失敗、座標を使用: ${coordStr}`);
              }
            })
            .catch(err => {
              setGpsLoading(prev => ({ ...prev, [field]: false }));
              const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
              setForm(prev => ({ ...prev, [field]: coordStr, [timeField3]: getNowTime() }));
              setGpsInfo(prev => ({ ...prev, [field]: { ...(prev[field] || {}), lat, lng, address: null } }));
              AppLogger.warn(`Nominatim API失敗、座標を使用: ${err.message}`);
            });
        }
      })
      .catch((error) => {
        setGpsLoading(prev => ({ ...prev, [field]: false }));
        const messages = {
          1: 'GPS使用が許可されていません。ブラウザの設定を確認してください。',
          2: '現在地を取得できませんでした。',
          3: 'GPS取得がタイムアウトしました。',
        };
        setErrors([messages[error.code] || 'GPS取得に失敗しました']);
        AppLogger.error(`GPS取得失敗 (${field}): code=${error.code || 0}`);
      });
  }, [apiKey]);

  // Geocoding結果から簡潔な住所を抽出
  function _formatAddress(result) {
    const comps = result.address_components;
    // 都道府県、市区町村、町名、番地を抽出
    let prefecture = '';
    let city = '';
    let ward = '';
    let town = '';
    let sublocality = '';

    for (const c of comps) {
      if (c.types.includes('administrative_area_level_1')) prefecture = c.long_name;
      if (c.types.includes('locality')) city = c.long_name;
      if (c.types.includes('sublocality_level_1') || c.types.includes('ward')) ward = c.long_name;
      if (c.types.includes('sublocality_level_2')) town = c.long_name;
      if (c.types.includes('sublocality_level_3')) sublocality = c.long_name;
    }

    // 簡潔な形式: 市区町村 + 町名 (都道府県は省略可)
    const parts = [ward || city || prefecture, town, sublocality].filter(Boolean);
    if (parts.length > 0) return parts.join(' ');

    // フォールバック: formatted_address から国名を除去
    return result.formatted_address.replace(/、日本$/, '').replace(/^日本、/, '');
  }

  const handleSubmit = (e) => {
    e.preventDefault();
    setErrors([]);

    // GPS座標をformに注入
    const formWithCoords = { ...form };
    if (gpsInfo.pickup && gpsInfo.pickup.lat != null) {
      formWithCoords.pickupCoords = { lat: gpsInfo.pickup.lat, lng: gpsInfo.pickup.lng };
    }
    if (gpsInfo.dropoff && gpsInfo.dropoff.lat != null) {
      formWithCoords.dropoffCoords = { lat: gpsInfo.dropoff.lat, lng: gpsInfo.dropoff.lng };
    }

    // DataServiceのaddEntryに完全委譲（バリデーション含む）
    const result = DataService.addEntry(formWithCoords);
    if (!result.success) {
      setErrors(result.errors);
      return;
    }

    setForm({ date: todayDefault, weather: form.weather, amount: '', pickup: '', pickupTime: '', dropoff: '', dropoffTime: '', passengers: '1', gender: '', purpose: '', memo: '', source: '' });
    setGpsInfo({ pickup: null, dropoff: null });
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
    setRefreshKey(k => k + 1);
  };

  const handleDelete = useCallback((id) => {
    DataService.deleteEntry(id);
    setRefreshKey(k => k + 1);
  }, []);

  const handleExportCSV = () => {
    DataService.downloadCSV();
  };

  const handleClearAll = () => {
    if (entries.length === 0) return;
    DataService.clearAllEntries();
    setRefreshKey(k => k + 1);
  };

  // 本日の日付文字列
  const today = new Date().toISOString().split('T')[0];
  const todayEntries = entries.filter(e => (e.date || e.timestamp.split('T')[0]) === today);
  const todayTotal = todayEntries.reduce((sum, e) => sum + e.amount, 0);
  const allTotal = entries.reduce((sum, e) => sum + e.amount, 0);

  // GPS取得ボタンのスタイル
  const gpsButtonStyle = (loading) => ({
    display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
    padding: '8px 12px', borderRadius: '6px',
    fontSize: '11px', fontWeight: '600',
    color: loading ? 'var(--color-secondary)' : '#fff',
    cursor: loading ? 'wait' : 'pointer',
    border: '1px solid rgba(255,255,255,0.15)',
    background: loading ? 'rgba(249,168,37,0.15)' : 'rgba(26,115,232,0.2)',
    transition: 'all 0.2s ease',
    whiteSpace: 'nowrap',
    minWidth: '0',
    flex: '0 0 auto',
  });

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'receipt_long'),
      '売上記録'
    ),

    // 本日の合計
    React.createElement(Card, { style: { marginBottom: 'var(--space-lg)', textAlign: 'center' } },
      React.createElement('div', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)' } }, '本日の売上合計（税込）'),
      React.createElement('div', {
        style: { fontSize: 'var(--font-size-2xl)', fontWeight: 700, color: 'var(--color-secondary)', margin: '8px 0' },
      }, `¥${todayTotal.toLocaleString()}`),
      React.createElement('div', {
        style: { display: 'flex', justifyContent: 'center', gap: '16px', margin: '4px 0 8px', fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' },
      },
        React.createElement('span', null, `税抜: ¥${Math.floor(todayTotal / 1.1).toLocaleString()}`),
        React.createElement('span', { style: { color: 'var(--color-warning)' } }, `消費税: ¥${(todayTotal - Math.floor(todayTotal / 1.1)).toLocaleString()}`)
      ),
      React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-xs)' } },
        `本日 ${todayEntries.length} 件 / 全 ${entries.length} 件（累計 ¥${allTotal.toLocaleString()}）`
      )
    ),

    // 入力フォーム
    React.createElement(Card, { title: '新規売上を記録', style: { marginBottom: 'var(--space-lg)' } },
      // バリデーションエラー表示
      errors.length > 0 && React.createElement('div', {
        style: {
          background: 'rgba(229,57,53,0.1)', border: '1px solid rgba(229,57,53,0.3)',
          borderRadius: '8px', padding: '8px 12px', marginBottom: 'var(--space-md)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: 'var(--color-danger)' },
        }, 'error'),
        React.createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-danger)' } },
          errors.join('、')
        )
      ),

      // 保存成功メッセージ
      saved && React.createElement('div', {
        style: {
          background: 'rgba(0,200,83,0.1)', border: '1px solid rgba(0,200,83,0.3)',
          borderRadius: '8px', padding: '8px 12px', marginBottom: 'var(--space-md)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: 'var(--color-accent)' },
        }, 'check_circle'),
        React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-accent)' } },
          '記録を追加しました'
        )
      ),

      React.createElement('form', { onSubmit: handleSubmit },
        React.createElement('div', { className: 'grid grid--2' },
          // 乗車地（GPS付き）
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '乗車地'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'stretch' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'text',
                placeholder: '東京駅',
                value: form.pickup,
                onChange: (e) => { setForm({ ...form, pickup: e.target.value }); if (!e.target.value) setGpsInfo(prev => ({ ...prev, pickup: null })); },
                style: { flex: 1, minWidth: 0 },
              }),
              React.createElement('button', {
                type: 'button',
                onClick: () => getGpsLocation('pickup'),
                disabled: gpsLoading.pickup,
                style: gpsButtonStyle(gpsLoading.pickup),
                title: 'GPSで現在地を取得',
              },
                React.createElement('span', {
                  className: 'material-icons-round',
                  style: { fontSize: '16px', animation: gpsLoading.pickup ? 'spin 1s linear infinite' : 'none' },
                }, gpsLoading.pickup ? 'sync' : 'my_location'),
                gpsLoading.pickup ? '取得中' : 'GPS'
              )
            ),
            // GPS取得結果の住所・座標表示
            gpsInfo.pickup && gpsInfo.pickup.lat != null && React.createElement('div', {
              style: {
                marginTop: '6px', padding: '6px 10px', borderRadius: '6px',
                background: 'rgba(26,115,232,0.08)', border: '1px solid rgba(26,115,232,0.15)',
                fontSize: '11px', color: 'var(--text-secondary)', lineHeight: '1.5',
              },
            },
              gpsInfo.pickup.address && React.createElement('div', { style: { display: 'flex', alignItems: 'flex-start', gap: '4px', marginBottom: '3px' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '13px', color: 'var(--color-primary-light)', marginTop: '1px', flexShrink: 0 } }, 'place'),
                React.createElement('span', { style: { fontWeight: '600', color: 'var(--color-primary-light)', wordBreak: 'break-all' } }, gpsInfo.pickup.address)
              ),
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '4px', color: 'var(--text-muted)', fontSize: '10px', flexWrap: 'wrap' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px', flexShrink: 0 } }, 'gps_fixed'),
                `${gpsInfo.pickup.lat.toFixed(6)}, ${gpsInfo.pickup.lng.toFixed(6)}`,
                gpsInfo.pickup.accuracy && React.createElement('span', {
                  style: { padding: '1px 6px', borderRadius: '3px', fontWeight: '600',
                    background: gpsInfo.pickup.accuracy <= 50 ? 'rgba(0,200,83,0.15)' : gpsInfo.pickup.accuracy <= 200 ? 'rgba(249,168,37,0.15)' : 'rgba(229,57,53,0.15)',
                    color: gpsInfo.pickup.accuracy <= 50 ? '#4caf50' : gpsInfo.pickup.accuracy <= 200 ? '#f9a825' : '#e53935' },
                }, `精度 ${gpsInfo.pickup.accuracy}m`),
                React.createElement('a', { href: `https://www.google.com/maps?q=${gpsInfo.pickup.lat},${gpsInfo.pickup.lng}`, target: '_blank', rel: 'noopener', style: { color: 'var(--color-primary-light)', textDecoration: 'underline' } }, '地図で確認')
              )
            )
          ),

          // 乗車時間
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '乗車時間'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'stretch' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'time',
                value: form.pickupTime,
                onChange: (e) => setForm({ ...form, pickupTime: e.target.value }),
                style: { flex: 1, minWidth: 0, colorScheme: 'dark' },
              }),
              React.createElement('button', {
                type: 'button',
                onClick: () => setForm({ ...form, pickupTime: getNowTime() }),
                style: {
                  display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
                  padding: '8px 12px', borderRadius: '6px', fontSize: '11px', fontWeight: '600',
                  color: '#fff', cursor: 'pointer',
                  border: '1px solid rgba(255,255,255,0.15)',
                  background: 'rgba(0,200,83,0.2)',
                  transition: 'all 0.2s ease', whiteSpace: 'nowrap', flex: '0 0 auto',
                },
                title: '現在時刻をセット',
              },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'schedule'),
                '現在'
              )
            )
          ),

          // 降車地（GPS付き）
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '降車地'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'stretch' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'text',
                placeholder: '渋谷駅',
                value: form.dropoff,
                onChange: (e) => { setForm({ ...form, dropoff: e.target.value }); if (!e.target.value) setGpsInfo(prev => ({ ...prev, dropoff: null })); },
                style: { flex: 1, minWidth: 0 },
              }),
              React.createElement('button', {
                type: 'button',
                onClick: () => getGpsLocation('dropoff'),
                disabled: gpsLoading.dropoff,
                style: gpsButtonStyle(gpsLoading.dropoff),
                title: 'GPSで現在地を取得',
              },
                React.createElement('span', {
                  className: 'material-icons-round',
                  style: { fontSize: '16px', animation: gpsLoading.dropoff ? 'spin 1s linear infinite' : 'none' },
                }, gpsLoading.dropoff ? 'sync' : 'my_location'),
                gpsLoading.dropoff ? '取得中' : 'GPS'
              )
            ),
            // GPS取得結果の住所・座標表示
            gpsInfo.dropoff && gpsInfo.dropoff.lat != null && React.createElement('div', {
              style: {
                marginTop: '6px', padding: '6px 10px', borderRadius: '6px',
                background: 'rgba(0,200,83,0.08)', border: '1px solid rgba(0,200,83,0.15)',
                fontSize: '11px', color: 'var(--text-secondary)', lineHeight: '1.5',
              },
            },
              gpsInfo.dropoff.address && React.createElement('div', { style: { display: 'flex', alignItems: 'flex-start', gap: '4px', marginBottom: '3px' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '13px', color: 'var(--color-accent)', marginTop: '1px', flexShrink: 0 } }, 'place'),
                React.createElement('span', { style: { fontWeight: '600', color: 'var(--color-accent)', wordBreak: 'break-all' } }, gpsInfo.dropoff.address)
              ),
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '4px', color: 'var(--text-muted)', fontSize: '10px', flexWrap: 'wrap' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px', flexShrink: 0 } }, 'gps_fixed'),
                `${gpsInfo.dropoff.lat.toFixed(6)}, ${gpsInfo.dropoff.lng.toFixed(6)}`,
                gpsInfo.dropoff.accuracy && React.createElement('span', {
                  style: { padding: '1px 6px', borderRadius: '3px', fontWeight: '600',
                    background: gpsInfo.dropoff.accuracy <= 50 ? 'rgba(0,200,83,0.15)' : gpsInfo.dropoff.accuracy <= 200 ? 'rgba(249,168,37,0.15)' : 'rgba(229,57,53,0.15)',
                    color: gpsInfo.dropoff.accuracy <= 50 ? '#4caf50' : gpsInfo.dropoff.accuracy <= 200 ? '#f9a825' : '#e53935' },
                }, `精度 ${gpsInfo.dropoff.accuracy}m`),
                React.createElement('a', { href: `https://www.google.com/maps?q=${gpsInfo.dropoff.lat},${gpsInfo.dropoff.lng}`, target: '_blank', rel: 'noopener', style: { color: 'var(--color-primary-light)', textDecoration: 'underline' } }, '地図で確認')
              )
            ),
            // 乗客なしボタン（降車地GPS下）
            React.createElement('button', {
              type: 'button',
              onClick: () => {
                setErrors([]);
                const now = new Date();
                const hh = String(now.getHours()).padStart(2, '0');
                const mm = String(now.getMinutes()).padStart(2, '0');
                const dropoffTime = `${hh}:${mm}`;
                const formData = {
                  ...form,
                  dropoffTime,
                  amount: '0',
                  passengers: '0',
                  noPassenger: true,
                };
                if (gpsInfo.pickup && gpsInfo.pickup.lat != null) {
                  formData.pickupCoords = { lat: gpsInfo.pickup.lat, lng: gpsInfo.pickup.lng };
                }
                if (gpsInfo.dropoff && gpsInfo.dropoff.lat != null) {
                  formData.dropoffCoords = { lat: gpsInfo.dropoff.lat, lng: gpsInfo.dropoff.lng };
                }
                const result = DataService.addEntry(formData);
                if (result.success) {
                  setForm({ date: todayDefault, weather: form.weather, amount: '', pickup: '', pickupTime: '', dropoff: '', dropoffTime: '', passengers: '1', gender: '', purpose: '', memo: '', source: '' });
                  setGpsInfo({ pickup: null, dropoff: null });
                  setSaved(true);
                  setTimeout(() => setSaved(false), 2000);
                  setRefreshKey(k => k + 1);
                } else {
                  setErrors(result.errors);
                }
              },
              style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px', width: '100%', padding: '10px', marginTop: '8px', borderRadius: '8px', border: 'none', cursor: 'pointer', fontSize: '13px', fontWeight: 700, background: '#d32f2f', color: '#fff' },
            },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, 'person_off'),
              '乗客なし（待機時間を記録）'
            )
          ),

          // 降車時間
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '降車時間'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'stretch' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'time',
                value: form.dropoffTime,
                onChange: (e) => setForm({ ...form, dropoffTime: e.target.value }),
                style: { flex: 1, minWidth: 0, colorScheme: 'dark' },
              }),
              React.createElement('button', {
                type: 'button',
                onClick: () => setForm({ ...form, dropoffTime: getNowTime() }),
                style: {
                  display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
                  padding: '8px 12px', borderRadius: '6px', fontSize: '11px', fontWeight: '600',
                  color: '#fff', cursor: 'pointer',
                  border: '1px solid rgba(255,255,255,0.15)',
                  background: 'rgba(0,200,83,0.2)',
                  transition: 'all 0.2s ease', whiteSpace: 'nowrap', flex: '0 0 auto',
                },
                title: '現在時刻をセット',
              },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'schedule'),
                '現在'
              )
            )
          ),

          // 日付（自動：本日 + 曜日・祝日を自動計算）
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '日付 *',
              React.createElement('span', {
                style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: '400', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.1)' },
              }, '自動')
            ),
            React.createElement('input', {
              className: 'form-input',
              type: 'date',
              value: form.date,
              onChange: (e) => setForm({ ...form, date: e.target.value }),
              required: true,
              style: { colorScheme: 'dark' },
            }),
            // 曜日・祝日の自動表示
            form.date && (() => {
              const info = JapaneseHolidays.getDateInfo(form.date);
              const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-secondary)';
              return React.createElement('div', {
                style: { marginTop: '6px', display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' },
              },
                React.createElement('span', {
                  style: {
                    fontSize: '13px', fontWeight: '600', color: dayColor,
                    padding: '2px 10px', borderRadius: '4px',
                    background: info.isSunday || info.isHoliday ? 'rgba(239,68,68,0.12)' : info.isSaturday ? 'rgba(59,130,246,0.12)' : 'rgba(255,255,255,0.06)',
                  },
                }, `${info.dayOfWeek}曜日`),
                info.holiday && React.createElement('span', {
                  style: {
                    fontSize: '12px', fontWeight: '600', color: '#ef4444',
                    padding: '2px 10px', borderRadius: '4px',
                    background: 'rgba(239,68,68,0.12)',
                    display: 'flex', alignItems: 'center', gap: '4px',
                  },
                },
                  React.createElement('span', { style: { fontSize: '13px' } }, '🎌'),
                  info.holiday
                )
              );
            })()
          ),

          // 天候（自動取得 + 手動変更可）
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '天候',
              weatherLoading && React.createElement('span', {
                style: { fontSize: '11px', color: 'var(--color-secondary)', fontWeight: '400', animation: 'pulse 1.5s ease-in-out infinite' },
              }, '取得中...'),
              !weatherLoading && form.weather && React.createElement('span', {
                style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: '400', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.1)' },
              }, '自動取得済')
            ),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              ...[
                { value: '晴れ', icon: '☀️' },
                { value: '曇り', icon: '☁️' },
                { value: '雨', icon: '🌧️' },
                { value: '雪', icon: '❄️' },
              ].map(w =>
                React.createElement('button', {
                  key: w.value,
                  type: 'button',
                  onClick: () => setForm({ ...form, weather: form.weather === w.value ? '' : w.value }),
                  style: {
                    display: 'flex', alignItems: 'center', gap: '4px',
                    padding: '8px 14px', borderRadius: '8px',
                    fontSize: '13px', fontWeight: form.weather === w.value ? '700' : '400',
                    cursor: 'pointer',
                    border: form.weather === w.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.weather === w.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.weather === w.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', { style: { fontSize: '16px' } }, w.icon),
                  w.value
                )
              )
            )
          ),

          // 配車方法
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '配車方法'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              ...[
                { value: 'Go', icon: '🟢' },
                { value: 'Uber', icon: '⚫' },
                { value: 'DIDI', icon: '🟠' },
                { value: '電話', icon: '📞' },
                { value: '流し', icon: '🚕' },
              ].map(s =>
                React.createElement('button', {
                  key: s.value,
                  type: 'button',
                  onClick: () => setForm({ ...form, source: form.source === s.value ? '' : s.value }),
                  style: {
                    display: 'flex', alignItems: 'center', gap: '4px',
                    padding: '8px 14px', borderRadius: '8px',
                    fontSize: '13px', fontWeight: form.source === s.value ? '700' : '400',
                    cursor: 'pointer',
                    border: form.source === s.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.source === s.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.source === s.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', { style: { fontSize: '16px' } }, s.icon),
                  s.value
                )
              )
            )
          ),

          // 金額
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '金額 (税込・円) *'),
            React.createElement('input', {
              className: 'form-input',
              type: 'number',
              min: '1',
              max: '1000000',
              placeholder: '3500',
              value: form.amount,
              onChange: (e) => { setForm({ ...form, amount: e.target.value }); setErrors([]); },
              required: true,
            }),
            // 税内訳表示
            form.amount && parseInt(form.amount) > 0 && (() => {
              const taxIncluded = parseInt(form.amount);
              const taxExcluded = Math.floor(taxIncluded / 1.1);
              const tax = taxIncluded - taxExcluded;
              return React.createElement('div', {
                style: {
                  marginTop: '6px', padding: '6px 10px', borderRadius: '6px',
                  background: 'rgba(249,168,37,0.08)', border: '1px solid rgba(249,168,37,0.15)',
                  fontSize: '12px', color: 'var(--text-secondary)',
                  display: 'flex', gap: '12px', flexWrap: 'wrap',
                },
              },
                React.createElement('span', null, `税抜: ¥${taxExcluded.toLocaleString()}`),
                React.createElement('span', { style: { color: 'var(--color-warning)' } }, `消費税: ¥${tax.toLocaleString()}`),
                React.createElement('span', null, `税込: ¥${taxIncluded.toLocaleString()}`)
              );
            })()
          ),

          // お客様人数
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, 'お客様人数'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              ...['1', '2', '3', '4'].map(n =>
                React.createElement('button', {
                  key: n,
                  type: 'button',
                  onClick: () => setForm({ ...form, passengers: n }),
                  style: {
                    display: 'flex', alignItems: 'center', justifyContent: 'center',
                    width: '44px', height: '44px', borderRadius: '8px',
                    fontSize: '15px', fontWeight: form.passengers === n ? '700' : '400',
                    cursor: 'pointer',
                    border: form.passengers === n ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.passengers === n ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.passengers === n ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                }, `${n}名`)
              ),
              React.createElement('input', {
                className: 'form-input',
                type: 'number',
                min: '1',
                max: '99',
                placeholder: '5+',
                value: !['1','2','3','4'].includes(form.passengers) ? form.passengers : '',
                onChange: (e) => setForm({ ...form, passengers: e.target.value }),
                onFocus: () => { if (['1','2','3','4'].includes(form.passengers)) setForm({ ...form, passengers: '' }); },
                style: { width: '60px', minWidth: '60px', flex: '0 0 auto', textAlign: 'center', fontSize: '14px' },
              })
            )
          ),

          // お客様性別
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, 'お客様性別'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              ...[
                { value: '男性', icon: '👨' },
                { value: '女性', icon: '👩' },
                { value: '混合', icon: '👥' },
              ].map(g =>
                React.createElement('button', {
                  key: g.value,
                  type: 'button',
                  onClick: () => setForm({ ...form, gender: form.gender === g.value ? '' : g.value }),
                  style: {
                    display: 'flex', alignItems: 'center', gap: '4px',
                    padding: '8px 14px', borderRadius: '8px',
                    fontSize: '13px', fontWeight: form.gender === g.value ? '700' : '400',
                    cursor: 'pointer',
                    border: form.gender === g.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.gender === g.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.gender === g.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', { style: { fontSize: '16px' } }, g.icon),
                  g.value
                )
              )
            )
          ),

          // 用途
          React.createElement('div', { className: 'form-group', style: { gridColumn: '1 / -1' } },
            React.createElement('label', { className: 'form-label' }, '用途'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              ...[
                { value: '通勤', icon: '🏢' },
                { value: '通院', icon: '🏥' },
                { value: '買物', icon: '🛒' },
                { value: '観光', icon: '📸' },
                { value: '出張', icon: '💼' },
                { value: '送迎', icon: '🚗' },
                { value: '空港', icon: '✈️' },
                { value: '飲食', icon: '🍺' },
                { value: 'その他', icon: '📝' },
              ].map(p =>
                React.createElement('button', {
                  key: p.value,
                  type: 'button',
                  onClick: () => setForm({ ...form, purpose: form.purpose === p.value ? '' : p.value }),
                  style: {
                    display: 'flex', alignItems: 'center', gap: '4px',
                    padding: '8px 12px', borderRadius: '8px',
                    fontSize: '12px', fontWeight: form.purpose === p.value ? '700' : '400',
                    cursor: 'pointer',
                    border: form.purpose === p.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.purpose === p.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.purpose === p.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', { style: { fontSize: '14px' } }, p.icon),
                  p.value
                )
              )
            )
          ),

          // メモ
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, 'メモ'),
            React.createElement('input', {
              className: 'form-input',
              type: 'text',
              placeholder: '任意のメモ',
              value: form.memo,
              onChange: (e) => setForm({ ...form, memo: e.target.value }),
            })
          )
        ),
        React.createElement(Button, {
          variant: 'primary',
          icon: 'add',
          style: { marginTop: 'var(--space-sm)' },
        }, '記録を追加')
      )
    ),

    // データ管理ツールバー
    React.createElement(Card, { style: { marginBottom: 'var(--space-md)' } },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '10px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--color-primary-light)' } }, 'folder'),
        React.createElement('span', { style: { fontSize: '13px', fontWeight: '600', color: 'var(--text-primary)' } }, 'データ管理'),
        entries.length > 0 && React.createElement('span', { style: { fontSize: '11px', color: 'var(--text-muted)', marginLeft: 'auto' } },
          `全 ${entries.length} 件の記録`
        )
      ),
      React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
        // 保存先フォルダ選択
        React.createElement(Button, {
          variant: 'secondary',
          icon: DataService.hasSaveFolder() ? 'folder_open' : 'create_new_folder',
          onClick: async () => {
            const result = await DataService.selectSaveFolder();
            if (result.success) {
              setSaved(false); setErrors([]);
              alert('保存先フォルダを設定しました: ' + result.folderName + '\n\n記録の追加時に自動保存されます。');
              setRefreshKey(k => k + 1);
            } else {
              if (result.message) alert(result.message);
            }
          },
          style: { padding: '6px 12px', fontSize: '11px' },
        }, DataService.hasSaveFolder() ? '保存先変更' : '保存先フォルダ設定'),
        // 手動保存
        entries.length > 0 && React.createElement(Button, {
          variant: 'secondary',
          icon: 'save',
          onClick: () => DataService.manualSaveToFile(),
          style: { padding: '6px 12px', fontSize: '11px' },
        }, 'JSON保存'),
        // CSVエクスポート
        entries.length > 0 && React.createElement(Button, {
          variant: 'secondary',
          icon: 'download',
          onClick: handleExportCSV,
          style: { padding: '6px 12px', fontSize: '11px' },
        }, 'CSV出力'),
        // ファイルから復元
        React.createElement(Button, {
          variant: 'secondary',
          icon: 'upload_file',
          onClick: async () => {
            const result = await DataService.importFromFile();
            if (result.success) {
              setRefreshKey(k => k + 1);
              alert(result.message);
            } else {
              if (result.message) alert(result.message);
            }
          },
          style: { padding: '6px 12px', fontSize: '11px' },
        }, 'ファイル復元'),
        // 全削除
        entries.length > 0 && React.createElement(Button, {
          variant: 'danger',
          icon: 'delete_forever',
          onClick: () => { if (confirm('全ての売上記録を削除しますか？この操作は取り消せません。')) handleClearAll(); },
          style: { padding: '6px 12px', fontSize: '11px' },
        }, '全削除')
      ),
      // 保存先フォルダ状態表示
      React.createElement('div', {
        style: { marginTop: '8px', fontSize: '10px', color: 'var(--text-muted)', display: 'flex', alignItems: 'center', gap: '4px' },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px' } }, 'info'),
        DataService.hasSaveFolder()
          ? '保存先フォルダ設定済み — 「売上記録」サブフォルダに自動保存されます'
          : '保存先フォルダ未設定 — 記録追加時にダウンロードとして保存されます'
      )
    ),

    // 記録一覧
    entries.length > 0 && React.createElement(Card, { title: `記録一覧（${entries.length}件）` },
      entries.map(entry =>
        React.createElement('div', {
          key: entry.id,
          style: {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            padding: '12px 0',
            borderBottom: '1px solid rgba(255,255,255,0.06)',
          },
        },
          React.createElement('div', { style: { flex: 1 } },
            React.createElement('div', { style: { fontWeight: 500, display: 'flex', alignItems: 'center', gap: '4px', flexWrap: 'wrap' } },
              entry.pickupTime && React.createElement('span', {
                style: { fontSize: '11px', color: 'var(--color-primary-light)', fontWeight: '600', padding: '1px 6px', borderRadius: '3px', background: 'rgba(26,115,232,0.12)' },
              }, entry.pickupTime),
              React.createElement('span', null, `${entry.pickup || '---'}`),
              React.createElement('span', { style: { color: 'var(--text-muted)', margin: '0 2px' } }, '→'),
              entry.dropoffTime && React.createElement('span', {
                style: { fontSize: '11px', color: 'var(--color-accent)', fontWeight: '600', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.12)' },
              }, entry.dropoffTime),
              React.createElement('span', null, `${entry.dropoff || '---'}`)
            ),
            React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', display: 'flex', flexWrap: 'wrap', alignItems: 'center', gap: '4px' } },
              (() => {
                const eDate = entry.date || new Date(entry.timestamp).toISOString().split('T')[0];
                const info = entry.dayOfWeek ? { dayOfWeek: entry.dayOfWeek, holiday: entry.holiday, isSunday: entry.dayOfWeek === '日', isSaturday: entry.dayOfWeek === '土', isHoliday: !!entry.holiday } : JapaneseHolidays.getDateInfo(eDate);
                const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-muted)';
                return React.createElement(React.Fragment, null,
                  React.createElement('span', null, eDate),
                  React.createElement('span', { style: { color: dayColor, fontWeight: '600' } }, `(${info.dayOfWeek})`),
                  info.holiday && React.createElement('span', {
                    style: { color: '#ef4444', fontSize: '10px', padding: '1px 6px', borderRadius: '3px', background: 'rgba(239,68,68,0.1)' },
                  }, info.holiday),
                  entry.weather && React.createElement('span', null, entry.weather),
                  entry.passengers && React.createElement('span', {
                    style: { fontSize: '10px', padding: '1px 5px', borderRadius: '3px', background: 'rgba(255,255,255,0.08)' },
                  }, `${entry.passengers}名`),
                  entry.gender && React.createElement('span', {
                    style: { fontSize: '10px', padding: '1px 5px', borderRadius: '3px', background: 'rgba(255,255,255,0.08)' },
                  }, entry.gender),
                  entry.purpose && React.createElement('span', {
                    style: { fontSize: '10px', padding: '1px 5px', borderRadius: '3px', background: 'rgba(26,115,232,0.1)', color: 'var(--color-primary-light)' },
                  }, entry.purpose),
                  entry.source && React.createElement('span', {
                    style: { fontSize: '10px', padding: '1px 5px', borderRadius: '3px', background: 'rgba(255,152,0,0.15)', color: '#ffb74d', fontWeight: '600' },
                  }, entry.source),
                  React.createElement('span', null, new Date(entry.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })),
                  entry.memo && React.createElement('span', null, `| ${entry.memo}`)
                );
              })()
            )
          ),
          React.createElement('div', { style: { marginRight: '12px', textAlign: 'right' } },
            entry.noPassenger
              ? React.createElement('div', { style: { fontWeight: 700, color: '#d32f2f', fontSize: 'var(--font-size-lg)' } }, '¥0（待機）')
              : React.createElement('div', { style: { fontWeight: 700, color: 'var(--color-secondary)', fontSize: 'var(--font-size-lg)' } }, `¥${entry.amount.toLocaleString()}`),
            !entry.noPassenger && React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(entry.amount / 1.1).toLocaleString()} 税¥${(entry.amount - Math.floor(entry.amount / 1.1)).toLocaleString()}`)
          ),
          React.createElement('button', {
            onClick: () => handleDelete(entry.id),
            style: {
              background: 'none', border: 'none', cursor: 'pointer',
              color: 'var(--text-muted)', padding: '4px',
              borderRadius: '4px', transition: 'color 0.2s',
            },
            title: '削除',
          },
            React.createElement('span', {
              className: 'material-icons-round',
              style: { fontSize: '18px' },
            }, 'delete_outline')
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/RivalRide.jsx
// ============================================================
(function() {
// RivalRide.jsx - 他社乗車情報記録ページ
window.RivalRidePage = () => {
  const { useState, useEffect, useCallback, useRef, useMemo } = React;

  const todayDefault = new Date().toISOString().split('T')[0];

  const getNowTime = () => {
    const now = new Date();
    return `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
  };

  const wmoToWeather = (code) => {
    if (code === undefined || code === null) return '';
    if (code <= 1) return '晴れ';
    if (code <= 3 || code === 45 || code === 48) return '曇り';
    if ((code >= 51 && code <= 67) || (code >= 80 && code <= 82) || code === 95 || code === 96 || code === 99) return '雨';
    if ((code >= 71 && code <= 77) || code === 85 || code === 86) return '雪';
    return '曇り';
  };

  const [refreshKey, setRefreshKey] = useState(0);
  const [form, setForm] = useState({ date: todayDefault, time: getNowTime(), weather: '', location: '', locationCoords: null, memo: '' });
  const [errors, setErrors] = useState([]);
  const [saved, setSaved] = useState(false);
  const [gpsLoading, setGpsLoading] = useState(false);
  const [gpsInfo, setGpsInfo] = useState(null);
  const [weatherLoading, setWeatherLoading] = useState(false);
  const weatherFetched = useRef(false);
  const locationFetched = useRef(false);
  const formRef = useRef(form);
  useEffect(() => { formRef.current = form; }, [form]);

  const { apiKey } = useAppContext();

  // ページロード時に天気を自動取得
  useEffect(() => {
    if (weatherFetched.current) return;
    weatherFetched.current = true;

    if (!navigator.geolocation) return;
    setWeatherLoading(true);
    getAccuratePosition({ accuracyThreshold: 500, timeout: 10000, maxWaitAfterFix: 3000 })
      .then((position) => {
        const lat = position.coords.latitude.toFixed(4);
        const lng = position.coords.longitude.toFixed(4);
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true&timezone=Asia%2FTokyo`;
        return fetch(url).then(res => res.json());
      })
      .then(data => {
        setWeatherLoading(false);
        if (data && data.current_weather) {
          const w = wmoToWeather(data.current_weather.weathercode);
          if (w) {
            setForm(prev => prev.weather ? prev : { ...prev, weather: w });
            AppLogger.info(`他社乗車 天気自動取得成功: ${w}`);
          }
        }
      })
      .catch(() => setWeatherLoading(false));
  }, []);

  // ページロード時にGPS場所を自動取得
  useEffect(() => {
    if (locationFetched.current) return;
    locationFetched.current = true;
    getGpsLocationAuto();
  }, []);

  const getGpsLocationAuto = () => {
    if (!navigator.geolocation) return;
    setGpsLoading(true);
    getAccuratePosition({ accuracyThreshold: 50, timeout: 20000, maxWaitAfterFix: 8000 })
      .then((position) => {
        setGpsInfo(prev => ({ ...prev, accuracy: Math.round(position.coords.accuracy) }));
        reverseGeocode(position.coords.latitude, position.coords.longitude, false);
      })
      .catch(() => setGpsLoading(false));
  };

  const getGpsLocation = useCallback(() => {
    if (!navigator.geolocation) {
      setErrors(['このブラウザではGPS機能が使えません']);
      return;
    }
    setGpsLoading(true);
    setErrors([]);
    getAccuratePosition({ accuracyThreshold: 30, timeout: 20000, maxWaitAfterFix: 8000 })
      .then((position) => {
        setGpsInfo(prev => ({ ...prev, accuracy: Math.round(position.coords.accuracy) }));
        reverseGeocode(position.coords.latitude, position.coords.longitude, true);
      })
      .catch((error) => {
        setGpsLoading(false);
        const messages = {
          1: 'GPS使用が許可されていません。ブラウザの設定を確認してください。',
          2: '現在地を取得できませんでした。',
          3: 'GPS取得がタイムアウトしました。',
        };
        setErrors([messages[error.code] || 'GPS取得に失敗しました']);
      });
  }, [apiKey]);

  // GPS解決時に自動記録追加
  const autoAddEntry = (location, coords) => {
    const cur = formRef.current;
    const entryData = { date: cur.date, time: getNowTime(), weather: cur.weather, location, locationCoords: coords, memo: cur.memo };
    const result = DataService.addRivalEntry(entryData);
    if (result.success) {
      setForm({ date: todayDefault, time: getNowTime(), weather: cur.weather, location: '', locationCoords: null, memo: '' });
      setGpsInfo(null);
      setSaved(true);
      setTimeout(() => setSaved(false), 2000);
      setRefreshKey(k => k + 1);
    }
  };

  // 逆ジオコーディング共通処理（autoAdd=trueでGPS解決時に自動記録追加）
  const reverseGeocode = (lat, lng, autoAdd) => {
    if (apiKey && window.google && window.google.maps) {
      const geocoder = new google.maps.Geocoder();
      geocoder.geocode({ location: { lat, lng } }, (results, status) => {
        setGpsLoading(false);
        if (status === 'OK' && results[0]) {
          const address = _formatRivalAddress(results[0]);
          const fullAddress = results[0].formatted_address.replace(/、日本$/, '').replace(/^日本、/, '');
          AppLogger.info(`他社乗車 GPS逆ジオコーディング成功: ${address}`);
          if (autoAdd) {
            autoAddEntry(address, { lat, lng });
          } else {
            setForm(prev => ({ ...prev, location: address, locationCoords: { lat, lng }, time: getNowTime() }));
            setGpsInfo(prev => ({ ...prev, lat, lng, address: fullAddress }));
          }
        } else {
          nominatimFallback(lat, lng, autoAdd);
        }
      });
    } else {
      nominatimFallback(lat, lng, autoAdd);
    }
  };

  const nominatimFallback = (lat, lng, autoAdd) => {
    const nomUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=ja`;
    fetch(nomUrl)
      .then(res => res.json())
      .then(data => {
        setGpsLoading(false);
        if (data && data.address) {
          const a = data.address;
          const parts = [a.city || a.town || a.village || a.county || '', a.suburb || a.neighbourhood || a.quarter || '', a.road || ''].filter(Boolean);
          const shortAddr = parts.join(' ') || data.display_name.split(',').slice(0, 3).join(' ');
          AppLogger.info(`他社乗車 Nominatim逆ジオコーディング成功: ${shortAddr}`);
          if (autoAdd) {
            autoAddEntry(shortAddr, { lat, lng });
          } else {
            setForm(prev => ({ ...prev, location: shortAddr, locationCoords: { lat, lng }, time: getNowTime() }));
            setGpsInfo(prev => ({ ...prev, lat, lng, address: data.display_name || shortAddr }));
          }
        } else {
          const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
          if (autoAdd) {
            autoAddEntry(coordStr, { lat, lng });
          } else {
            setForm(prev => ({ ...prev, location: coordStr, locationCoords: { lat, lng }, time: getNowTime() }));
            setGpsInfo(prev => ({ ...prev, lat, lng, address: null }));
          }
        }
      })
      .catch(() => {
        setGpsLoading(false);
        const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
        if (autoAdd) {
          autoAddEntry(coordStr, { lat, lng });
        } else {
          setForm(prev => ({ ...prev, location: coordStr, locationCoords: { lat, lng } }));
          setGpsInfo(prev => ({ ...prev, lat, lng, address: null }));
        }
      });
  };

  function _formatRivalAddress(result) {
    const comps = result.address_components;
    let prefecture = '', city = '', ward = '', town = '', sublocality = '';
    for (const c of comps) {
      if (c.types.includes('administrative_area_level_1')) prefecture = c.long_name;
      if (c.types.includes('locality')) city = c.long_name;
      if (c.types.includes('sublocality_level_1') || c.types.includes('ward')) ward = c.long_name;
      if (c.types.includes('sublocality_level_2')) town = c.long_name;
      if (c.types.includes('sublocality_level_3')) sublocality = c.long_name;
    }
    const parts = [ward || city || prefecture, town, sublocality].filter(Boolean);
    if (parts.length > 0) return parts.join(' ');
    return result.formatted_address.replace(/、日本$/, '').replace(/^日本、/, '');
  }

  const entries = useMemo(() => DataService.getRivalEntries(), [refreshKey]);

  useEffect(() => {
    const handleStorage = (e) => {
      if (e.key === APP_CONSTANTS.STORAGE_KEYS.RIVAL_RIDES) {
        setRefreshKey(k => k + 1);
      }
    };
    window.addEventListener('storage', handleStorage);
    const handleVisibility = () => {
      if (!document.hidden) setRefreshKey(k => k + 1);
    };
    document.addEventListener('visibilitychange', handleVisibility);
    return () => {
      window.removeEventListener('storage', handleStorage);
      document.removeEventListener('visibilitychange', handleVisibility);
    };
  }, []);

  const handleSubmit = (e) => {
    e.preventDefault();
    setErrors([]);
    const result = DataService.addRivalEntry(form);
    if (!result.success) {
      setErrors(result.errors);
      return;
    }
    setForm({ date: todayDefault, time: getNowTime(), weather: form.weather, location: '', locationCoords: null, memo: '' });
    setGpsInfo(null);
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
    setRefreshKey(k => k + 1);
  };

  const handleDelete = useCallback((id) => {
    DataService.deleteRivalEntry(id);
    setRefreshKey(k => k + 1);
  }, []);

  const handleExportCSV = () => {
    DataService.downloadRivalCSV();
  };

  const handleClearAll = () => {
    if (entries.length === 0) return;
    DataService.clearAllRivalEntries();
    setRefreshKey(k => k + 1);
  };

  const gpsButtonStyle = (loading) => ({
    display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
    padding: '8px 12px', borderRadius: '6px',
    fontSize: '11px', fontWeight: '600',
    color: loading ? 'var(--color-secondary)' : '#fff',
    cursor: loading ? 'wait' : 'pointer',
    border: '1px solid rgba(255,255,255,0.15)',
    background: loading ? 'rgba(249,168,37,0.15)' : 'rgba(26,115,232,0.2)',
    transition: 'all 0.2s ease',
    whiteSpace: 'nowrap',
    minWidth: '0',
    flex: '0 0 auto',
  });

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'local_taxi'),
      '他社乗車情報'
    ),

    // 記録件数
    React.createElement(Card, { style: { marginBottom: 'var(--space-lg)', textAlign: 'center' } },
      React.createElement('div', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)' } }, '他社乗車記録'),
      React.createElement('div', {
        style: { fontSize: 'var(--font-size-2xl)', fontWeight: 700, color: 'var(--color-primary-light)', margin: '8px 0' },
      }, `${entries.length} 件`),
      React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-xs)' } },
        entries.length > 0 ? `最新: ${entries[0].date} ${entries[0].time}` : 'まだ記録がありません'
      )
    ),

    // 入力フォーム
    React.createElement(Card, { title: '他社乗車を記録', style: { marginBottom: 'var(--space-lg)' } },
      errors.length > 0 && React.createElement('div', {
        style: {
          background: 'rgba(229,57,53,0.1)', border: '1px solid rgba(229,57,53,0.3)',
          borderRadius: '8px', padding: '8px 12px', marginBottom: 'var(--space-md)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: 'var(--color-danger)' },
        }, 'error'),
        React.createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-danger)' } },
          errors.join('、')
        )
      ),

      saved && React.createElement('div', {
        style: {
          background: 'rgba(0,200,83,0.1)', border: '1px solid rgba(0,200,83,0.3)',
          borderRadius: '8px', padding: '8px 12px', marginBottom: 'var(--space-md)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: 'var(--color-accent)' },
        }, 'check_circle'),
        React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-accent)' } },
          '記録を追加しました'
        )
      ),

      React.createElement('form', { onSubmit: handleSubmit },
        React.createElement('div', { className: 'grid grid--2' },
          // 日付
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '年月日 *',
              React.createElement('span', {
                style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: '400', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.1)' },
              }, '自動')
            ),
            React.createElement('input', {
              className: 'form-input',
              type: 'date',
              value: form.date,
              onChange: (e) => setForm({ ...form, date: e.target.value }),
              required: true,
              style: { colorScheme: 'dark' },
            }),
            form.date && (() => {
              const info = JapaneseHolidays.getDateInfo(form.date);
              const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-secondary)';
              return React.createElement('div', {
                style: { marginTop: '6px', display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' },
              },
                React.createElement('span', {
                  style: {
                    fontSize: '13px', fontWeight: '600', color: dayColor,
                    padding: '2px 10px', borderRadius: '4px',
                    background: info.isSunday || info.isHoliday ? 'rgba(239,68,68,0.12)' : info.isSaturday ? 'rgba(59,130,246,0.12)' : 'rgba(255,255,255,0.06)',
                  },
                }, `${info.dayOfWeek}曜日`),
                info.holiday && React.createElement('span', {
                  style: {
                    fontSize: '12px', fontWeight: '600', color: '#ef4444',
                    padding: '2px 10px', borderRadius: '4px',
                    background: 'rgba(239,68,68,0.12)',
                    display: 'flex', alignItems: 'center', gap: '4px',
                  },
                },
                  React.createElement('span', { style: { fontSize: '13px' } }, '🎌'),
                  info.holiday
                )
              );
            })()
          ),

          // 時間
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '時間 *',
              React.createElement('span', {
                style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: '400', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.1)' },
              }, '自動')
            ),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'stretch' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'time',
                value: form.time,
                onChange: (e) => setForm({ ...form, time: e.target.value }),
                required: true,
                style: { flex: 1, minWidth: 0, colorScheme: 'dark' },
              }),
              React.createElement('button', {
                type: 'button',
                onClick: () => setForm({ ...form, time: getNowTime() }),
                style: {
                  display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
                  padding: '8px 12px', borderRadius: '6px', fontSize: '11px', fontWeight: '600',
                  color: '#fff', cursor: 'pointer',
                  border: '1px solid rgba(255,255,255,0.15)',
                  background: 'rgba(0,200,83,0.2)',
                  transition: 'all 0.2s ease', whiteSpace: 'nowrap', flex: '0 0 auto',
                },
                title: '現在時刻をセット',
              },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'schedule'),
                '現在'
              )
            )
          ),

          // 天候
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '天気',
              weatherLoading && React.createElement('span', {
                style: { fontSize: '11px', color: 'var(--color-secondary)', fontWeight: '400', animation: 'pulse 1.5s ease-in-out infinite' },
              }, '取得中...'),
              !weatherLoading && form.weather && React.createElement('span', {
                style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: '400', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.1)' },
              }, '自動取得済')
            ),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              ...[
                { value: '晴れ', icon: '☀️' },
                { value: '曇り', icon: '☁️' },
                { value: '雨', icon: '🌧️' },
                { value: '雪', icon: '❄️' },
              ].map(w =>
                React.createElement('button', {
                  key: w.value,
                  type: 'button',
                  onClick: () => setForm({ ...form, weather: form.weather === w.value ? '' : w.value }),
                  style: {
                    display: 'flex', alignItems: 'center', gap: '4px',
                    padding: '8px 14px', borderRadius: '8px',
                    fontSize: '13px', fontWeight: form.weather === w.value ? '700' : '400',
                    cursor: 'pointer',
                    border: form.weather === w.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.weather === w.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.weather === w.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', { style: { fontSize: '16px' } }, w.icon),
                  w.value
                )
              )
            )
          ),

          // 乗車場所（GPS付き）
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '乗車場所 *',
              gpsLoading && React.createElement('span', {
                style: { fontSize: '11px', color: 'var(--color-secondary)', fontWeight: '400', animation: 'pulse 1.5s ease-in-out infinite' },
              }, '取得中...'),
              !gpsLoading && form.location && React.createElement('span', {
                style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: '400', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.1)' },
              }, 'GPS取得済')
            ),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'stretch' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'text',
                placeholder: '東京駅前',
                value: form.location,
                onChange: (e) => { setForm({ ...form, location: e.target.value }); if (!e.target.value) setGpsInfo(null); },
                required: true,
                style: { flex: 1, minWidth: 0 },
              }),
              React.createElement('button', {
                type: 'button',
                onClick: getGpsLocation,
                disabled: gpsLoading,
                style: gpsButtonStyle(gpsLoading),
                title: 'GPSで現在地を取得',
              },
                React.createElement('span', {
                  className: 'material-icons-round',
                  style: { fontSize: '16px', animation: gpsLoading ? 'spin 1s linear infinite' : 'none' },
                }, gpsLoading ? 'sync' : 'my_location'),
                gpsLoading ? '取得中' : 'GPS'
              )
            ),
            gpsInfo && gpsInfo.lat && React.createElement('div', {
              style: {
                marginTop: '6px', padding: '8px 10px', borderRadius: '6px',
                background: 'rgba(26,115,232,0.08)', border: '1px solid rgba(26,115,232,0.15)',
                fontSize: '11px', color: 'var(--text-secondary)', lineHeight: '1.6',
              },
            },
              gpsInfo.address && React.createElement('div', { style: { display: 'flex', alignItems: 'flex-start', gap: '4px', marginBottom: '4px' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '13px', color: 'var(--color-primary-light)', marginTop: '1px', flexShrink: 0 } }, 'place'),
                React.createElement('span', { style: { fontWeight: '600', color: 'var(--color-primary-light)', wordBreak: 'break-all' } }, gpsInfo.address)
              ),
              // 座標 + 精度
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '4px', color: 'var(--text-muted)', fontSize: '10px', flexWrap: 'wrap' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px', flexShrink: 0 } }, 'gps_fixed'),
                `${gpsInfo.lat.toFixed(6)}, ${gpsInfo.lng.toFixed(6)}`,
                gpsInfo.accuracy && React.createElement('span', {
                  style: {
                    padding: '1px 6px', borderRadius: '3px', fontWeight: '600',
                    background: gpsInfo.accuracy <= 50 ? 'rgba(0,200,83,0.15)' : gpsInfo.accuracy <= 200 ? 'rgba(249,168,37,0.15)' : 'rgba(229,57,53,0.15)',
                    color: gpsInfo.accuracy <= 50 ? '#4caf50' : gpsInfo.accuracy <= 200 ? '#f9a825' : '#e53935',
                  },
                }, `精度 ${gpsInfo.accuracy}m`)
              ),
              // Google Maps で確認リンク
              React.createElement('div', { style: { marginTop: '4px' } },
                React.createElement('a', {
                  href: `https://www.google.com/maps?q=${gpsInfo.lat},${gpsInfo.lng}`,
                  target: '_blank',
                  rel: 'noopener',
                  style: { fontSize: '10px', color: 'var(--color-primary-light)', textDecoration: 'underline' },
                }, 'Google Mapsで位置を確認'),
              ),
              // 精度が低い場合のガイド
              gpsInfo.accuracy && gpsInfo.accuracy > 100 && React.createElement('div', {
                style: {
                  marginTop: '6px', padding: '6px 8px', borderRadius: '4px',
                  background: 'rgba(249,168,37,0.1)', border: '1px solid rgba(249,168,37,0.2)',
                  fontSize: '10px', color: '#f9a825', lineHeight: '1.5',
                },
              },
                React.createElement('div', { style: { fontWeight: '600', marginBottom: '2px' } }, 'GPS精度が低い場合:'),
                React.createElement('div', null, '・Androidの設定 → 位置情報 → 「正確な位置情報」をON'),
                React.createElement('div', null, '・Chromeの権限 → 位置情報 → 「正確な位置情報」を許可'),
                React.createElement('div', null, '・屋外で再取得すると精度が向上します')
              )
            )
          ),

          // メモ
          React.createElement('div', { className: 'form-group', style: { gridColumn: '1 / -1' } },
            React.createElement('label', { className: 'form-label' }, 'メモ'),
            React.createElement('input', {
              className: 'form-input',
              type: 'text',
              placeholder: '任意のメモ',
              value: form.memo,
              onChange: (e) => setForm({ ...form, memo: e.target.value }),
            })
          ),

          // 送信ボタン
          React.createElement('div', { style: { gridColumn: '1 / -1', marginTop: 'var(--space-sm)' } },
            React.createElement(Button, {
              variant: 'primary',
              icon: 'add',
              type: 'submit',
            }, '記録')
          )
        )
      )
    ),

    // データ管理ツールバー
    React.createElement(Card, { style: { marginBottom: 'var(--space-md)' } },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '10px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--color-primary-light)' } }, 'folder'),
        React.createElement('span', { style: { fontSize: '13px', fontWeight: '600', color: 'var(--text-primary)' } }, 'データ管理'),
        entries.length > 0 && React.createElement('span', { style: { fontSize: '11px', color: 'var(--text-muted)', marginLeft: 'auto' } },
          `全 ${entries.length} 件の記録`
        )
      ),
      React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
        // 保存先フォルダ選択
        React.createElement(Button, {
          variant: 'secondary',
          icon: DataService.hasSaveFolder() ? 'folder_open' : 'create_new_folder',
          onClick: async () => {
            const result = await DataService.selectSaveFolder();
            if (result.success) {
              setSaved(false); setErrors([]);
              alert('保存先フォルダを設定しました: ' + result.folderName + '\n\n記録の追加時に自動保存されます。\n（売上記録と共通の親フォルダです）');
              setRefreshKey(k => k + 1);
            } else {
              if (result.message) alert(result.message);
            }
          },
          style: { padding: '6px 12px', fontSize: '11px' },
        }, DataService.hasSaveFolder() ? '保存先変更' : '保存先フォルダ設定'),
        // 手動保存
        entries.length > 0 && React.createElement(Button, {
          variant: 'secondary',
          icon: 'save',
          onClick: () => DataService.manualSaveRivalToFile(),
          style: { padding: '6px 12px', fontSize: '11px' },
        }, 'JSON保存'),
        entries.length > 0 && React.createElement(Button, {
          variant: 'secondary',
          icon: 'download',
          onClick: handleExportCSV,
          style: { padding: '6px 12px', fontSize: '11px' },
        }, 'CSV出力'),
        entries.length > 0 && React.createElement(Button, {
          variant: 'danger',
          icon: 'delete_forever',
          onClick: () => { if (confirm('全ての他社乗車記録を削除しますか？この操作は取り消せません。')) handleClearAll(); },
          style: { padding: '6px 12px', fontSize: '11px' },
        }, '全削除')
      ),
      // 保存先フォルダ状態表示
      React.createElement('div', {
        style: { marginTop: '8px', fontSize: '10px', color: 'var(--text-muted)', display: 'flex', alignItems: 'center', gap: '4px' },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px' } }, 'info'),
        DataService.hasSaveFolder()
          ? '保存先フォルダ設定済み — 「他社乗車」サブフォルダに自動保存されます'
          : '保存先フォルダ未設定 — 記録追加時にダウンロードとして保存されます'
      )
    ),

    // 記録一覧
    entries.length > 0 && React.createElement(Card, { title: `記録一覧（${entries.length}件）` },
      entries.map(entry =>
        React.createElement('div', {
          key: entry.id,
          style: {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            padding: '12px 0',
            borderBottom: '1px solid rgba(255,255,255,0.06)',
          },
        },
          React.createElement('div', { style: { flex: 1 } },
            React.createElement('div', { style: { fontWeight: 500, display: 'flex', alignItems: 'center', gap: '6px', flexWrap: 'wrap' } },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: 'var(--color-primary-light)' } }, 'local_taxi'),
              React.createElement('span', null, entry.location || '---')
            ),
            React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', display: 'flex', flexWrap: 'wrap', alignItems: 'center', gap: '4px', marginTop: '4px' } },
              (() => {
                const info = entry.dayOfWeek ? { dayOfWeek: entry.dayOfWeek, holiday: entry.holiday, isSunday: entry.dayOfWeek === '日', isSaturday: entry.dayOfWeek === '土', isHoliday: !!entry.holiday } : JapaneseHolidays.getDateInfo(entry.date);
                const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-muted)';
                return React.createElement(React.Fragment, null,
                  React.createElement('span', null, entry.date),
                  React.createElement('span', { style: { color: dayColor, fontWeight: '600' } }, `(${info.dayOfWeek})`),
                  info.holiday && React.createElement('span', {
                    style: { color: '#ef4444', fontSize: '10px', padding: '1px 6px', borderRadius: '3px', background: 'rgba(239,68,68,0.1)' },
                  }, info.holiday),
                  entry.time && React.createElement('span', {
                    style: { fontSize: '11px', color: 'var(--color-primary-light)', fontWeight: '600', padding: '1px 6px', borderRadius: '3px', background: 'rgba(26,115,232,0.12)' },
                  }, entry.time),
                  entry.weather && React.createElement('span', null, entry.weather),
                  entry.memo && React.createElement('span', null, `| ${entry.memo}`)
                );
              })()
            )
          ),
          React.createElement('button', {
            onClick: () => handleDelete(entry.id),
            style: {
              background: 'none', border: 'none', cursor: 'pointer',
              color: 'var(--text-muted)', padding: '4px',
              borderRadius: '4px', transition: 'color 0.2s',
            },
            title: '削除',
          },
            React.createElement('span', {
              className: 'material-icons-round',
              style: { fontSize: '18px' },
            }, 'delete_outline')
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/TransitInfo.jsx
// ============================================================
(function() {
// TransitInfo.jsx - 公共交通機関情報ページ
// Gemini AI を使用して電車・バス・飛行機の運行情報と遅延情報を取得・保存
window.TransitInfoPage = () => {
  const { useState, useCallback, useEffect, useMemo, useRef } = React;
  const { geminiApiKey, apiKey } = useAppContext();

  const STORAGE_KEY = APP_CONSTANTS.STORAGE_KEYS.TRANSIT_INFO;

  // GPS地域検出
  const [region, setRegion] = useState(null);
  const [regionLoading, setRegionLoading] = useState(false);
  const regionFetched = useRef(false);

  // ページ読み込み時にGPSで現在地の地域を取得
  useEffect(() => {
    if (regionFetched.current) return;
    regionFetched.current = true;

    if (!navigator.geolocation) return;
    setRegionLoading(true);

    getAccuratePosition({ accuracyThreshold: 500, timeout: 10000, maxWaitAfterFix: 3000 })
      .then((position) => {
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;

        // Google Maps Geocoder があれば使用
        if (apiKey && window.google && window.google.maps) {
          const geocoder = new google.maps.Geocoder();
          geocoder.geocode({ location: { lat, lng } }, (results, status) => {
            setRegionLoading(false);
            if (status === 'OK' && results[0]) {
              const comps = results[0].address_components;
              let prefecture = '', city = '';
              for (const c of comps) {
                if (c.types.includes('administrative_area_level_1')) prefecture = c.long_name;
                if (c.types.includes('locality')) city = c.long_name;
                if (!city && (c.types.includes('sublocality_level_1') || c.types.includes('ward'))) city = c.long_name;
              }
              const regionStr = [prefecture, city].filter(Boolean).join(' ');
              if (regionStr) {
                setRegion(regionStr);
                AppLogger.info(`交通情報: 地域検出成功 (Google) - ${regionStr}`);
              }
            } else {
              // Google失敗時はNominatimにフォールバック
              _fetchRegionNominatim(lat, lng);
            }
          });
        } else {
          // Nominatimで逆ジオコーディング
          _fetchRegionNominatim(lat, lng);
        }
      })
      .catch((err) => {
        setRegionLoading(false);
        AppLogger.warn('交通情報: 地域検出失敗 - ' + (err.message || ''));
      });
  }, [apiKey]);

  // Nominatim逆ジオコーディングで地域名を取得
  const _fetchRegionNominatim = useCallback((lat, lng) => {
    const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=10&addressdetails=1&accept-language=ja`;
    fetch(url)
      .then(res => res.json())
      .then(data => {
        setRegionLoading(false);
        if (data && data.address) {
          const a = data.address;
          const prefecture = a.province || a.state || '';
          const city = a.city || a.town || a.village || a.county || '';
          const regionStr = [prefecture, city].filter(Boolean).join(' ');
          if (regionStr) {
            setRegion(regionStr);
            AppLogger.info(`交通情報: 地域検出成功 (Nominatim) - ${regionStr}`);
          }
        }
      })
      .catch(() => {
        setRegionLoading(false);
      });
  }, []);

  // カテゴリ定義
  const categories = useMemo(() => [
    { key: 'trouble', icon: 'warning',        label: '遅延・トラブル', color: '229,57,53',  fetchFn: GeminiService.fetchTroubleInfo },
    { key: 'train',   icon: 'train',           label: '電車',           color: '26,115,232',  fetchFn: GeminiService.fetchTrainInfo },
    { key: 'bus',     icon: 'directions_bus',   label: 'バス',           color: '46,125,50',   fetchFn: GeminiService.fetchBusInfo },
    { key: 'flight',  icon: 'flight',           label: '飛行機',         color: '156,39,176',  fetchFn: GeminiService.fetchFlightInfo },
  ], []);

  // localStorageから保存済みデータを読み込み
  const loadSaved = () => {
    const saved = AppStorage.get(STORAGE_KEY, {});
    const result = {};
    categories.forEach(c => {
      const s = saved[c.key];
      result[c.key] = { loading: false, result: s?.text || null, error: null, fetchedAt: s?.fetchedAt || null };
    });
    return result;
  };

  const [data, setData] = useState(loadSaved);
  const [activeTab, setActiveTab] = useState('trouble');

  // データをlocalStorageに保存 + ファイル保存
  const saveToStorage = useCallback((newData) => {
    const toSave = {};
    Object.keys(newData).forEach(key => {
      if (newData[key].result) {
        toSave[key] = { text: newData[key].result, fetchedAt: newData[key].fetchedAt };
      }
    });
    AppStorage.set(STORAGE_KEY, toSave);
    // 保存先フォルダが設定されていればファイルにも保存
    DataService.autoSaveTransitToFile(toSave);
    window.dispatchEvent(new CustomEvent('taxi-data-changed', { detail: { type: 'transit' } }));
  }, [STORAGE_KEY]);

  // カテゴリ別取得
  const handleFetch = useCallback(async (categoryKey) => {
    const cat = categories.find(c => c.key === categoryKey);
    if (!cat) return;

    setData(prev => ({ ...prev, [categoryKey]: { ...prev[categoryKey], loading: true, error: null } }));

    const result = await cat.fetchFn(geminiApiKey, region);
    const now = new Date().toISOString();

    setData(prev => {
      const updated = {
        ...prev,
        [categoryKey]: {
          loading: false,
          result: result.success ? result.text : prev[categoryKey].result,
          error: result.success ? null : result.error,
          fetchedAt: result.success ? now : prev[categoryKey].fetchedAt,
        }
      };
      if (result.success) saveToStorage(updated);
      return updated;
    });

    // 遅延・トラブル情報取得成功時にプッシュ通知
    if (categoryKey === 'trouble' && result.success && result.text) {
      NotificationService.sendTroubleAlert(result.text);
    }
  }, [geminiApiKey, region, categories, saveToStorage]);

  // 全カテゴリ一括取得
  const handleFetchAll = useCallback(async () => {
    for (const cat of categories) {
      await handleFetch(cat.key);
    }
  }, [categories, handleFetch]);

  // 取得時刻のフォーマット
  const formatTime = (isoStr) => {
    if (!isoStr) return null;
    const d = new Date(isoStr);
    return d.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
  };

  // Geminiテキストを見やすく整形するレンダラー
  const renderFormattedText = (text) => {
    if (!text) return null;

    const lines = text.split('\n');
    const elements = [];

    lines.forEach((line, idx) => {
      const trimmed = line.trim();
      if (!trimmed) {
        elements.push(React.createElement('div', { key: idx, style: { height: '6px' } }));
        return;
      }

      // ### 見出し3
      if (trimmed.startsWith('### ')) {
        elements.push(React.createElement('div', {
          key: idx,
          style: {
            fontSize: '12px', fontWeight: 600, color: 'var(--text-secondary)',
            marginTop: '12px', marginBottom: '4px', paddingBottom: '3px',
            borderBottom: '1px solid rgba(255,255,255,0.06)',
          },
        }, renderInlineFormatting(trimmed.slice(4))));
        return;
      }

      // ## 見出し2
      if (trimmed.startsWith('## ')) {
        elements.push(React.createElement('div', {
          key: idx,
          style: {
            fontSize: '13px', fontWeight: 700, color: 'var(--color-primary-light)',
            marginTop: '14px', marginBottom: '6px', paddingBottom: '4px',
            borderBottom: '1px solid rgba(26,115,232,0.2)',
            display: 'flex', alignItems: 'center', gap: '6px',
          },
        }, renderInlineFormatting(trimmed.slice(3))));
        return;
      }

      // # 見出し1
      if (trimmed.startsWith('# ')) {
        elements.push(React.createElement('div', {
          key: idx,
          style: {
            fontSize: '14px', fontWeight: 700, color: 'var(--text-primary)',
            marginTop: '16px', marginBottom: '8px', paddingBottom: '6px',
            borderBottom: '2px solid rgba(26,115,232,0.3)',
          },
        }, renderInlineFormatting(trimmed.slice(2))));
        return;
      }

      // 【セクション】ヘッダー
      if (trimmed.startsWith('\u3010') && trimmed.includes('\u3011')) {
        elements.push(React.createElement('div', {
          key: idx,
          style: {
            fontSize: '13px', fontWeight: 700, color: 'var(--color-primary-light)',
            marginTop: '14px', marginBottom: '6px', padding: '6px 10px',
            borderRadius: '6px', background: 'rgba(26,115,232,0.08)',
            borderLeft: '3px solid rgba(26,115,232,0.5)',
          },
        }, renderInlineFormatting(trimmed)));
        return;
      }

      // 表区切り線 (|---|---| 形式) - スキップ
      if (/^\|[\s\-:]+\|/.test(trimmed) && !trimmed.replace(/[\|\s\-:]/g, '')) {
        return;
      }

      // テーブル行 (| cell | cell |)
      if (trimmed.startsWith('|') && trimmed.endsWith('|')) {
        const cells = trimmed.split('|').filter(c => c.trim());
        const isHeader = idx + 1 < lines.length && /^\|[\s\-:]+\|/.test(lines[idx + 1]?.trim() || '');
        elements.push(React.createElement('div', {
          key: idx,
          style: {
            display: 'grid',
            gridTemplateColumns: `repeat(${cells.length}, 1fr)`,
            gap: '1px', fontSize: '11px',
            background: 'rgba(255,255,255,0.04)', borderRadius: idx === 0 ? '4px 4px 0 0' : '0',
          },
        },
          cells.map((cell, ci) => React.createElement('div', {
            key: ci,
            style: {
              padding: '5px 8px',
              fontWeight: isHeader ? 700 : 400,
              color: isHeader ? 'var(--text-primary)' : 'var(--text-secondary)',
              background: isHeader ? 'rgba(26,115,232,0.08)' : 'rgba(255,255,255,0.02)',
              borderBottom: '1px solid rgba(255,255,255,0.05)',
              whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis',
            },
          }, renderInlineFormatting(cell.trim())))
        ));
        return;
      }

      // 箇条書き (- / * / ・)
      if (/^[-*\u30FB]/.test(trimmed) && trimmed.length > 1) {
        const content = trimmed.replace(/^[-*\u30FB]\s*/, '');
        elements.push(React.createElement('div', {
          key: idx,
          style: {
            display: 'flex', gap: '6px', fontSize: '12px', color: 'var(--text-primary)',
            padding: '2px 0 2px 8px', lineHeight: 1.6,
          },
        },
          React.createElement('span', { style: { color: 'var(--color-primary-light)', flexShrink: 0, marginTop: '2px', fontSize: '8px' } }, '\u25CF'),
          React.createElement('span', null, renderInlineFormatting(content))
        ));
        return;
      }

      // 番号付きリスト (1. / 2.)
      if (/^\d+[\.\)]\s/.test(trimmed)) {
        const num = trimmed.match(/^(\d+)[\.\)]\s/)[1];
        const content = trimmed.replace(/^\d+[\.\)]\s*/, '');
        elements.push(React.createElement('div', {
          key: idx,
          style: {
            display: 'flex', gap: '6px', fontSize: '12px', color: 'var(--text-primary)',
            padding: '2px 0 2px 4px', lineHeight: 1.6,
          },
        },
          React.createElement('span', {
            style: {
              color: 'var(--color-primary-light)', flexShrink: 0, fontWeight: 600,
              fontSize: '11px', minWidth: '16px', textAlign: 'right',
            },
          }, num + '.'),
          React.createElement('span', null, renderInlineFormatting(content))
        ));
        return;
      }

      // 通常テキスト
      elements.push(React.createElement('div', {
        key: idx,
        style: { fontSize: '12px', color: 'var(--text-primary)', lineHeight: 1.7, padding: '1px 0' },
      }, renderInlineFormatting(trimmed)));
    });

    return elements;
  };

  // インライン書式（太字・強調）
  const renderInlineFormatting = (text) => {
    if (!text) return '';
    // **太字**
    const parts = text.split(/(\*\*[^*]+\*\*)/g);
    if (parts.length <= 1) return text;
    return parts.map((part, i) => {
      if (part.startsWith('**') && part.endsWith('**')) {
        return React.createElement('strong', {
          key: i,
          style: { fontWeight: 700, color: 'var(--text-primary)' },
        }, part.slice(2, -2));
      }
      return part;
    });
  };

  // APIキー未設定時
  if (!geminiApiKey) {
    return React.createElement('div', null,
      React.createElement('h1', { className: 'page-title' },
        React.createElement('span', { className: 'material-icons-round' }, 'directions_transit'),
        '公共交通機関情報'
      ),
      React.createElement(Card, null,
        React.createElement('div', {
          style: {
            textAlign: 'center', padding: 'var(--space-lg)',
            display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '10px',
          },
        },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '36px', color: 'var(--color-primary-light)', opacity: 0.5 },
          }, 'smart_toy'),
          React.createElement('div', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)' } }, '公共交通機関情報'),
          React.createElement('div', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-xs)', lineHeight: 1.6 } },
            'Gemini APIキーを設定すると、AIで交通機関の運行情報を取得できます'
          ),
          React.createElement(Button, {
            variant: 'secondary',
            icon: 'settings',
            onClick: () => document.dispatchEvent(new CustomEvent('navigate', { detail: 'settings' })),
            style: { fontSize: '12px' },
          }, '設定ページへ')
        )
      )
    );
  }

  const today = new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
  const anyLoading = categories.some(c => data[c.key]?.loading);
  const activeCat = categories.find(c => c.key === activeTab);
  const activeData = data[activeTab] || { loading: false, result: null, error: null, fetchedAt: null };

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'directions_transit'),
      '公共交通機関情報'
    ),

    // 上部: 日付 + 取得ボタン群
    React.createElement(Card, { style: { marginBottom: 'var(--space-md)' } },
      // 日付 + 地域
      React.createElement('div', {
        style: {
          display: 'flex', alignItems: 'center', justifyContent: 'space-between',
          marginBottom: '8px', flexWrap: 'wrap', gap: '8px',
        },
      },
        React.createElement('div', {
          style: { display: 'flex', flexDirection: 'column', gap: '4px' },
        },
          React.createElement('div', {
            style: { display: 'flex', alignItems: 'center', gap: '6px', fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)' },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'today'),
            today
          ),
          React.createElement('div', {
            style: { display: 'flex', alignItems: 'center', gap: '4px', fontSize: '11px', color: 'var(--text-muted)' },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, regionLoading ? 'sync' : 'place'),
            regionLoading ? '地域を検出中...'
              : region ? region
              : 'GPS地域未検出（デフォルト: 東京都内）'
          )
        ),
        React.createElement(Button, {
          variant: 'primary',
          icon: anyLoading ? 'sync' : 'refresh',
          onClick: handleFetchAll,
          disabled: anyLoading,
          style: { fontSize: '11px', padding: '6px 12px' },
        }, anyLoading ? '取得中...' : 'すべて取得')
      ),

      // 個別取得ボタン群
      React.createElement('div', {
        style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '6px' },
      },
        categories.map(cat => {
          const catData = data[cat.key] || {};
          const hasData = !!catData.result;
          const isLoading = catData.loading;
          return React.createElement('button', {
            key: cat.key,
            onClick: () => { if (!isLoading) handleFetch(cat.key); },
            disabled: isLoading,
            style: {
              display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '4px',
              padding: '10px 4px', borderRadius: '10px', border: 'none',
              background: isLoading ? 'rgba(255,255,255,0.08)' : `rgba(${cat.color}, 0.1)`,
              cursor: isLoading ? 'wait' : 'pointer', transition: 'all 0.15s',
              opacity: isLoading ? 0.7 : 1,
            },
            onMouseEnter: (e) => { if (!isLoading) e.currentTarget.style.background = `rgba(${cat.color}, 0.2)`; },
            onMouseLeave: (e) => { e.currentTarget.style.background = isLoading ? 'rgba(255,255,255,0.08)' : `rgba(${cat.color}, 0.1)`; },
          },
            React.createElement('span', {
              className: 'material-icons-round',
              style: {
                fontSize: '22px', color: `rgb(${cat.color})`,
                animation: isLoading ? 'spin 1s linear infinite' : 'none',
              },
            }, isLoading ? 'sync' : cat.icon),
            React.createElement('span', {
              style: { fontSize: '10px', fontWeight: 600, color: 'var(--text-primary)' },
            }, cat.label),
            // 取得済みマーク or 未取得
            hasData
              ? React.createElement('span', {
                  style: { fontSize: '9px', color: 'var(--text-muted)' },
                }, formatTime(catData.fetchedAt) + ' 取得')
              : React.createElement('span', {
                  style: { fontSize: '9px', color: 'var(--text-muted)', opacity: 0.5 },
                }, '未取得')
          );
        })
      )
    ),

    // タブ切り替え
    React.createElement('div', {
      style: {
        display: 'flex', gap: '2px', marginBottom: 'var(--space-sm)',
        background: 'rgba(255,255,255,0.03)', borderRadius: '10px', padding: '3px',
      },
    },
      categories.map(cat => {
        const isActive = activeTab === cat.key;
        const catData = data[cat.key] || {};
        return React.createElement('button', {
          key: cat.key,
          onClick: () => setActiveTab(cat.key),
          style: {
            flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
            padding: '8px 4px', borderRadius: '8px', border: 'none',
            background: isActive ? `rgba(${cat.color}, 0.15)` : 'transparent',
            color: isActive ? `rgb(${cat.color})` : 'var(--text-muted)',
            fontWeight: isActive ? 600 : 400, fontSize: '11px',
            cursor: 'pointer', transition: 'all 0.15s', position: 'relative',
          },
        },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '16px' },
          }, cat.icon),
          // モバイルではラベル非表示
          React.createElement('span', {
            style: { fontSize: '10px' },
            className: 'transit-tab-label',
          }, cat.label),
          // 取得済みドット
          catData.result && React.createElement('span', {
            style: {
              position: 'absolute', top: '4px', right: '4px',
              width: '5px', height: '5px', borderRadius: '50%',
              background: `rgb(${cat.color})`,
            },
          })
        );
      })
    ),

    // コンテンツエリア
    activeData.loading
      ? React.createElement(Card, null,
          React.createElement('div', {
            style: {
              padding: 'var(--space-xl)', textAlign: 'center',
              display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '10px',
            },
          },
            React.createElement('span', {
              className: 'material-icons-round',
              style: { fontSize: '36px', color: `rgb(${activeCat.color})`, animation: 'spin 1s linear infinite' },
            }, 'sync'),
            React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)' } },
              activeCat.label + 'の情報を取得中...'
            )
          )
        )
      : activeData.error
        ? React.createElement(Card, null,
            React.createElement('div', {
              style: {
                padding: '12px', borderRadius: '8px',
                background: 'rgba(229,57,53,0.08)', border: '1px solid rgba(229,57,53,0.2)',
                display: 'flex', alignItems: 'center', gap: '8px',
              },
            },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--color-danger)' } }, 'error'),
              React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-danger)' } }, activeData.error)
            )
          )
        : activeData.result
          ? React.createElement(Card, null,
              // ヘッダー: カテゴリ名 + 取得時刻 + 再取得ボタン
              React.createElement('div', {
                style: {
                  display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                  marginBottom: '12px', paddingBottom: '10px',
                  borderBottom: '1px solid rgba(255,255,255,0.06)',
                },
              },
                React.createElement('div', {
                  style: { display: 'flex', alignItems: 'center', gap: '8px' },
                },
                  React.createElement('span', {
                    className: 'material-icons-round',
                    style: { fontSize: '20px', color: `rgb(${activeCat.color})` },
                  }, activeCat.icon),
                  React.createElement('div', null,
                    React.createElement('div', { style: { fontWeight: 700, fontSize: '13px', color: 'var(--text-primary)' } },
                      activeCat.label + ' 運行情報'
                    ),
                    activeData.fetchedAt && React.createElement('div', {
                      style: { fontSize: '10px', color: 'var(--text-muted)', marginTop: '1px' },
                    },
                      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '10px', verticalAlign: 'middle', marginRight: '2px' } }, 'schedule'),
                      formatTime(activeData.fetchedAt) + ' に取得'
                    )
                  )
                ),
                React.createElement('button', {
                  onClick: () => handleFetch(activeTab),
                  style: {
                    display: 'flex', alignItems: 'center', gap: '4px',
                    padding: '4px 10px', borderRadius: '6px', border: 'none',
                    background: `rgba(${activeCat.color}, 0.1)`, color: `rgb(${activeCat.color})`,
                    fontSize: '11px', fontWeight: 600, cursor: 'pointer', transition: 'all 0.15s',
                  },
                  onMouseEnter: (e) => { e.currentTarget.style.background = `rgba(${activeCat.color}, 0.2)`; },
                  onMouseLeave: (e) => { e.currentTarget.style.background = `rgba(${activeCat.color}, 0.1)`; },
                },
                  React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'refresh'),
                  '再取得'
                )
              ),

              // 整形済みコンテンツ
              React.createElement('div', {
                style: { maxHeight: '60vh', overflowY: 'auto', padding: '0 2px' },
              }, renderFormattedText(activeData.result)),

              // 免責事項
              React.createElement('div', {
                style: {
                  marginTop: '12px', paddingTop: '8px',
                  borderTop: '1px solid rgba(255,255,255,0.06)',
                  fontSize: '10px', color: 'var(--text-muted)',
                  display: 'flex', alignItems: 'center', gap: '4px',
                },
              },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px' } }, 'info'),
                '※ AIによる回答です。最新情報は各交通機関の公式サイトでご確認ください'
              )
            )
          : // 未取得状態
            React.createElement(Card, null,
              React.createElement('div', {
                style: {
                  textAlign: 'center', padding: 'var(--space-xl)',
                  display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '10px',
                },
              },
                React.createElement('span', {
                  className: 'material-icons-round',
                  style: { fontSize: '40px', color: `rgb(${activeCat.color})`, opacity: 0.3 },
                }, activeCat.icon),
                React.createElement('div', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)' } },
                  activeCat.label + 'の情報がありません'
                ),
                React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: '11px', lineHeight: 1.5 } },
                  '上のボタンをタップして情報を取得してください'
                ),
                React.createElement(Button, {
                  variant: 'primary',
                  icon: 'download',
                  onClick: () => handleFetch(activeTab),
                  style: { fontSize: '12px', marginTop: '4px' },
                }, activeCat.label + 'の情報を取得')
              )
            )
  );
};

})();

// ============================================================
// FILE: src/pages/Events.jsx
// ============================================================
(function() {
// Events.jsx - イベント記録ページ
// 周辺イベントの記録CRUD（RivalRide.jsx パターン踏襲）
window.EventsPage = () => {
  const { useState, useEffect, useCallback, useRef, useMemo } = React;

  const todayDefault = new Date().toISOString().split('T')[0];

  const getNowTime = () => {
    const now = new Date();
    return `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
  };

  const [refreshKey, setRefreshKey] = useState(0);
  const [form, setForm] = useState({
    name: '', date: todayDefault, startTime: '', endTime: '',
    location: '', locationCoords: null, scale: '', impact: '', memo: '',
  });
  const [errors, setErrors] = useState([]);
  const [saved, setSaved] = useState(false);
  const [gpsLoading, setGpsLoading] = useState(false);
  const [gpsInfo, setGpsInfo] = useState(null);

  const { apiKey, geminiApiKey } = useAppContext();

  // Gemini イベント検索
  const [geminiQuery, setGeminiQuery] = useState('');
  const [geminiArea, setGeminiArea] = useState('');
  const [geminiLoading, setGeminiLoading] = useState(false);
  const [geminiResult, setGeminiResult] = useState(null);
  const [geminiError, setGeminiError] = useState(null);

  const handleGeminiSearch = useCallback(async () => {
    if (!geminiQuery.trim()) return;
    setGeminiLoading(true);
    setGeminiError(null);
    setGeminiResult(null);
    const result = await GeminiService.searchEvents(geminiApiKey, geminiQuery.trim(), geminiArea.trim());
    setGeminiLoading(false);
    if (result.success) {
      setGeminiResult(result.text);
    } else {
      setGeminiError(result.error);
    }
  }, [geminiApiKey, geminiQuery, geminiArea]);

  const quickEventQueries = [
    '今週末の東京都内のイベント',
    '本日のコンサート・ライブ情報',
    '今月の大規模スポーツイベント',
    '近日中の花火大会・お祭り',
  ];

  const entries = useMemo(() => DataService.getEvents(), [refreshKey]);

  // localStorage変更の監視
  useEffect(() => {
    const handleStorage = (e) => {
      if (e.key === APP_CONSTANTS.STORAGE_KEYS.EVENTS) {
        setRefreshKey(k => k + 1);
      }
    };
    window.addEventListener('storage', handleStorage);
    const handleVisibility = () => {
      if (!document.hidden) setRefreshKey(k => k + 1);
    };
    document.addEventListener('visibilitychange', handleVisibility);
    return () => {
      window.removeEventListener('storage', handleStorage);
      document.removeEventListener('visibilitychange', handleVisibility);
    };
  }, []);

  // GPS逆ジオコーディング
  const getGpsLocation = useCallback(() => {
    if (!navigator.geolocation) {
      setErrors(['このブラウザではGPS機能が使えません']);
      return;
    }
    setGpsLoading(true);
    setErrors([]);
    getAccuratePosition({ accuracyThreshold: 50, timeout: 20000, maxWaitAfterFix: 8000 })
      .then((position) => {
        reverseGeocode(position.coords.latitude, position.coords.longitude);
      })
      .catch((error) => {
        setGpsLoading(false);
        const messages = {
          1: 'GPS使用が許可されていません。ブラウザの設定を確認してください。',
          2: '現在地を取得できませんでした。',
          3: 'GPS取得がタイムアウトしました。',
        };
        setErrors([messages[error.code] || 'GPS取得に失敗しました']);
      });
  }, [apiKey]);

  const reverseGeocode = (lat, lng) => {
    if (apiKey && window.google && window.google.maps) {
      const geocoder = new google.maps.Geocoder();
      geocoder.geocode({ location: { lat, lng } }, (results, status) => {
        setGpsLoading(false);
        if (status === 'OK' && results[0]) {
          const address = formatAddress(results[0]);
          setForm(prev => ({ ...prev, location: address, locationCoords: { lat, lng } }));
          setGpsInfo({ lat, lng, address: results[0].formatted_address.replace(/、日本$/, '').replace(/^日本、/, '') });
        } else {
          nominatimFallback(lat, lng);
        }
      });
    } else {
      nominatimFallback(lat, lng);
    }
  };

  const nominatimFallback = (lat, lng) => {
    const nomUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=ja`;
    fetch(nomUrl)
      .then(res => res.json())
      .then(data => {
        setGpsLoading(false);
        if (data && data.address) {
          const a = data.address;
          const parts = [a.city || a.town || a.village || a.county || '', a.suburb || a.neighbourhood || a.quarter || '', a.road || ''].filter(Boolean);
          const shortAddr = parts.join(' ') || data.display_name.split(',').slice(0, 3).join(' ');
          setForm(prev => ({ ...prev, location: shortAddr, locationCoords: { lat, lng } }));
          setGpsInfo({ lat, lng, address: data.display_name || shortAddr });
        } else {
          const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
          setForm(prev => ({ ...prev, location: coordStr, locationCoords: { lat, lng } }));
          setGpsInfo({ lat, lng, address: null });
        }
      })
      .catch(() => {
        setGpsLoading(false);
        const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
        setForm(prev => ({ ...prev, location: coordStr, locationCoords: { lat, lng } }));
        setGpsInfo({ lat, lng, address: null });
      });
  };

  function formatAddress(result) {
    const comps = result.address_components;
    let prefecture = '', city = '', ward = '', town = '', sublocality = '';
    for (const c of comps) {
      if (c.types.includes('administrative_area_level_1')) prefecture = c.long_name;
      if (c.types.includes('locality')) city = c.long_name;
      if (c.types.includes('sublocality_level_1') || c.types.includes('ward')) ward = c.long_name;
      if (c.types.includes('sublocality_level_2')) town = c.long_name;
      if (c.types.includes('sublocality_level_3')) sublocality = c.long_name;
    }
    const parts = [ward || city || prefecture, town, sublocality].filter(Boolean);
    if (parts.length > 0) return parts.join(' ');
    return result.formatted_address.replace(/、日本$/, '').replace(/^日本、/, '');
  }

  const handleSubmit = (e) => {
    e.preventDefault();
    setErrors([]);
    const result = DataService.addEvent(form);
    if (!result.success) {
      setErrors(result.errors);
      return;
    }
    setForm({
      name: '', date: todayDefault, startTime: '', endTime: '',
      location: '', locationCoords: null, scale: '', impact: '', memo: '',
    });
    setGpsInfo(null);
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
    setRefreshKey(k => k + 1);
  };

  const handleDelete = useCallback((id) => {
    DataService.deleteEvent(id);
    setRefreshKey(k => k + 1);
  }, []);

  const handleClearAll = () => {
    if (entries.length === 0) return;
    DataService.clearAllEvents();
    setRefreshKey(k => k + 1);
  };

  const scaleOptions = [
    { value: '小', label: '小', desc: '〜100人' },
    { value: '中', label: '中', desc: '100〜1000人' },
    { value: '大', label: '大', desc: '1000〜10000人' },
    { value: '特大', label: '特大', desc: '10000人〜' },
  ];

  const impactOptions = [
    { value: '需要増', icon: 'trending_up', color: 'var(--color-accent)' },
    { value: '需要減', icon: 'trending_down', color: 'var(--color-danger)' },
    { value: '不明', icon: 'help_outline', color: 'var(--text-muted)' },
  ];

  const gpsButtonStyle = (loading) => ({
    display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
    padding: '8px 12px', borderRadius: '6px',
    fontSize: '11px', fontWeight: '600',
    color: loading ? 'var(--color-secondary)' : '#fff',
    cursor: loading ? 'wait' : 'pointer',
    border: '1px solid rgba(255,255,255,0.15)',
    background: loading ? 'rgba(249,168,37,0.15)' : 'rgba(26,115,232,0.2)',
    transition: 'all 0.2s ease',
    whiteSpace: 'nowrap', minWidth: '0', flex: '0 0 auto',
  });

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'event'),
      'イベント記録'
    ),

    // 記録件数
    React.createElement(Card, { style: { marginBottom: 'var(--space-lg)', textAlign: 'center' } },
      React.createElement('div', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)' } }, 'イベント記録'),
      React.createElement('div', {
        style: { fontSize: 'var(--font-size-2xl)', fontWeight: 700, color: 'var(--color-primary-light)', margin: '8px 0' },
      }, `${entries.length} 件`),
      React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-xs)' } },
        entries.length > 0 ? `最新: ${entries[0].name} (${entries[0].date})` : 'まだ記録がありません'
      )
    ),

    // Gemini AIイベント検索
    geminiApiKey ? React.createElement(Card, {
      title: 'AIイベント検索（Gemini）',
      style: { marginBottom: 'var(--space-lg)' },
    },
      React.createElement('div', { style: { marginBottom: 'var(--space-md)' } },
        React.createElement('div', { style: { display: 'flex', gap: '8px', alignItems: 'stretch', marginBottom: '8px' } },
          React.createElement('input', {
            className: 'form-input',
            type: 'text',
            placeholder: '例: 今週末のイベント、コンサート情報...',
            value: geminiQuery,
            onChange: (e) => setGeminiQuery(e.target.value),
            onKeyDown: (e) => { if (e.key === 'Enter' && !geminiLoading) handleGeminiSearch(); },
            style: { flex: 1 },
          }),
          React.createElement(Button, {
            variant: 'primary',
            icon: geminiLoading ? 'sync' : 'search',
            onClick: handleGeminiSearch,
            disabled: geminiLoading || !geminiQuery.trim(),
            style: { whiteSpace: 'nowrap' },
          }, geminiLoading ? '検索中...' : 'AI検索')
        ),
        React.createElement('input', {
          className: 'form-input',
          type: 'text',
          placeholder: 'エリア（任意）: 渋谷、新宿、東京駅周辺...',
          value: geminiArea,
          onChange: (e) => setGeminiArea(e.target.value),
          style: { marginBottom: '8px' },
        }),
        React.createElement('div', {
          style: { display: 'flex', gap: '6px', flexWrap: 'wrap' },
        },
          quickEventQueries.map(q =>
            React.createElement('button', {
              key: q,
              onClick: () => { setGeminiQuery(q); },
              style: {
                padding: '4px 10px', borderRadius: '12px', fontSize: '11px',
                border: '1px solid rgba(255,255,255,0.12)', background: 'rgba(255,255,255,0.05)',
                color: 'var(--text-secondary)', cursor: 'pointer', transition: 'all 0.15s',
              },
              onMouseEnter: (e) => { e.currentTarget.style.background = 'rgba(249,168,37,0.15)'; e.currentTarget.style.color = 'var(--color-secondary)'; },
              onMouseLeave: (e) => { e.currentTarget.style.background = 'rgba(255,255,255,0.05)'; e.currentTarget.style.color = 'var(--text-secondary)'; },
            }, q)
          )
        )
      ),
      geminiError && React.createElement('div', {
        style: {
          padding: '10px 14px', borderRadius: '8px', marginBottom: 'var(--space-md)',
          background: 'rgba(229,57,53,0.1)', border: '1px solid rgba(229,57,53,0.3)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--color-danger)' } }, 'error'),
        React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-danger)' } }, geminiError)
      ),
      geminiLoading && React.createElement('div', {
        style: {
          padding: 'var(--space-lg)', textAlign: 'center',
          display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '32px', color: 'var(--color-secondary)', animation: 'spin 1s linear infinite' },
        }, 'sync'),
        React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)' } }, 'Gemini AIが検索中...')
      ),
      geminiResult && React.createElement('div', {
        style: {
          padding: 'var(--space-md)', borderRadius: '8px',
          background: 'rgba(249,168,37,0.06)', border: '1px solid rgba(249,168,37,0.15)',
        },
      },
        React.createElement('div', {
          style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '10px' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--color-secondary)' } }, 'smart_toy'),
          React.createElement('span', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)', color: 'var(--color-secondary)' } }, 'Gemini AI回答')
        ),
        React.createElement('div', {
          style: {
            fontSize: 'var(--font-size-sm)', color: 'var(--text-primary)',
            lineHeight: 1.8, whiteSpace: 'pre-wrap', wordBreak: 'break-word',
          },
        }, geminiResult),
        React.createElement('div', {
          style: { marginTop: '10px', fontSize: '10px', color: 'var(--text-muted)', display: 'flex', alignItems: 'center', gap: '4px' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px' } }, 'info'),
          '※ AIによる回答です。イベント情報は公式サイトで最終確認をお勧めします'
        )
      )
    ) : React.createElement(Card, { style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('div', {
        style: {
          textAlign: 'center', padding: 'var(--space-lg)',
          display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '10px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '36px', color: 'var(--color-secondary)', opacity: 0.5 },
        }, 'smart_toy'),
        React.createElement('div', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)' } }, 'AIイベント検索'),
        React.createElement('div', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-xs)', lineHeight: 1.6 } },
          'Gemini APIキーを設定すると、AIでイベント情報を検索できます'
        ),
        React.createElement(Button, {
          variant: 'secondary',
          icon: 'settings',
          onClick: () => document.dispatchEvent(new CustomEvent('navigate', { detail: 'settings' })),
          style: { fontSize: '12px' },
        }, '設定ページへ')
      )
    ),

    // 入力フォーム
    React.createElement(Card, { title: 'イベントを記録', style: { marginBottom: 'var(--space-lg)' } },
      // エラー表示
      errors.length > 0 && React.createElement('div', {
        style: {
          background: 'rgba(229,57,53,0.1)', border: '1px solid rgba(229,57,53,0.3)',
          borderRadius: '8px', padding: '8px 12px', marginBottom: 'var(--space-md)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: 'var(--color-danger)' },
        }, 'error'),
        React.createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-danger)' } },
          errors.join('、')
        )
      ),

      // 保存成功メッセージ
      saved && React.createElement('div', {
        style: {
          background: 'rgba(0,200,83,0.1)', border: '1px solid rgba(0,200,83,0.3)',
          borderRadius: '8px', padding: '8px 12px', marginBottom: 'var(--space-md)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: 'var(--color-accent)' },
        }, 'check_circle'),
        React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-accent)' } },
          'イベントを記録しました'
        )
      ),

      React.createElement('form', { onSubmit: handleSubmit },
        React.createElement('div', { className: 'grid grid--2' },

          // イベント名（必須）
          React.createElement('div', { className: 'form-group', style: { gridColumn: '1 / -1' } },
            React.createElement('label', { className: 'form-label' }, 'イベント名 *'),
            React.createElement('input', {
              className: 'form-input',
              type: 'text',
              placeholder: '例: 東京マラソン、花火大会、コンサート',
              value: form.name,
              onChange: (e) => setForm({ ...form, name: e.target.value }),
              required: true,
            })
          ),

          // 日付
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '日付',
              React.createElement('span', {
                style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: '400', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.1)' },
              }, '自動')
            ),
            React.createElement('input', {
              className: 'form-input',
              type: 'date',
              value: form.date,
              onChange: (e) => setForm({ ...form, date: e.target.value }),
              style: { colorScheme: 'dark' },
            }),
            form.date && (() => {
              const info = JapaneseHolidays.getDateInfo(form.date);
              const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-secondary)';
              return React.createElement('div', {
                style: { marginTop: '6px', display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' },
              },
                React.createElement('span', {
                  style: {
                    fontSize: '13px', fontWeight: '600', color: dayColor,
                    padding: '2px 10px', borderRadius: '4px',
                    background: info.isSunday || info.isHoliday ? 'rgba(239,68,68,0.12)' : info.isSaturday ? 'rgba(59,130,246,0.12)' : 'rgba(255,255,255,0.06)',
                  },
                }, `${info.dayOfWeek}曜日`),
                info.holiday && React.createElement('span', {
                  style: {
                    fontSize: '12px', fontWeight: '600', color: '#ef4444',
                    padding: '2px 10px', borderRadius: '4px',
                    background: 'rgba(239,68,68,0.12)',
                    display: 'flex', alignItems: 'center', gap: '4px',
                  },
                },
                  React.createElement('span', { style: { fontSize: '13px' } }, '\u{1F38C}'),
                  info.holiday
                )
              );
            })()
          ),

          // 時間帯
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '時間帯'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'center' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'time',
                value: form.startTime,
                onChange: (e) => setForm({ ...form, startTime: e.target.value }),
                style: { flex: 1, minWidth: 0, colorScheme: 'dark' },
                placeholder: '開始',
              }),
              React.createElement('span', { style: { color: 'var(--text-muted)', fontSize: '14px' } }, '\u301C'),
              React.createElement('input', {
                className: 'form-input',
                type: 'time',
                value: form.endTime,
                onChange: (e) => setForm({ ...form, endTime: e.target.value }),
                style: { flex: 1, minWidth: 0, colorScheme: 'dark' },
                placeholder: '終了',
              })
            )
          ),

          // 場所（GPS付き）
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '場所',
              gpsLoading && React.createElement('span', {
                style: { fontSize: '11px', color: 'var(--color-secondary)', fontWeight: '400', animation: 'pulse 1.5s ease-in-out infinite' },
              }, '取得中...')
            ),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'stretch' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'text',
                placeholder: '東京ドーム、渋谷駅前 等',
                value: form.location,
                onChange: (e) => { setForm({ ...form, location: e.target.value }); if (!e.target.value) setGpsInfo(null); },
                style: { flex: 1, minWidth: 0 },
              }),
              React.createElement('button', {
                type: 'button',
                onClick: getGpsLocation,
                disabled: gpsLoading,
                style: gpsButtonStyle(gpsLoading),
                title: 'GPSで現在地を取得',
              },
                React.createElement('span', {
                  className: 'material-icons-round',
                  style: { fontSize: '16px', animation: gpsLoading ? 'spin 1s linear infinite' : 'none' },
                }, gpsLoading ? 'sync' : 'my_location'),
                gpsLoading ? '取得中' : 'GPS'
              )
            ),
            gpsInfo && React.createElement('div', {
              style: {
                marginTop: '6px', padding: '6px 10px', borderRadius: '6px',
                background: 'rgba(26,115,232,0.08)', border: '1px solid rgba(26,115,232,0.15)',
                fontSize: '11px', color: 'var(--text-secondary)', lineHeight: '1.5',
              },
            },
              gpsInfo.address && React.createElement('div', { style: { display: 'flex', alignItems: 'flex-start', gap: '4px', marginBottom: '3px' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '13px', color: 'var(--color-primary-light)', marginTop: '1px', flexShrink: 0 } }, 'place'),
                React.createElement('span', { style: { fontWeight: '600', color: 'var(--color-primary-light)', wordBreak: 'break-all' } }, gpsInfo.address)
              ),
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '4px', color: 'var(--text-muted)', fontSize: '10px' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px', flexShrink: 0 } }, 'gps_fixed'),
                `${gpsInfo.lat.toFixed(6)}, ${gpsInfo.lng.toFixed(6)}`
              )
            )
          ),

          // 規模
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '規模'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              scaleOptions.map(s =>
                React.createElement('button', {
                  key: s.value,
                  type: 'button',
                  onClick: () => setForm({ ...form, scale: form.scale === s.value ? '' : s.value }),
                  style: {
                    display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px',
                    padding: '8px 14px', borderRadius: '8px',
                    fontSize: '13px', fontWeight: form.scale === s.value ? '700' : '400',
                    cursor: 'pointer',
                    border: form.scale === s.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.scale === s.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.scale === s.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', null, s.label),
                  React.createElement('span', { style: { fontSize: '9px', color: 'var(--text-muted)' } }, s.desc)
                )
              )
            )
          ),

          // 予想影響
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '予想影響'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              impactOptions.map(opt =>
                React.createElement('button', {
                  key: opt.value,
                  type: 'button',
                  onClick: () => setForm({ ...form, impact: form.impact === opt.value ? '' : opt.value }),
                  style: {
                    display: 'flex', alignItems: 'center', gap: '6px',
                    padding: '8px 14px', borderRadius: '8px',
                    fontSize: '13px', fontWeight: form.impact === opt.value ? '700' : '400',
                    cursor: 'pointer',
                    border: form.impact === opt.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.impact === opt.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.impact === opt.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: opt.color } }, opt.icon),
                  opt.value
                )
              )
            )
          ),

          // メモ
          React.createElement('div', { className: 'form-group', style: { gridColumn: '1 / -1' } },
            React.createElement('label', { className: 'form-label' }, 'メモ'),
            React.createElement('input', {
              className: 'form-input',
              type: 'text',
              placeholder: '任意のメモ（集客予想、注意点など）',
              value: form.memo,
              onChange: (e) => setForm({ ...form, memo: e.target.value }),
            })
          )
        ),
        React.createElement(Button, {
          variant: 'primary',
          icon: 'add',
          style: { marginTop: 'var(--space-sm)' },
        }, 'イベントを記録')
      )
    ),

    // データ管理ツールバー
    entries.length > 0 && React.createElement(Card, { style: { marginBottom: 'var(--space-md)' } },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '10px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--color-primary-light)' } }, 'folder'),
        React.createElement('span', { style: { fontSize: '13px', fontWeight: '600', color: 'var(--text-primary)' } }, 'データ管理'),
        React.createElement('span', { style: { fontSize: '11px', color: 'var(--text-muted)', marginLeft: 'auto' } },
          `全 ${entries.length} 件の記録`
        )
      ),
      React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
        React.createElement(Button, {
          variant: 'danger',
          icon: 'delete_forever',
          onClick: () => { if (confirm('全てのイベント記録を削除しますか？この操作は取り消せません。')) handleClearAll(); },
          style: { padding: '6px 12px', fontSize: '11px' },
        }, '全削除')
      )
    ),

    // 記録一覧
    entries.length > 0 && React.createElement(Card, { title: `記録一覧（${entries.length}件）` },
      entries.map(entry =>
        React.createElement('div', {
          key: entry.id,
          style: {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'flex-start',
            padding: '12px 0',
            borderBottom: '1px solid rgba(255,255,255,0.06)',
          },
        },
          React.createElement('div', { style: { flex: 1 } },
            React.createElement('div', { style: { fontWeight: 600, display: 'flex', alignItems: 'center', gap: '6px', flexWrap: 'wrap' } },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: 'var(--color-secondary)' } }, 'event'),
              React.createElement('span', null, entry.name)
            ),
            React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', display: 'flex', flexWrap: 'wrap', alignItems: 'center', gap: '4px', marginTop: '4px' } },
              (() => {
                const info = entry.dayOfWeek ? { dayOfWeek: entry.dayOfWeek, holiday: entry.holiday, isSunday: entry.dayOfWeek === '日', isSaturday: entry.dayOfWeek === '土', isHoliday: !!entry.holiday } : JapaneseHolidays.getDateInfo(entry.date);
                const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-muted)';
                return React.createElement(React.Fragment, null,
                  React.createElement('span', null, entry.date),
                  React.createElement('span', { style: { color: dayColor, fontWeight: '600' } }, `(${info.dayOfWeek})`),
                  info.holiday && React.createElement('span', {
                    style: { color: '#ef4444', fontSize: '10px', padding: '1px 6px', borderRadius: '3px', background: 'rgba(239,68,68,0.1)' },
                  }, info.holiday),
                  (entry.startTime || entry.endTime) && React.createElement('span', {
                    style: { fontSize: '11px', color: 'var(--color-primary-light)', fontWeight: '600', padding: '1px 6px', borderRadius: '3px', background: 'rgba(26,115,232,0.12)' },
                  }, `${entry.startTime || '?'}\u301C${entry.endTime || '?'}`),
                  entry.location && React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '2px' } },
                    React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px' } }, 'place'),
                    entry.location
                  )
                );
              })()
            ),
            (entry.scale || entry.impact) && React.createElement('div', {
              style: { fontSize: '11px', color: 'var(--text-secondary)', marginTop: '4px', display: 'flex', gap: '6px', flexWrap: 'wrap' },
            },
              entry.scale && React.createElement('span', {
                style: { padding: '1px 8px', borderRadius: '3px', background: 'rgba(249,168,37,0.12)', color: 'var(--color-secondary)', fontWeight: '600' },
              }, `規模: ${entry.scale}`),
              entry.impact && React.createElement('span', {
                style: {
                  padding: '1px 8px', borderRadius: '3px', fontWeight: '600',
                  background: entry.impact === '需要増' ? 'rgba(0,200,83,0.12)' : entry.impact === '需要減' ? 'rgba(229,57,53,0.12)' : 'rgba(255,255,255,0.06)',
                  color: entry.impact === '需要増' ? 'var(--color-accent)' : entry.impact === '需要減' ? 'var(--color-danger)' : 'var(--text-muted)',
                },
              }, `影響: ${entry.impact}`)
            ),
            entry.memo && React.createElement('div', {
              style: { fontSize: '11px', color: 'var(--text-muted)', marginTop: '2px' },
            }, `${entry.memo}`)
          ),
          React.createElement('button', {
            onClick: () => handleDelete(entry.id),
            style: {
              background: 'none', border: 'none', cursor: 'pointer',
              color: 'var(--text-muted)', padding: '4px',
              borderRadius: '4px', transition: 'color 0.2s',
              marginTop: '4px',
            },
            title: '削除',
          },
            React.createElement('span', {
              className: 'material-icons-round',
              style: { fontSize: '18px' },
            }, 'delete_outline')
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/Analytics.jsx
// ============================================================
(function() {
// Analytics.jsx - 売上分析ページ（DataServiceによるリアルデータ分析）
// v0.3.1: useMemoの依存配列修正 — データ追加後に分析結果が更新されるようにrefreshKeyを導入
window.AnalyticsPage = () => {
  const { useState, useEffect, useMemo } = React;
  const [tab, setTab] = useState('daily');
  const [refreshKey, setRefreshKey] = useState(0);

  // localStorageの変更を監視して自動更新（Dashboardと同じパターン）
  useEffect(() => {
    const handleStorage = (e) => {
      if (e.key === APP_CONSTANTS.STORAGE_KEYS.REVENUE_DATA || e.key === APP_CONSTANTS.STORAGE_KEYS.RIVAL_RIDES) {
        setRefreshKey(k => k + 1);
      }
    };
    window.addEventListener('storage', handleStorage);

    // 画面に戻った時も更新
    const handleVisibility = () => {
      if (!document.hidden) setRefreshKey(k => k + 1);
    };
    document.addEventListener('visibilitychange', handleVisibility);

    return () => {
      window.removeEventListener('storage', handleStorage);
      document.removeEventListener('visibilitychange', handleVisibility);
    };
  }, []);

  const daily = useMemo(() => DataService.getDailyBreakdown(30), [refreshKey]);
  const dayOfWeek = useMemo(() => DataService.getDayOfWeekBreakdown(), [refreshKey]);
  const hourly = useMemo(() => DataService.getHourlyBreakdown(), [refreshKey]);
  const areas = useMemo(() => DataService.getAreaBreakdown(), [refreshKey]);
  const overall = useMemo(() => DataService.getOverallSummary(), [refreshKey]);
  const monthly = useMemo(() => DataService.getMonthlyBreakdown(), [refreshKey]);

  const weather = useMemo(() => DataService.getWeatherBreakdown(), [refreshKey]);
  const rivalHourly = useMemo(() => DataService.getRivalHourlyBreakdown(), [refreshKey]);
  const rivalDow = useMemo(() => DataService.getRivalDayOfWeekBreakdown(), [refreshKey]);
  const rivalLocs = useMemo(() => DataService.getRivalLocationBreakdown(), [refreshKey]);
  const rivalWeather = useMemo(() => DataService.getRivalWeatherBreakdown(), [refreshKey]);
  const rivalTotal = useMemo(() => DataService.getRivalEntries().length, [refreshKey]);

  const sourceData = useMemo(() => DataService.getSourceBreakdown(), [refreshKey]);
  const purposeData = useMemo(() => DataService.getPurposeBreakdown(), [refreshKey]);
  const areaTime = useMemo(() => DataService.getAreaTimeBreakdown(), [refreshKey]);
  const unitPrice = useMemo(() => DataService.getUnitPriceAnalysis(), [refreshKey]);
  const recommendation = useMemo(() => DataService.getBusinessRecommendation(), [refreshKey]);
  const sourceAreaPrice = useMemo(() => DataService.getSourceAreaPriceBreakdown(), [refreshKey]);

  const hasData = overall.rideCount > 0;

  // バーチャートコンポーネント（CSS純正）
  const BarChart = ({ data, valueKey, labelKey, color, maxBars = 30, height = 200, prefix = '¥' }) => {
    const maxVal = Math.max(...data.map(d => d[valueKey]), 1);
    const barData = data.slice(-maxBars);

    return React.createElement('div', {
      style: { display: 'flex', alignItems: 'flex-end', gap: '2px', height: `${height}px`, padding: '0 4px' },
    },
      barData.map((d, i) => {
        const pct = (d[valueKey] / maxVal) * 100;
        return React.createElement('div', {
          key: i,
          style: { flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', height: '100%', justifyContent: 'flex-end' },
          title: `${d[labelKey]}: ${prefix}${d[valueKey].toLocaleString()}`,
        },
          React.createElement('div', {
            style: {
              width: '100%', minHeight: '2px',
              height: `${Math.max(pct, 1)}%`,
              background: d[valueKey] === 0 ? 'rgba(255,255,255,0.05)' : color,
              borderRadius: '3px 3px 0 0',
              transition: 'height 0.3s ease',
            },
          })
        );
      })
    );
  };

  // 横棒グラフ
  const HBarChart = ({ data, nameKey, valueKey, color, prefix = '¥' }) => {
    const maxVal = Math.max(...data.map(d => d[valueKey]), 1);
    return React.createElement('div', { style: { display: 'grid', gap: '6px' } },
      data.map((d, i) => {
        const pct = (d[valueKey] / maxVal) * 100;
        return React.createElement('div', { key: i },
          React.createElement('div', {
            style: { display: 'flex', justifyContent: 'space-between', fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)', marginBottom: '2px' },
          },
            React.createElement('span', null, d[nameKey]),
            React.createElement('span', { style: { fontWeight: 500, color: 'var(--text-primary)' } }, `${prefix}${d[valueKey].toLocaleString()}`)
          ),
          React.createElement('div', {
            style: { background: 'rgba(255,255,255,0.06)', borderRadius: '4px', height: '8px', overflow: 'hidden' },
          },
            React.createElement('div', {
              style: { width: `${pct}%`, height: '100%', background: color, borderRadius: '4px', transition: 'width 0.3s ease' },
            })
          )
        );
      })
    );
  };

  // データなし画面
  if (!hasData) {
    return React.createElement('div', null,
      React.createElement('h1', { className: 'page-title' },
        React.createElement('span', { className: 'material-icons-round' }, 'analytics'),
        '売上分析'
      ),
      React.createElement(Card, { style: { textAlign: 'center', padding: 'var(--space-2xl)' } },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '64px', color: 'var(--text-muted)', marginBottom: '16px' },
        }, 'bar_chart'),
        React.createElement('h3', { style: { marginBottom: '8px' } }, 'まだデータがありません'),
        React.createElement('p', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)' } },
          '売上記録ページからデータを追加すると、ここに分析結果が表示されます。'
        )
      )
    );
  }

  const tabs = [
    { id: 'daily', label: '日別', icon: 'calendar_today' },
    { id: 'dayOfWeek', label: '曜日別', icon: 'date_range' },
    { id: 'hourly', label: '時間帯別', icon: 'schedule' },
    { id: 'area', label: 'エリア別', icon: 'place' },
    { id: 'weather', label: '天候別', icon: 'cloud' },
    { id: 'rival', label: '他社分析', icon: 'local_taxi' },
    { id: 'forecast', label: '業務予測', icon: 'tips_and_updates' },
  ];

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'analytics'),
      '売上分析'
    ),

    // サマリーカード
    React.createElement('div', { className: 'grid grid--4', style: { marginBottom: 'var(--space-lg)' } },
      [
        { label: '累計売上（税込）', value: `¥${overall.totalAmount.toLocaleString()}`, sub: `税抜¥${Math.floor(overall.totalAmount / 1.1).toLocaleString()} 税¥${(overall.totalAmount - Math.floor(overall.totalAmount / 1.1)).toLocaleString()}`, icon: 'payments', color: 'var(--color-secondary)' },
        { label: '累計乗車', value: `${overall.rideCount}回`, icon: 'people', color: 'var(--color-primary-light)' },
        { label: '平均単価（税込）', value: `¥${overall.avgAmount.toLocaleString()}`, sub: `税抜¥${Math.floor(overall.avgAmount / 1.1).toLocaleString()} 税¥${(overall.avgAmount - Math.floor(overall.avgAmount / 1.1)).toLocaleString()}`, icon: 'price_check', color: 'var(--color-accent)' },
        { label: '日平均（税込）', value: `¥${overall.dailyAvg.toLocaleString()}`, sub: `税抜¥${Math.floor(overall.dailyAvg / 1.1).toLocaleString()} 税¥${(overall.dailyAvg - Math.floor(overall.dailyAvg / 1.1)).toLocaleString()}`, icon: 'trending_up', color: 'var(--color-warning)' },
      ].map((s, i) =>
        React.createElement(Card, { key: i, className: 'stat-card' },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '28px', color: s.color, marginBottom: '4px' },
          }, s.icon),
          React.createElement('div', { className: 'stat-card__value', style: { fontSize: 'var(--font-size-xl)' } }, s.value),
          s.sub && React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)', marginTop: '2px' } }, s.sub),
          React.createElement('div', { className: 'stat-card__label' }, s.label)
        )
      )
    ),

    // 当月合計
    (() => {
      const now = new Date();
      const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
      const cm = monthly.find(m => m.month === currentMonth);
      const amt = cm ? cm.amount : 0;
      const cnt = cm ? cm.count : 0;
      const taxExcl = Math.floor(amt / 1.1);
      const tax = amt - taxExcl;
      return React.createElement('div', {
        style: { background: 'linear-gradient(135deg, rgba(26,115,232,0.15), rgba(255,167,38,0.10))', border: '1px solid rgba(26,115,232,0.3)', borderRadius: '12px', padding: '16px 20px', marginBottom: 'var(--space-lg)', display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexWrap: 'wrap', gap: '12px' },
      },
        React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '10px' } },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '24px', color: 'var(--color-primary-light)' } }, 'calendar_month'),
          React.createElement('div', null,
            React.createElement('div', { style: { fontSize: '12px', color: 'var(--text-secondary)' } }, `${now.getFullYear()}年${now.getMonth() + 1}月の売上合計`),
            React.createElement('div', { style: { fontSize: '11px', color: 'var(--text-muted)', marginTop: '2px' } }, `${cnt}回乗車`)
          )
        ),
        React.createElement('div', { style: { textAlign: 'right' } },
          React.createElement('div', { style: { fontSize: '24px', fontWeight: 800, color: 'var(--color-secondary)' } }, `¥${amt.toLocaleString()}`),
          React.createElement('div', { style: { fontSize: '11px', color: 'var(--text-muted)', marginTop: '2px' } }, `税抜¥${taxExcl.toLocaleString()}　税¥${tax.toLocaleString()}`)
        )
      );
    })(),

    // タブ切り替え
    React.createElement('div', {
      style: { display: 'flex', gap: '4px', marginBottom: 'var(--space-lg)', flexWrap: 'wrap' },
    },
      tabs.map(t =>
        React.createElement('button', {
          key: t.id,
          onClick: () => setTab(t.id),
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 16px', border: 'none', borderRadius: '20px', cursor: 'pointer',
            fontSize: 'var(--font-size-sm)', fontFamily: 'var(--font-family)',
            background: tab === t.id ? 'rgba(26,115,232,0.2)' : 'rgba(255,255,255,0.04)',
            color: tab === t.id ? 'var(--color-primary-light)' : 'var(--text-secondary)',
            transition: 'all 0.2s ease',
          },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, t.icon),
          t.label
        )
      )
    ),

    // 日別タブ
    tab === 'daily' && React.createElement(React.Fragment, null,
      React.createElement(Card, { title: '過去30日間の売上推移', style: { marginBottom: 'var(--space-lg)' } },
        React.createElement(BarChart, { data: daily, valueKey: 'amount', labelKey: 'date', color: 'var(--color-primary-light)', height: 180 }),
        React.createElement('div', {
          style: { display: 'flex', justifyContent: 'space-between', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '8px', padding: '0 4px' },
        },
          React.createElement('span', null, daily.length > 0 ? daily[0].date.slice(5) : ''),
          React.createElement('span', null, '今日')
        )
      ),
      monthly.length > 0 && React.createElement(Card, { title: '月別集計', style: { marginBottom: 'var(--space-lg)' } },
        monthly.map((m, i) =>
          React.createElement('div', {
            key: i,
            style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '10px 0', borderBottom: '1px solid rgba(255,255,255,0.06)' },
          },
            React.createElement('span', { style: { fontWeight: 500 } }, m.month),
            React.createElement('div', { style: { textAlign: 'right' } },
              React.createElement('div', { style: { display: 'flex', gap: '16px', alignItems: 'center', justifyContent: 'flex-end' } },
                React.createElement('span', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)' } }, `${m.count}回`),
                React.createElement('span', { style: { fontWeight: 700, color: 'var(--color-secondary)' } }, `¥${m.amount.toLocaleString()}`)
              ),
              React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(m.amount / 1.1).toLocaleString()} 税¥${(m.amount - Math.floor(m.amount / 1.1)).toLocaleString()}`)
            )
          )
        )
      )
    ),

    // 曜日別タブ
    tab === 'dayOfWeek' && React.createElement(React.Fragment, null,
      React.createElement(Card, { title: '曜日別売上合計', style: { marginBottom: 'var(--space-lg)' } },
        React.createElement(BarChart, { data: dayOfWeek, valueKey: 'amount', labelKey: 'name', color: 'var(--color-accent)', height: 160 }),
        React.createElement('div', {
          style: { display: 'flex', justifyContent: 'space-around', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '6px' },
        }, dayOfWeek.map(d => React.createElement('span', { key: d.name }, d.name)))
      ),
      React.createElement(Card, { title: '曜日別詳細' },
        dayOfWeek.map((d, i) =>
          React.createElement('div', {
            key: i,
            style: { display: 'grid', gridTemplateColumns: '40px 1fr 80px 80px', gap: '8px', alignItems: 'center', padding: '8px 0', borderBottom: '1px solid rgba(255,255,255,0.06)' },
          },
            React.createElement('span', {
              style: { fontWeight: 700, color: (d.index === 0 || d.index === 6) ? 'var(--color-danger)' : 'var(--text-primary)' },
            }, d.name),
            React.createElement('div', {
              style: { background: 'rgba(255,255,255,0.06)', borderRadius: '4px', height: '6px', overflow: 'hidden' },
            },
              React.createElement('div', {
                style: { width: `${d.count > 0 ? (d.amount / Math.max(...dayOfWeek.map(x => x.amount), 1)) * 100 : 0}%`, height: '100%', background: 'var(--color-accent)', borderRadius: '4px' },
              })
            ),
            React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', textAlign: 'right' } }, `${d.count}回`),
            React.createElement('div', { style: { textAlign: 'right' } },
              React.createElement('div', { style: { fontSize: 'var(--font-size-sm)', fontWeight: 500 } }, `¥${d.amount.toLocaleString()}`),
              React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(d.amount / 1.1).toLocaleString()} 税¥${(d.amount - Math.floor(d.amount / 1.1)).toLocaleString()}`)
            )
          )
        )
      )
    ),

    // 時間帯別タブ
    tab === 'hourly' && React.createElement(React.Fragment, null,
      React.createElement(Card, { title: '時間帯別売上', subtitle: '各時間帯の合計売上額', style: { marginBottom: 'var(--space-lg)' } },
        React.createElement(BarChart, { data: hourly, valueKey: 'amount', labelKey: 'label', color: 'var(--color-warning)', height: 160, maxBars: 24 }),
        React.createElement('div', {
          style: { display: 'flex', justifyContent: 'space-between', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '6px', padding: '0 4px' },
        },
          React.createElement('span', null, '0時'),
          React.createElement('span', null, '6時'),
          React.createElement('span', null, '12時'),
          React.createElement('span', null, '18時'),
          React.createElement('span', null, '23時')
        )
      ),
      React.createElement(Card, { title: '売上上位の時間帯' },
        (() => {
          const sorted = [...hourly].filter(h => h.count > 0).sort((a, b) => b.amount - a.amount).slice(0, 5);
          return sorted.length > 0
            ? React.createElement(HBarChart, { data: sorted, nameKey: 'label', valueKey: 'amount', color: 'var(--color-warning)' })
            : React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-sm)' } }, 'データなし');
        })()
      )
    ),

    // エリア別タブ
    tab === 'area' && React.createElement('div', { className: 'grid grid--2', style: { gap: 'var(--space-lg)' } },
      // 乗車地
      React.createElement(Card, { title: '乗車地ランキング', subtitle: `上位 ${Math.min(areas.pickups.length, 10)} 件` },
        areas.pickups.length === 0
          ? React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-sm)' } }, '乗車地データなし')
          : areas.pickups.map((p, i) =>
              React.createElement('div', {
                key: i,
                style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '8px 0', borderBottom: '1px solid rgba(255,255,255,0.06)' },
              },
                React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
                  React.createElement('span', {
                    style: {
                      width: '24px', height: '24px', borderRadius: '50%',
                      background: i < 3 ? 'var(--color-secondary)' : 'rgba(255,255,255,0.1)',
                      color: i < 3 ? 'var(--text-dark)' : 'var(--text-secondary)',
                      display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: 'var(--font-size-xs)', fontWeight: 700,
                    },
                  }, `${i + 1}`),
                  React.createElement('span', { style: { fontSize: 'var(--font-size-sm)' } }, p.name)
                ),
                React.createElement('div', { style: { textAlign: 'right' } },
                  React.createElement('div', { style: { fontSize: 'var(--font-size-sm)', fontWeight: 500 } }, `${p.count}回`),
                  React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--color-secondary)' } }, `¥${p.amount.toLocaleString()}`),
                  React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(p.amount / 1.1).toLocaleString()} 税¥${(p.amount - Math.floor(p.amount / 1.1)).toLocaleString()}`)
                )
              )
            )
      ),
      // 降車地
      React.createElement(Card, { title: '降車地ランキング', subtitle: `上位 ${Math.min(areas.dropoffs.length, 10)} 件` },
        areas.dropoffs.length === 0
          ? React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-sm)' } }, '降車地データなし')
          : areas.dropoffs.map((p, i) =>
              React.createElement('div', {
                key: i,
                style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '8px 0', borderBottom: '1px solid rgba(255,255,255,0.06)' },
              },
                React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
                  React.createElement('span', {
                    style: {
                      width: '24px', height: '24px', borderRadius: '50%',
                      background: i < 3 ? 'var(--color-accent)' : 'rgba(255,255,255,0.1)',
                      color: i < 3 ? '#fff' : 'var(--text-secondary)',
                      display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: 'var(--font-size-xs)', fontWeight: 700,
                    },
                  }, `${i + 1}`),
                  React.createElement('span', { style: { fontSize: 'var(--font-size-sm)' } }, p.name)
                ),
                React.createElement('div', { style: { textAlign: 'right' } },
                  React.createElement('div', { style: { fontSize: 'var(--font-size-sm)', fontWeight: 500 } }, `${p.count}回`),
                  React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--color-accent)' } }, `¥${p.amount.toLocaleString()}`),
                  React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(p.amount / 1.1).toLocaleString()} 税¥${(p.amount - Math.floor(p.amount / 1.1)).toLocaleString()}`)
                )
              )
            )
      )
    ),

    // 天候別タブ
    tab === 'weather' && React.createElement(React.Fragment, null,
      React.createElement(Card, { title: '天候別 平均売上', style: { marginBottom: 'var(--space-lg)' } },
        (() => {
          const withData = weather.filter(w => w.count > 0);
          return withData.length > 0
            ? React.createElement(BarChart, { data: withData, valueKey: 'avg', labelKey: 'name', color: 'var(--color-primary-light)', height: 160 })
            : React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-sm)' } }, 'データなし');
        })(),
        React.createElement('div', {
          style: { display: 'flex', justifyContent: 'space-around', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '6px' },
        }, weather.filter(w => w.count > 0).map(w => React.createElement('span', { key: w.name, style: { display: 'flex', alignItems: 'center', gap: '2px' } },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } },
            w.name === '晴れ' ? 'wb_sunny' : w.name === '曇り' ? 'cloud' : w.name === '雨' ? 'water_drop' : w.name === '雪' ? 'ac_unit' : 'help_outline'
          ), w.name
        )))
      ),
      React.createElement(Card, { title: '天候別 合計売上', style: { marginBottom: 'var(--space-lg)' } },
        (() => {
          const withData = weather.filter(w => w.count > 0);
          return withData.length > 0
            ? React.createElement(HBarChart, { data: withData, nameKey: 'name', valueKey: 'amount', color: 'var(--color-primary-light)' })
            : React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-sm)' } }, 'データなし');
        })()
      ),
      React.createElement(Card, { title: '天候別 詳細' },
        weather.map((w, i) =>
          React.createElement('div', {
            key: i,
            style: { display: 'grid', gridTemplateColumns: '80px 1fr 60px 80px 80px', gap: '8px', alignItems: 'center', padding: '8px 0', borderBottom: '1px solid rgba(255,255,255,0.06)' },
          },
            React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '4px', fontWeight: 500 } },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } },
                w.name === '晴れ' ? 'wb_sunny' : w.name === '曇り' ? 'cloud' : w.name === '雨' ? 'water_drop' : w.name === '雪' ? 'ac_unit' : 'help_outline'
              ), w.name
            ),
            React.createElement('div', {
              style: { background: 'rgba(255,255,255,0.06)', borderRadius: '4px', height: '6px', overflow: 'hidden' },
            },
              React.createElement('div', {
                style: { width: `${w.count > 0 ? (w.amount / Math.max(...weather.map(x => x.amount), 1)) * 100 : 0}%`, height: '100%', background: 'var(--color-primary-light)', borderRadius: '4px' },
              })
            ),
            React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', textAlign: 'right' } }, `${w.count}回`),
            React.createElement('div', { style: { textAlign: 'right' } },
              React.createElement('div', { style: { fontSize: 'var(--font-size-sm)' } }, `¥${w.avg.toLocaleString()}`),
              React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(w.avg / 1.1).toLocaleString()}`)
            ),
            React.createElement('div', { style: { textAlign: 'right' } },
              React.createElement('div', { style: { fontSize: 'var(--font-size-sm)', fontWeight: 500, color: 'var(--color-secondary)' } }, `¥${w.amount.toLocaleString()}`),
              React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(w.amount / 1.1).toLocaleString()} 税¥${(w.amount - Math.floor(w.amount / 1.1)).toLocaleString()}`)
            )
          )
        )
      )
    ),

    // 他社分析タブ
    tab === 'rival' && React.createElement(React.Fragment, null,
      // サマリー
      React.createElement(Card, {
        style: { marginBottom: 'var(--space-lg)', textAlign: 'center', padding: 'var(--space-lg)' },
      },
        React.createElement('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', marginBottom: '4px' } },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '28px', color: 'var(--color-warning)' } }, 'local_taxi'),
          React.createElement('span', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } }, '他社乗車記録数')
        ),
        React.createElement('div', { style: { fontSize: '2rem', fontWeight: 700 } }, `${rivalTotal}件`)
      ),

      rivalTotal === 0 && React.createElement(Card, { style: { textAlign: 'center', padding: 'var(--space-2xl)' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '48px', color: 'var(--text-muted)', marginBottom: '12px' } }, 'info'),
        React.createElement('p', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)' } }, '他社乗車データを記録すると、ここに分析結果が表示されます。')
      ),

      // 時間帯別
      rivalTotal > 0 && React.createElement(Card, { title: '時間帯別 他社乗車件数', style: { marginBottom: 'var(--space-lg)' } },
        React.createElement(BarChart, { data: rivalHourly, valueKey: 'count', labelKey: 'label', color: 'var(--color-warning)', height: 140, maxBars: 24, prefix: '' }),
        React.createElement('div', {
          style: { display: 'flex', justifyContent: 'space-between', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '6px', padding: '0 4px' },
        },
          React.createElement('span', null, '0時'),
          React.createElement('span', null, '6時'),
          React.createElement('span', null, '12時'),
          React.createElement('span', null, '18時'),
          React.createElement('span', null, '23時')
        )
      ),

      // 曜日別
      rivalTotal > 0 && React.createElement(Card, { title: '曜日別 他社乗車件数', style: { marginBottom: 'var(--space-lg)' } },
        React.createElement(BarChart, { data: rivalDow, valueKey: 'count', labelKey: 'name', color: 'var(--color-accent)', height: 140, prefix: '' }),
        React.createElement('div', {
          style: { display: 'flex', justifyContent: 'space-around', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '6px' },
        }, rivalDow.map(d => React.createElement('span', { key: d.name }, d.name)))
      ),

      // 場所ランキング
      rivalTotal > 0 && rivalLocs.length > 0 && React.createElement(Card, { title: '乗車場所ランキング TOP10', style: { marginBottom: 'var(--space-lg)' } },
        React.createElement(HBarChart, { data: rivalLocs, nameKey: 'name', valueKey: 'count', color: 'var(--color-warning)', prefix: '' })
      ),

      // 天候別
      rivalTotal > 0 && React.createElement(Card, { title: '天候別 他社乗車件数' },
        React.createElement(HBarChart, { data: rivalWeather.filter(w => w.count > 0), nameKey: 'name', valueKey: 'count', color: 'var(--color-primary-light)', prefix: '' })
      )
    ),

    // 業務予測タブ
    tab === 'forecast' && React.createElement(React.Fragment, null,

      // A. 今日のおすすめカード
      React.createElement(Card, {
        style: { marginBottom: 'var(--space-lg)', padding: 'var(--space-lg)' },
      },
        React.createElement('div', {
          style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: 'var(--space-md)' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '28px', color: 'var(--color-accent)' } }, 'tips_and_updates'),
          React.createElement('h3', { style: { margin: 0 } }, '今日のおすすめ')
        ),
        React.createElement('div', {
          style: { display: 'flex', gap: '12px', flexWrap: 'wrap', marginBottom: 'var(--space-md)', fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)' },
        },
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '4px' } },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'calendar_today'),
            recommendation.currentCondition.dayOfWeek + '曜日'
          ),
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '4px' } },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'schedule'),
            recommendation.currentCondition.hour + '時台'
          )
        ),

        // 推定客単価
        React.createElement('div', {
          style: {
            textAlign: 'center', padding: 'var(--space-lg)', marginBottom: 'var(--space-md)',
            background: 'rgba(0,200,83,0.08)', borderRadius: '12px', border: '1px solid rgba(0,200,83,0.2)',
          },
        },
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)', marginBottom: '4px' } }, '推定客単価'),
          React.createElement('div', { style: { fontSize: '2rem', fontWeight: 700, color: 'var(--color-accent)' } },
            recommendation.estimatedUnitPrice > 0 ? '¥' + recommendation.estimatedUnitPrice.toLocaleString() : 'データ不足'
          ),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '4px' } },
            recommendation.currentCondition.dayOfWeek + '曜 ' + recommendation.currentCondition.hour + '時台の平均'
          )
        ),

        // TOP3エリア & 時間帯を横並び
        React.createElement('div', {
          style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 'var(--space-md)' },
        },
          // 売上が高いエリアTOP3
          React.createElement('div', null,
            React.createElement('div', {
              style: { fontSize: 'var(--font-size-sm)', fontWeight: 600, marginBottom: '8px', display: 'flex', alignItems: 'center', gap: '4px' },
            },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: 'var(--color-primary-light)' } }, 'place'),
              '売上が高いエリア'
            ),
            recommendation.topAreas.length > 0
              ? recommendation.topAreas.map((a, i) =>
                  React.createElement('div', {
                    key: i,
                    style: { display: 'flex', justifyContent: 'space-between', padding: '6px 0', borderBottom: '1px solid rgba(255,255,255,0.06)', fontSize: 'var(--font-size-sm)' },
                  },
                    React.createElement('span', null, (i + 1) + '. ' + a.name),
                    React.createElement('span', { style: { fontWeight: 500, color: 'var(--color-secondary)' } }, '¥' + a.amount.toLocaleString())
                  )
                )
              : React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, 'この時間帯のデータなし')
          ),

          // 単価が高い時間帯TOP3
          React.createElement('div', null,
            React.createElement('div', {
              style: { fontSize: 'var(--font-size-sm)', fontWeight: 600, marginBottom: '8px', display: 'flex', alignItems: 'center', gap: '4px' },
            },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: 'var(--color-warning)' } }, 'schedule'),
              '単価が高い時間帯'
            ),
            recommendation.topHours.length > 0
              ? recommendation.topHours.map((h, i) =>
                  React.createElement('div', {
                    key: i,
                    style: { display: 'flex', justifyContent: 'space-between', padding: '6px 0', borderBottom: '1px solid rgba(255,255,255,0.06)', fontSize: 'var(--font-size-sm)' },
                  },
                    React.createElement('span', null, (i + 1) + '. ' + h.name),
                    React.createElement('span', { style: { fontWeight: 500, color: 'var(--color-secondary)' } }, '¥' + h.avg.toLocaleString())
                  )
                )
              : React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, 'この曜日のデータなし')
          )
        )
      ),

      // B. エリア×時間帯クロス分析
      areaTime.length > 0 && React.createElement(Card, { title: 'エリア×時間帯クロス分析', style: { marginBottom: 'var(--space-lg)' } },
        React.createElement('div', { style: { overflowX: 'auto' } },
          React.createElement('div', {
            style: {
              display: 'grid',
              gridTemplateColumns: '120px repeat(6, 1fr)',
              gap: '2px',
              fontSize: 'var(--font-size-xs)',
              minWidth: '500px',
            },
          },
            // ヘッダー行
            React.createElement('div', { style: { padding: '6px 4px', fontWeight: 600, color: 'var(--text-secondary)' } }, 'エリア'),
            ...['0-3', '4-7', '8-11', '12-15', '16-19', '20-23'].map(label =>
              React.createElement('div', { key: label, style: { padding: '6px 4px', textAlign: 'center', fontWeight: 600, color: 'var(--text-secondary)' } }, label + '時')
            ),

            // データ行（上位5エリア）
            ...areaTime.slice(0, 5).flatMap((a) => {
              const timeSlots = [
                { start: 0, end: 3 }, { start: 4, end: 7 }, { start: 8, end: 11 },
                { start: 12, end: 15 }, { start: 16, end: 19 }, { start: 20, end: 23 },
              ];
              const slotData = timeSlots.map(slot => {
                let count = 0, amount = 0;
                for (let h = slot.start; h <= slot.end; h++) {
                  count += a.hours[h].count;
                  amount += a.hours[h].amount;
                }
                return { count, amount };
              });
              const maxCount = Math.max(...slotData.map(s => s.count), 1);

              return [
                React.createElement('div', {
                  key: a.area + '-label',
                  style: { padding: '8px 4px', fontWeight: 500, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', borderBottom: '1px solid rgba(255,255,255,0.06)' },
                  title: a.area,
                }, a.area.length > 10 ? a.area.slice(0, 10) + '…' : a.area),
                ...slotData.map((s, si) => {
                  const intensity = s.count > 0 ? Math.max(0.1, s.count / maxCount) : 0;
                  return React.createElement('div', {
                    key: a.area + '-' + si,
                    style: {
                      padding: '8px 4px', textAlign: 'center', borderRadius: '4px',
                      background: intensity > 0 ? 'rgba(26,115,232,' + (intensity * 0.5) + ')' : 'transparent',
                      borderBottom: '1px solid rgba(255,255,255,0.06)',
                      color: intensity > 0.5 ? '#fff' : 'var(--text-secondary)',
                    },
                    title: a.area + ' ' + ['0-3', '4-7', '8-11', '12-15', '16-19', '20-23'][si] + '時: ' + s.count + '件 ¥' + s.amount.toLocaleString(),
                  }, s.count > 0 ? s.count + '件' : '-');
                })
              ];
            })
          )
        ),
        React.createElement('div', {
          style: { marginTop: '8px', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', display: 'flex', alignItems: 'center', gap: '8px' },
        },
          React.createElement('span', null, '色の濃さ = 件数の多さ'),
          React.createElement('span', null, '|'),
          React.createElement('span', null, 'セルをタップで詳細表示')
        )
      ),

      // C. 客単価分析
      React.createElement(Card, { title: '客単価分析', style: { marginBottom: 'var(--space-lg)' } },
        // 曜日別
        React.createElement('div', { style: { marginBottom: 'var(--space-lg)' } },
          React.createElement('h4', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' } }, '曜日別 平均客単価'),
          React.createElement(BarChart, {
            data: unitPrice.byDayOfWeek, valueKey: 'avg', labelKey: 'name', color: 'var(--color-primary-light)', height: 140,
          }),
          React.createElement('div', {
            style: { display: 'flex', justifyContent: 'space-around', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '6px' },
          }, unitPrice.byDayOfWeek.map(d => React.createElement('span', { key: d.name }, d.name)))
        ),

        // 時間帯別
        React.createElement('div', { style: { marginBottom: 'var(--space-lg)' } },
          React.createElement('h4', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' } }, '時間帯別 平均客単価'),
          React.createElement(BarChart, {
            data: unitPrice.byHour, valueKey: 'avg', labelKey: 'name', color: 'var(--color-accent)', height: 140, maxBars: 24,
          }),
          React.createElement('div', {
            style: { display: 'flex', justifyContent: 'space-between', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '6px', padding: '0 4px' },
          },
            React.createElement('span', null, '0時'),
            React.createElement('span', null, '6時'),
            React.createElement('span', null, '12時'),
            React.createElement('span', null, '18時'),
            React.createElement('span', null, '23時')
          )
        ),

        // 用途別
        React.createElement('div', { style: { marginBottom: 'var(--space-lg)' } },
          React.createElement('h4', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' } }, '用途別 平均客単価'),
          React.createElement(HBarChart, {
            data: unitPrice.byPurpose.filter(p => p.count > 0), nameKey: 'name', valueKey: 'avg', color: 'var(--color-warning)',
          })
        ),

        // 人数別
        React.createElement('div', null,
          React.createElement('h4', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' } }, '人数別 平均客単価'),
          React.createElement(HBarChart, {
            data: unitPrice.byPassengers.filter(p => p.count > 0), nameKey: 'name', valueKey: 'avg', color: 'var(--color-secondary)',
          })
        )
      ),

      // D. 配車方法・用途分析
      React.createElement(Card, { title: '配車方法・用途分析' },
        // 配車方法別
        React.createElement('div', { style: { marginBottom: 'var(--space-lg)' } },
          React.createElement('h4', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' } }, '配車方法別'),
          React.createElement('div', { style: { marginBottom: '12px' } },
            React.createElement(HBarChart, {
              data: sourceData.filter(s => s.count > 0), nameKey: 'name', valueKey: 'amount', color: 'var(--color-primary-light)',
            })
          ),
          React.createElement('div', {
            style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(140px, 1fr))', gap: '8px' },
          },
            sourceData.filter(s => s.count > 0).map((s, i) =>
              React.createElement('div', {
                key: i,
                style: {
                  padding: '8px', borderRadius: '8px', background: 'rgba(255,255,255,0.04)',
                  fontSize: 'var(--font-size-xs)', textAlign: 'center',
                },
              },
                React.createElement('div', { style: { fontWeight: 600, marginBottom: '2px' } }, s.name),
                React.createElement('div', { style: { color: 'var(--text-secondary)' } }, s.count + '件'),
                React.createElement('div', { style: { color: 'var(--color-secondary)', fontWeight: 500 } }, '平均¥' + s.avg.toLocaleString())
              )
            )
          )
        ),

        // 用途別
        React.createElement('div', null,
          React.createElement('h4', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' } }, '用途別'),
          React.createElement('div', { style: { marginBottom: '12px' } },
            React.createElement(HBarChart, {
              data: purposeData.filter(p => p.count > 0), nameKey: 'name', valueKey: 'amount', color: 'var(--color-accent)',
            })
          ),
          React.createElement('div', {
            style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(140px, 1fr))', gap: '8px' },
          },
            purposeData.filter(p => p.count > 0).map((p, i) =>
              React.createElement('div', {
                key: i,
                style: {
                  padding: '8px', borderRadius: '8px', background: 'rgba(255,255,255,0.04)',
                  fontSize: 'var(--font-size-xs)', textAlign: 'center',
                },
              },
                React.createElement('div', { style: { fontWeight: 600, marginBottom: '2px' } }, p.name),
                React.createElement('div', { style: { color: 'var(--text-secondary)' } }, p.count + '件'),
                React.createElement('div', { style: { color: 'var(--color-secondary)', fontWeight: 500 } }, '平均¥' + p.avg.toLocaleString())
              )
            )
          )
        )
      ),

      // E. 配車方法×エリア×単価ランク クロス分析
      sourceAreaPrice.matrixData.length > 0 && React.createElement(Card, {
        title: '配車方法×エリア×単価 クロス分析',
        style: { marginBottom: 'var(--space-lg)' },
      },
        // 凡例
        React.createElement('div', {
          style: { display: 'flex', gap: '12px', marginBottom: 'var(--space-md)', fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)', flexWrap: 'wrap' },
        },
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '4px' } },
            React.createElement('span', { style: { width: '10px', height: '10px', borderRadius: '2px', background: 'rgba(244,67,54,0.6)', display: 'inline-block' } }),
            '¥2,000以上'
          ),
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '4px' } },
            React.createElement('span', { style: { width: '10px', height: '10px', borderRadius: '2px', background: 'rgba(255,193,7,0.6)', display: 'inline-block' } }),
            '¥1,001〜1,999'
          ),
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '4px' } },
            React.createElement('span', { style: { width: '10px', height: '10px', borderRadius: '2px', background: 'rgba(76,175,80,0.6)', display: 'inline-block' } }),
            '¥1,000以下'
          )
        ),

        // エリア×配車方法マトリクス（平均単価 + 単価ランク内訳バー）
        React.createElement('div', { style: { overflowX: 'auto' } },
          React.createElement('div', {
            style: {
              display: 'grid',
              gridTemplateColumns: '100px repeat(5, 1fr)',
              gap: '2px',
              fontSize: 'var(--font-size-xs)',
              minWidth: '480px',
            },
          },
            // ヘッダー
            React.createElement('div', { style: { padding: '8px 4px', fontWeight: 600, color: 'var(--text-secondary)' } }, 'エリア'),
            ...sourceAreaPrice.sources.map(s =>
              React.createElement('div', { key: s, style: { padding: '8px 4px', textAlign: 'center', fontWeight: 600, color: 'var(--text-secondary)' } }, s)
            ),

            // データ行
            ...sourceAreaPrice.matrixData.flatMap(row => [
              React.createElement('div', {
                key: row.area + '-lbl',
                style: { padding: '8px 4px', fontWeight: 500, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', borderBottom: '1px solid rgba(255,255,255,0.06)', display: 'flex', alignItems: 'center' },
                title: row.area,
              }, row.area.length > 8 ? row.area.slice(0, 8) + '…' : row.area),

              ...sourceAreaPrice.sources.map(src => {
                const d = row[src];
                if (d.count === 0) {
                  return React.createElement('div', {
                    key: row.area + '-' + src,
                    style: { padding: '8px 4px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.06)', color: 'var(--text-muted)' },
                  }, '-');
                }
                const total = d.tiers.short + d.tiers.mid + d.tiers.long;
                const pctS = total > 0 ? (d.tiers.short / total) * 100 : 0;
                const pctM = total > 0 ? (d.tiers.mid / total) * 100 : 0;
                const pctL = total > 0 ? (d.tiers.long / total) * 100 : 0;
                return React.createElement('div', {
                  key: row.area + '-' + src,
                  style: { padding: '6px 4px', borderBottom: '1px solid rgba(255,255,255,0.06)', textAlign: 'center' },
                  title: row.area + ' × ' + src + ': ' + d.count + '件 平均¥' + d.avg.toLocaleString() + ' (短' + d.tiers.short + '/中' + d.tiers.mid + '/長' + d.tiers.long + ')',
                },
                  React.createElement('div', { style: { fontWeight: 600, marginBottom: '3px' } }, '¥' + d.avg.toLocaleString()),
                  React.createElement('div', { style: { fontSize: '9px', color: 'var(--text-muted)', marginBottom: '3px' } }, d.count + '件'),
                  // 単価ランク内訳バー
                  React.createElement('div', {
                    style: { display: 'flex', height: '4px', borderRadius: '2px', overflow: 'hidden', background: 'rgba(255,255,255,0.06)' },
                  },
                    pctS > 0 && React.createElement('div', { style: { width: pctS + '%', background: 'rgba(76,175,80,0.7)' } }),
                    pctM > 0 && React.createElement('div', { style: { width: pctM + '%', background: 'rgba(255,193,7,0.7)' } }),
                    pctL > 0 && React.createElement('div', { style: { width: pctL + '%', background: 'rgba(244,67,54,0.7)' } })
                  )
                );
              })
            ])
          )
        ),

        React.createElement('div', {
          style: { marginTop: '8px', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' },
        }, 'セルをタップで詳細表示 | バー: 緑=短距離 黄=中距離 赤=長距離')
      ),

      // 配車方法別 単価ランク構成
      sourceAreaPrice.sourceTierList.some(s => s.totalCount > 0) && React.createElement(Card, {
        title: '配車方法別 単価ランク構成',
        style: { marginBottom: 'var(--space-lg)' },
      },
        React.createElement('div', { style: { display: 'grid', gap: 'var(--space-md)' } },
          sourceAreaPrice.sourceTierList.filter(s => s.totalCount > 0).map(s =>
            React.createElement('div', { key: s.source },
              React.createElement('div', {
                style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '4px' },
              },
                React.createElement('span', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)' } }, s.source),
                React.createElement('span', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } }, s.totalCount + '件')
              ),
              // 積み上げバー
              React.createElement('div', {
                style: { display: 'flex', height: '20px', borderRadius: '4px', overflow: 'hidden', background: 'rgba(255,255,255,0.06)' },
              },
                ...s.tiers.map(t => {
                  const pct = s.totalCount > 0 ? (t.count / s.totalCount) * 100 : 0;
                  if (pct === 0) return null;
                  const colors = { short: 'rgba(76,175,80,0.7)', mid: 'rgba(255,193,7,0.7)', long: 'rgba(244,67,54,0.7)' };
                  return React.createElement('div', {
                    key: t.key,
                    style: {
                      width: pct + '%', background: colors[t.key],
                      display: 'flex', alignItems: 'center', justifyContent: 'center',
                      fontSize: '9px', fontWeight: 600, color: '#fff', whiteSpace: 'nowrap',
                      minWidth: pct > 8 ? 'auto' : '0',
                    },
                    title: t.label + ': ' + t.count + '件 平均¥' + t.avg.toLocaleString(),
                  }, pct >= 15 ? Math.round(pct) + '%' : '');
                })
              ),
              // ラベル
              React.createElement('div', {
                style: { display: 'flex', justifyContent: 'space-between', marginTop: '3px', fontSize: '10px', color: 'var(--text-muted)' },
              },
                ...s.tiers.filter(t => t.count > 0).map(t =>
                  React.createElement('span', { key: t.key }, t.label + ' ' + t.count + '件 avg¥' + t.avg.toLocaleString())
                )
              )
            )
          )
        )
      ),

      // エリア別 単価ランク構成
      sourceAreaPrice.areaTierList.length > 0 && React.createElement(Card, {
        title: 'エリア別 単価ランク構成',
        style: { marginBottom: 'var(--space-lg)' },
      },
        React.createElement('div', { style: { display: 'grid', gap: 'var(--space-md)' } },
          sourceAreaPrice.areaTierList.map(a =>
            React.createElement('div', { key: a.area },
              React.createElement('div', {
                style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '4px' },
              },
                React.createElement('span', {
                  style: { fontWeight: 600, fontSize: 'var(--font-size-sm)', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', maxWidth: '60%' },
                  title: a.area,
                }, a.area),
                React.createElement('span', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } }, a.total + '件')
              ),
              // 積み上げバー
              React.createElement('div', {
                style: { display: 'flex', height: '16px', borderRadius: '4px', overflow: 'hidden', background: 'rgba(255,255,255,0.06)' },
              },
                ...a.tiers.map(t => {
                  if (t.pct === 0) return null;
                  const colors = { short: 'rgba(76,175,80,0.7)', mid: 'rgba(255,193,7,0.7)', long: 'rgba(244,67,54,0.7)' };
                  return React.createElement('div', {
                    key: t.key,
                    style: {
                      width: t.pct + '%', background: colors[t.key],
                      display: 'flex', alignItems: 'center', justifyContent: 'center',
                      fontSize: '9px', fontWeight: 600, color: '#fff',
                    },
                    title: t.label + ': ' + t.count + '件 (' + t.pct + '%)',
                  }, t.pct >= 15 ? t.pct + '%' : '');
                })
              )
            )
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/Settings.jsx
// ============================================================
(function() {
// Settings.jsx - 設定ページ
window.SettingsPage = () => {
  const { useState } = React;
  const { apiKey, setApiKey, geminiApiKey, setGeminiApiKey } = useAppContext();
  const [inputKey, setInputKey] = useState(apiKey);
  const [saved, setSaved] = useState(false);
  const [geminiInputKey, setGeminiInputKey] = useState(geminiApiKey);
  const [geminiSaved, setGeminiSaved] = useState(false);
  const [geminiTesting, setGeminiTesting] = useState(false);
  const [geminiTestResult, setGeminiTestResult] = useState(null);

  // クラウド同期
  const [syncSecret, setSyncSecret] = useState(localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.SYNC_SECRET) || '');
  const [syncSaved, setSyncSaved] = useState(false);
  const [syncTesting, setSyncTesting] = useState(false);
  const [syncTestResult, setSyncTestResult] = useState(null);
  const [syncStatus, setSyncStatus] = useState(null);
  const [refreshKey, setRefreshKey] = useState(0);

  const handleSave = () => {
    setApiKey(inputKey.trim());
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
  };

  const handleClear = () => {
    setApiKey('');
    setInputKey('');
    window._gmapLoader.reset();
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
  };

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'settings'),
      '設定'
    ),

    // Google Maps API キー
    React.createElement(Card, { title: 'Google Maps API キー', style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('p', {
        style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: 'var(--space-md)' },
      }, 'Google Maps を表示するにはAPIキーが必要です。'),

      React.createElement('div', { className: 'form-group' },
        React.createElement('label', { className: 'form-label' }, 'APIキー'),
        React.createElement('input', {
          className: 'form-input',
          type: 'password',
          placeholder: 'AIzaSy...',
          value: inputKey,
          onChange: (e) => setInputKey(e.target.value),
          style: { fontFamily: 'monospace' },
        })
      ),

      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap' } },
        React.createElement(Button, {
          variant: 'primary',
          icon: 'save',
          onClick: handleSave,
        }, '保存'),
        inputKey && React.createElement(Button, {
          variant: 'secondary',
          icon: 'delete',
          onClick: handleClear,
        }, 'クリア'),
        saved && React.createElement('span', {
          style: { color: 'var(--color-accent)', fontSize: 'var(--font-size-sm)', display: 'flex', alignItems: 'center', gap: '4px' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'check_circle'),
          '保存しました'
        ),
        apiKey && React.createElement('span', { className: 'badge badge--success' }, 'APIキー設定済み'),
        !apiKey && React.createElement('span', { className: 'badge badge--warning' }, 'デモモード')
      ),

      // トラブルシューティング
      apiKey && React.createElement('div', {
        style: {
          marginTop: 'var(--space-md)', padding: 'var(--space-md)',
          background: 'rgba(249, 168, 37, 0.08)', borderRadius: '8px', border: '1px solid rgba(249, 168, 37, 0.2)',
        },
      },
        React.createElement('div', {
          style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--color-secondary)' } }, 'info'),
          React.createElement('strong', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-secondary)' } }, '地図が正しく表示されない場合')
        ),
        React.createElement('div', {
          style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)', lineHeight: 1.8 },
        },
          React.createElement('p', { style: { margin: '4px 0' } }, '「For development purposes only」と表示される場合：'),
          React.createElement('p', { style: { margin: '2px 0', paddingLeft: '12px' } }, '① Google Cloud Console で請求先アカウント（Billing）を有効にしてください'),
          React.createElement('p', { style: { margin: '2px 0', paddingLeft: '12px' } }, '② 「Maps JavaScript API」が有効になっていることを確認してください'),
          React.createElement('p', { style: { margin: '4px 0', marginTop: '8px' } }, '地図が全く表示されない場合：'),
          React.createElement('p', { style: { margin: '2px 0', paddingLeft: '12px' } }, '③ APIキーの「アプリケーションの制限」で HTTP リファラーを「なし」に設定してください'),
          React.createElement('p', { style: { margin: '2px 0', paddingLeft: '12px' } }, '④ ローカルファイルから開く場合、リファラー制限があると動作しません')
        )
      ),

      // 取得手順
      React.createElement('details', {
        style: { marginTop: 'var(--space-md)', cursor: 'pointer' },
      },
        React.createElement('summary', {
          style: { color: 'var(--color-primary-light)', fontSize: 'var(--font-size-sm)' },
        }, 'APIキーの取得方法（初めての方）'),
        React.createElement('div', {
          style: { padding: 'var(--space-md)', color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)', lineHeight: 1.8 },
        },
          React.createElement('p', null, '1. Google Cloud Console（https://console.cloud.google.com）にアクセス'),
          React.createElement('p', null, '2. プロジェクトを作成または選択'),
          React.createElement('p', { style: { color: 'var(--color-warning)' } }, '3. 「お支払い」から請求先アカウントを設定（月$200分の無料枠あり）'),
          React.createElement('p', null, '4. 「APIとサービス」→「ライブラリ」から「Maps JavaScript API」を有効化'),
          React.createElement('p', null, '5. 「認証情報」→「認証情報を作成」→「APIキー」を選択'),
          React.createElement('p', { style: { color: 'var(--color-warning)' } }, '6. APIキーの「アプリケーションの制限」は「なし」に設定'),
          React.createElement('p', null, '7. 上のフォームにAPIキーを貼り付けて保存'),
          React.createElement('p', {
            style: { marginTop: '8px', padding: '8px 12px', background: 'rgba(0,200,83,0.08)', borderRadius: '6px', color: 'var(--color-accent)' },
          }, '※ 月$200の無料クレジットがあるため、個人利用では通常料金はかかりません。')
        )
      )
    ),

    // Gemini API キー
    React.createElement(Card, { title: 'Gemini API キー（AI検索）', style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('p', {
        style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: 'var(--space-md)' },
      }, 'Google Gemini を使用して公共交通機関情報やイベント情報をAI検索できます。'),

      React.createElement('div', { className: 'form-group' },
        React.createElement('label', { className: 'form-label' }, 'Gemini APIキー'),
        React.createElement('input', {
          className: 'form-input',
          type: 'password',
          placeholder: 'AIzaSy...',
          value: geminiInputKey,
          onChange: (e) => setGeminiInputKey(e.target.value),
          style: { fontFamily: 'monospace' },
        })
      ),

      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap' } },
        React.createElement(Button, {
          variant: 'primary',
          icon: 'save',
          onClick: () => {
            setGeminiApiKey(geminiInputKey.trim());
            setGeminiSaved(true);
            setGeminiTestResult(null);
            setTimeout(() => setGeminiSaved(false), 2000);
          },
        }, '保存'),
        geminiInputKey && React.createElement(Button, {
          variant: 'secondary',
          icon: 'delete',
          onClick: () => {
            setGeminiApiKey('');
            setGeminiInputKey('');
            setGeminiTestResult(null);
            setGeminiSaved(true);
            setTimeout(() => setGeminiSaved(false), 2000);
          },
        }, 'クリア'),
        geminiInputKey && React.createElement(Button, {
          variant: 'secondary',
          icon: geminiTesting ? 'sync' : 'network_check',
          onClick: async () => {
            setGeminiTesting(true);
            setGeminiTestResult(null);
            const result = await GeminiService.testConnection(geminiInputKey.trim());
            setGeminiTesting(false);
            setGeminiTestResult(result.success ? 'success' : result.error);
          },
          disabled: geminiTesting,
        }, geminiTesting ? 'テスト中...' : '接続テスト'),
        geminiSaved && React.createElement('span', {
          style: { color: 'var(--color-accent)', fontSize: 'var(--font-size-sm)', display: 'flex', alignItems: 'center', gap: '4px' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'check_circle'),
          '保存しました'
        ),
        geminiApiKey && React.createElement('span', { className: 'badge badge--success' }, 'APIキー設定済み'),
        !geminiApiKey && React.createElement('span', { className: 'badge badge--warning' }, '未設定')
      ),

      geminiTestResult && React.createElement('div', {
        style: {
          marginTop: 'var(--space-md)', padding: '8px 12px', borderRadius: '8px',
          background: geminiTestResult === 'success' ? 'rgba(0,200,83,0.1)' : 'rgba(229,57,53,0.1)',
          border: `1px solid ${geminiTestResult === 'success' ? 'rgba(0,200,83,0.3)' : 'rgba(229,57,53,0.3)'}`,
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: geminiTestResult === 'success' ? 'var(--color-accent)' : 'var(--color-danger)' },
        }, geminiTestResult === 'success' ? 'check_circle' : 'error'),
        React.createElement('span', {
          style: { fontSize: 'var(--font-size-sm)', color: geminiTestResult === 'success' ? 'var(--color-accent)' : 'var(--color-danger)' },
        }, geminiTestResult === 'success' ? 'Gemini APIに正常に接続できました' : geminiTestResult)
      ),

      React.createElement('details', {
        style: { marginTop: 'var(--space-md)', cursor: 'pointer' },
      },
        React.createElement('summary', {
          style: { color: 'var(--color-primary-light)', fontSize: 'var(--font-size-sm)' },
        }, 'Gemini APIキーの取得方法'),
        React.createElement('div', {
          style: { padding: 'var(--space-md)', color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)', lineHeight: 1.8 },
        },
          React.createElement('p', null, '1. Google AI Studio（https://aistudio.google.com）にアクセス'),
          React.createElement('p', null, '2. Googleアカウントでログイン'),
          React.createElement('p', null, '3. 「Get API Key」→「Create API key」をクリック'),
          React.createElement('p', null, '4. 生成されたAPIキーをコピー'),
          React.createElement('p', null, '5. 上のフォームに貼り付けて保存'),
          React.createElement('p', {
            style: { marginTop: '8px', padding: '8px 12px', background: 'rgba(0,200,83,0.08)', borderRadius: '6px', color: 'var(--color-accent)' },
          }, '※ 無料枠: 15リクエスト/分、1,500リクエスト/日（Gemini 2.0 Flash）')
        )
      )
    ),

    // クラウド同期
    React.createElement(Card, { title: 'クラウド同期', style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('p', {
        style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: 'var(--space-md)' },
      }, 'Vercel Blob Storageを使用してデータをクラウドに保存・同期します。記録追加時に自動的にクラウドへ保存されます。'),

      React.createElement('div', { className: 'form-group', style: { marginBottom: 'var(--space-md)' } },
        React.createElement('label', { className: 'form-label' }, '同期シークレット'),
        React.createElement('input', {
          className: 'form-input',
          type: 'password',
          placeholder: 'Vercel環境変数のSYNC_SECRETと同じ値',
          value: syncSecret,
          onChange: (e) => setSyncSecret(e.target.value),
          style: { fontFamily: 'monospace' },
        }),
        React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginTop: '8px' } },
          React.createElement(Button, {
            variant: 'primary',
            icon: 'save',
            onClick: () => {
              localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.SYNC_SECRET, syncSecret.trim());
              setSyncStatus('シークレットを保存しました');
              setTimeout(() => setSyncStatus(null), 2000);
            },
          }, '保存'),
          React.createElement('span', {
            style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' },
          }, '※ Vercelダッシュボードの環境変数SYNC_SECRETと同じ値を設定')
        )
      ),

      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap', marginBottom: 'var(--space-md)' } },
        React.createElement(Button, {
          variant: 'secondary',
          icon: syncTesting ? 'sync' : 'network_check',
          onClick: async () => {
            setSyncTesting(true);
            setSyncTestResult(null);
            try {
              const res = await fetch('/api/data?type=revenue');
              if (res.ok) {
                setSyncTestResult('success');
              } else {
                let detail = '';
                try { const j = await res.json(); detail = j.detail || j.error || ''; } catch {}
                setSyncTestResult(`エラー: ${res.status}${detail ? ' - ' + detail : ''}`);
              }
            } catch (e) {
              setSyncTestResult('接続エラー: ' + e.message);
            }
            setSyncTesting(false);
          },
          disabled: syncTesting,
        }, syncTesting ? 'テスト中...' : '接続テスト')
      ),

      // 接続テスト結果
      syncTestResult && React.createElement('div', {
        style: {
          marginBottom: 'var(--space-md)', padding: '8px 12px', borderRadius: '8px',
          background: syncTestResult === 'success' ? 'rgba(0,200,83,0.1)' : 'rgba(229,57,53,0.1)',
          border: `1px solid ${syncTestResult === 'success' ? 'rgba(0,200,83,0.3)' : 'rgba(229,57,53,0.3)'}`,
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: syncTestResult === 'success' ? 'var(--color-accent)' : 'var(--color-danger)' },
        }, syncTestResult === 'success' ? 'check_circle' : 'error'),
        React.createElement('span', {
          style: { fontSize: 'var(--font-size-sm)', color: syncTestResult === 'success' ? 'var(--color-accent)' : 'var(--color-danger)' },
        }, syncTestResult === 'success' ? 'クラウドに正常に接続できました' : syncTestResult)
      ),

      // 自動同期ステータス
      React.createElement('div', {
        style: {
          padding: '8px 12px', borderRadius: '8px', marginBottom: 'var(--space-md)',
          background: syncSecret ? 'rgba(0, 200, 83, 0.1)' : 'rgba(255, 152, 0, 0.1)',
          border: `1px solid ${syncSecret ? 'rgba(0, 200, 83, 0.3)' : 'rgba(255, 152, 0, 0.3)'}`,
          display: 'flex', alignItems: 'center', gap: '8px',
          fontSize: 'var(--font-size-sm)',
          color: syncSecret ? 'var(--color-accent)' : 'var(--color-warning)',
        },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, syncSecret ? 'sync' : 'sync_disabled'),
        syncSecret ? '自動同期: 有効（起動時・タブ復帰時・5分間隔）' : '自動同期: SYNC_SECRET未設定のため無効'
      ),

      // 手動同期ボタン
      React.createElement('div', {
        style: { display: 'flex', gap: '12px', flexWrap: 'wrap', marginBottom: 'var(--space-md)' },
      },
        React.createElement(Button, {
          variant: 'primary',
          icon: 'cloud_upload',
          onClick: async () => {
            setSyncStatus('送信中...');
            try {
              const revenueEntries = DataService.getEntries();
              const rivalEntries = DataService.getRivalEntries();
              const secret = (localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.SYNC_SECRET) || '').trim();
              const headers = { 'Content-Type': 'application/json', ...(secret ? { 'Authorization': `Bearer ${secret}` } : {}) };
              const [r1, r2] = await Promise.all([
                fetch('/api/data?type=revenue', { method: 'POST', headers, body: JSON.stringify({ version: APP_CONSTANTS.VERSION, syncedAt: new Date().toISOString(), count: revenueEntries.length, entries: revenueEntries }) }),
                fetch('/api/data?type=rival', { method: 'POST', headers, body: JSON.stringify({ version: APP_CONSTANTS.VERSION, syncedAt: new Date().toISOString(), count: rivalEntries.length, entries: rivalEntries }) }),
              ]);
              if (r1.ok && r2.ok) {
                setSyncStatus(`送信完了: 売上${revenueEntries.length}件, 他社${rivalEntries.length}件`);
              } else {
                let d1 = '', d2 = '';
                try { const j = await r1.json(); d1 = j.detail || j.error || ''; } catch {}
                try { const j = await r2.json(); d2 = j.detail || j.error || ''; } catch {}
                setSyncStatus(`送信エラー: revenue=${r1.status}${d1 ? '(' + d1 + ')' : ''}, rival=${r2.status}${d2 ? '(' + d2 + ')' : ''}`);
              }
            } catch (e) {
              setSyncStatus('送信エラー: ' + e.message);
            }
          },
        }, 'クラウドに送信'),
        React.createElement(Button, {
          variant: 'secondary',
          icon: 'cloud_download',
          onClick: async () => {
            setSyncStatus('取得中...');
            try {
              const [r1, r2] = await Promise.all([
                DataService.syncFromCloud('revenue'),
                DataService.syncFromCloud('rival'),
              ]);
              setSyncStatus(`取得完了: 売上+${r1.merged}件, 他社+${r2.merged}件`);
            } catch (e) {
              setSyncStatus('取得エラー: ' + e.message);
            }
          },
        }, 'クラウドから取得')
      ),

      // 同期状態表示
      syncStatus && React.createElement('div', {
        style: {
          padding: '8px 12px', borderRadius: '8px',
          background: 'rgba(66, 165, 245, 0.1)', border: '1px solid rgba(66, 165, 245, 0.3)',
          fontSize: 'var(--font-size-sm)', color: 'var(--color-primary-light)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, 'cloud_sync'),
        syncStatus
      )
    ),

    // プッシュ通知設定
    React.createElement(Card, { title: 'プッシュ通知', style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('p', {
        style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: 'var(--space-md)' },
      }, '交通機関の遅延・トラブル情報をブラウザ通知でお知らせします。'),
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between' } },
        React.createElement('div', null,
          React.createElement('div', { style: { fontWeight: 500, fontSize: 'var(--font-size-sm)' } }, '通知'),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } },
            !NotificationService.isSupported() ? 'このブラウザは通知に対応していません'
              : NotificationService.getPermission() === 'denied' ? 'ブラウザの通知が拒否されています。ブラウザ設定から許可してください'
              : '遅延・運休・事故などの交通情報を自動通知'
          )
        ),
        React.createElement('button', {
          onClick: async () => {
            if (!NotificationService.isSupported()) return;
            if (NotificationService.isEnabled()) {
              NotificationService.setEnabled(false);
              setRefreshKey(k => k + 1);
            } else {
              const perm = await NotificationService.requestPermission();
              if (perm === 'granted') {
                NotificationService.setEnabled(true);
                NotificationService.send('通知テスト', { body: '通知が有効になりました' });
              }
              setRefreshKey(k => k + 1);
            }
          },
          disabled: !NotificationService.isSupported() || NotificationService.getPermission() === 'denied',
          style: {
            padding: '8px 20px', borderRadius: '20px', border: 'none', cursor: 'pointer',
            fontWeight: 700, fontSize: 'var(--font-size-sm)', fontFamily: 'var(--font-family)',
            background: NotificationService.isEnabled() ? 'var(--color-accent)' : 'rgba(255,255,255,0.1)',
            color: NotificationService.isEnabled() ? '#fff' : 'var(--text-secondary)',
            opacity: (!NotificationService.isSupported() || NotificationService.getPermission() === 'denied') ? 0.5 : 1,
            transition: 'all 0.2s ease',
          },
        }, NotificationService.isEnabled() ? 'ON' : 'OFF')
      )
    ),

    // GPS設定
    React.createElement(Card, { title: 'GPS設定', style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '8px 0' } },
        React.createElement('div', null,
          React.createElement('div', { style: { fontWeight: 500, fontSize: 'var(--font-size-sm)' } }, '高精度モード'),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } }, 'GPSの精度を最大にする（バッテリー消費が増えます）')
        ),
        React.createElement('span', { className: 'badge badge--success' }, '有効')
      ),
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '8px 0' } },
        React.createElement('div', null,
          React.createElement('div', { style: { fontWeight: 500, fontSize: 'var(--font-size-sm)' } }, 'バックグラウンド追跡'),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } }, 'アプリがバックグラウンドでも位置を追跡')
        ),
        React.createElement('span', { className: 'badge badge--warning' }, 'PWA必要')
      )
    ),

    // アプリをインストール（PWA）
    React.createElement(Card, { title: 'アプリをインストール', style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('div', { style: { display: 'flex', alignItems: 'flex-start', gap: '12px' } },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '36px', color: 'var(--color-primary-light)' },
        }, 'install_mobile'),
        React.createElement('div', { style: { flex: 1 } },
          React.createElement('div', { style: { fontWeight: 600, marginBottom: '4px' } }, 'ホーム画面に追加'),
          React.createElement('div', {
            style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', lineHeight: 1.6, marginBottom: '12px' },
          }, 'このアプリをスマートフォンのホーム画面に追加すると、ネイティブアプリのように使えます。オフラインでも基本機能が利用可能です。')
        )
      ),
      React.createElement(Button, {
        variant: 'primary',
        icon: 'download',
        onClick: async () => {
          const result = await window.triggerPwaInstall();
          if (!result.success && result.reason === 'prompt_not_available') {
            alert('手動インストール方法:\n\n【Android Chrome】\nメニュー（⋮）→「ホーム画面に追加」\n\n【iPhone Safari】\n共有ボタン（□↑）→「ホーム画面に追加」');
          }
        },
      }, 'インストール'),
      React.createElement('details', {
        style: { marginTop: 'var(--space-md)', cursor: 'pointer' },
      },
        React.createElement('summary', {
          style: { color: 'var(--color-primary-light)', fontSize: 'var(--font-size-sm)' },
        }, '手動インストール方法'),
        React.createElement('div', {
          style: { padding: 'var(--space-md)', color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)', lineHeight: 1.8 },
        },
          React.createElement('div', { style: { fontWeight: 600, marginBottom: '4px' } }, 'Android（Chrome）:'),
          React.createElement('p', null, '1. Chrome でこのページを開く'),
          React.createElement('p', null, '2. 右上の メニュー（⋮）をタップ'),
          React.createElement('p', null, '3.「ホーム画面に追加」または「アプリをインストール」をタップ'),
          React.createElement('div', { style: { fontWeight: 600, marginTop: '12px', marginBottom: '4px' } }, 'iPhone（Safari）:'),
          React.createElement('p', null, '1. Safari でこのページを開く'),
          React.createElement('p', null, '2. 下部の 共有ボタン（□↑）をタップ'),
          React.createElement('p', null, '3.「ホーム画面に追加」をタップ')
        )
      )
    ),

    // アプリ情報
    React.createElement(Card, { title: 'アプリ情報' },
      React.createElement('div', { style: { display: 'grid', gap: '8px', fontSize: 'var(--font-size-sm)' } },
        React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between' } },
          React.createElement('span', { style: { color: 'var(--text-secondary)' } }, 'バージョン'),
          React.createElement('span', null, APP_CONSTANTS.VERSION)
        ),
        React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between' } },
          React.createElement('span', { style: { color: 'var(--text-secondary)' } }, 'ビルド'),
          React.createElement('span', null, 'CDN (開発版)')
        ),
        React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between' } },
          React.createElement('span', { style: { color: 'var(--text-secondary)' } }, 'React'),
          React.createElement('span', null, React.version)
        )
      )
    )
  );
};

})();

// 音声入力テキストをパースして各フィールドに分解する
function parseVoiceInput(text) {
  const result = {};
  // 全角数字→半角変換 + カンマ除去（Speech APIが「3,500円」のように返す場合に対応）
  let remaining = text
    .replace(/[０-９]/g, c => String.fromCharCode(c.charCodeAt(0) - 0xFEE0))
    .replace(/(\d),(\d)/g, '$1$2');

  // 金額: 「3500円」「3500 円」
  const amountMatch = remaining.match(/(\d+)\s*円/);
  if (amountMatch) {
    result.amount = amountMatch[1];
    remaining = remaining.replace(amountMatch[0], ' ');
  }

  // 天候
  const weatherMatch = remaining.match(/晴れ|曇り?|雨|雪/);
  if (weatherMatch) {
    result.weather = weatherMatch[0] === '曇' ? '曇り' : weatherMatch[0];
    remaining = remaining.replace(weatherMatch[0], ' ');
  }

  // 人数: 「1名」「2人」「一名」
  const passMatch = remaining.match(/(\d+)\s*[名人]/);
  if (passMatch) {
    result.passengers = passMatch[1];
    remaining = remaining.replace(passMatch[0], ' ');
  }

  // 性別
  const genderMatch = remaining.match(/男性|女性/);
  if (genderMatch) {
    result.gender = genderMatch[0];
    remaining = remaining.replace(genderMatch[0], ' ');
  }

  // 配車方法（ラテン文字 + カタカナ両対応、単語境界なし）
  const sourcePatterns = [
    { pattern: /(?:ゴー|[Gg][Oo](?!ogle))/, value: 'Go' },
    { pattern: /(?:ウーバー|[Uu]ber)/, value: 'Uber' },
    { pattern: /(?:ディディ|ディーディー|[Dd][Ii][Dd][Ii])/, value: 'DIDI' },
    { pattern: /電話/, value: '電話' },
    { pattern: /流し|ながし/, value: '流し' },
  ];
  for (const sp of sourcePatterns) {
    const m = remaining.match(sp.pattern);
    if (m) {
      result.source = sp.value;
      remaining = remaining.replace(m[0], ' ');
      break;
    }
  }

  // 用途
  const purposeMatch = remaining.match(/通勤|通院|買い?物|観光|出張|送迎|空港|飲食|その他/);
  if (purposeMatch) {
    result.purpose = purposeMatch[0].replace('買い物', '買物');
    remaining = remaining.replace(purposeMatch[0], ' ');
  }

  // 金額フォールバック: 3桁以上の単独数字
  if (!result.amount) {
    const numMatch = remaining.match(/(\d{3,})/);
    if (numMatch) {
      result.amount = numMatch[1];
      remaining = remaining.replace(numMatch[0], ' ');
    }
  }

  // 場所: 「から」で分割
  remaining = remaining.replace(/\s+/g, ' ').trim();
  if (remaining.includes('から')) {
    const parts = remaining.split('から');
    const pickup = parts[0].trim();
    const rest = parts.slice(1).join('から').trim();
    if (pickup) result.pickup = pickup;
    if (rest) result.dropoff = rest;
  } else if (remaining) {
    result.memo = remaining;
  }

  return result;
}

// ============================================================
// FILE: src/pages/DataManage.jsx
// ============================================================
(function() {
// DataManage.jsx - データ管理ページ（売上・他社・交通情報の編集・削除）
window.DataManagePage = () => {
  const { useState, useEffect, useCallback, useMemo } = React;
  const [tab, setTab] = useState('revenue');
  const [refreshKey, setRefreshKey] = useState(0);
  const [editingId, setEditingId] = useState(null);
  const [editForm, setEditForm] = useState({});
  const [errors, setErrors] = useState([]);
  const [saved, setSaved] = useState(false);
  const [confirmDelete, setConfirmDelete] = useState(null);
  const [search, setSearch] = useState('');
  const [showAddForm, setShowAddForm] = useState(false);
  const todayDefault = new Date().toISOString().split('T')[0];
  const [addForm, setAddForm] = useState({ date: todayDefault, weather: '', amount: '', pickup: '', pickupTime: '', dropoff: '', dropoffTime: '', passengers: '1', gender: '', purpose: '', memo: '', source: '' });
  const [addErrors, setAddErrors] = useState([]);
  const [mapPickerField, setMapPickerField] = useState(null); // 'pickup' | 'dropoff' | null
  const [addCoords, setAddCoords] = useState({ pickupCoords: null, dropoffCoords: null });
  const mapPickerRef = React.useRef(null);
  const mapPickerInstanceRef = React.useRef(null);
  const mapPickerMarkerRef = React.useRef(null);
  const [editMapPickerField, setEditMapPickerField] = useState(null); // 'pickup' | null
  const editMapPickerRef = React.useRef(null);
  const editMapPickerInstanceRef = React.useRef(null);
  const editMapPickerMarkerRef = React.useRef(null);
  const [isListening, setIsListening] = useState(false);
  const [interimText, setInterimText] = useState('');
  const [voiceSuccess, setVoiceSuccess] = useState(false);
  const recognitionRef = React.useRef(null);
  const speechSupported = React.useRef(!!(window.SpeechRecognition || window.webkitSpeechRecognition));
  const { apiKey } = useAppContext();

  const tabs = [
    { id: 'revenue', label: '売上記録', icon: 'receipt_long' },
    { id: 'rival', label: '他社記録', icon: 'local_taxi' },
    { id: 'transit', label: '交通情報', icon: 'directions_transit' },
  ];

  // データ読み込み
  const revenueEntries = useMemo(() => DataService.getEntries(), [refreshKey]);
  const rivalEntries = useMemo(() => DataService.getRivalEntries(), [refreshKey]);
  const transitData = useMemo(() => {
    try {
      const saved = AppStorage.get(APP_CONSTANTS.STORAGE_KEYS.TRANSIT_INFO, {});
      return saved;
    } catch { return {}; }
  }, [refreshKey]);

  // storage変更を監視
  useEffect(() => {
    const handleStorage = (e) => {
      if ([APP_CONSTANTS.STORAGE_KEYS.REVENUE_DATA, APP_CONSTANTS.STORAGE_KEYS.RIVAL_RIDES, APP_CONSTANTS.STORAGE_KEYS.TRANSIT_INFO].includes(e.key)) {
        setRefreshKey(k => k + 1);
      }
    };
    window.addEventListener('storage', handleStorage);
    return () => window.removeEventListener('storage', handleStorage);
  }, []);

  // 編集開始
  const startEdit = useCallback((entry, type) => {
    setEditingId(entry.id);
    setEditForm(type === 'revenue'
      ? { amount: String(entry.amount), date: entry.date || '', weather: entry.weather || '', pickup: entry.pickup || '', pickupTime: entry.pickupTime || '', dropoff: entry.dropoff || '', dropoffTime: entry.dropoffTime || '', passengers: entry.passengers || '', gender: entry.gender || '', purpose: entry.purpose || '', memo: entry.memo || '', source: entry.source || '' }
      : { date: entry.date || '', time: entry.time || '', weather: entry.weather || '', location: entry.location || '', memo: entry.memo || '' }
    );
    setErrors([]);
  }, []);

  // 編集保存
  const saveEdit = useCallback(() => {
    setErrors([]);
    let result;
    if (tab === 'revenue') {
      result = DataService.updateEntry(editingId, editForm);
    } else if (tab === 'rival') {
      result = DataService.updateRivalEntry(editingId, editForm);
    } else {
      setErrors(['このタブでは編集できません']);
      return;
    }
    if (!result || !result.success) { setErrors((result && result.errors) || ['保存に失敗しました']); return; }
    setEditingId(null);
    setEditForm({});
    setEditMapPickerField(null);
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
    setRefreshKey(k => k + 1);
  }, [tab, editingId, editForm]);

  // 削除確認→実行
  const handleDelete = useCallback((id) => {
    if (confirmDelete === id) {
      if (tab === 'revenue') DataService.deleteEntry(id);
      else if (tab === 'rival') DataService.deleteRivalEntry(id);
      setConfirmDelete(null);
      setRefreshKey(k => k + 1);
    } else {
      setConfirmDelete(id);
      setTimeout(() => setConfirmDelete(null), 3000);
    }
  }, [tab, confirmDelete]);

  // 交通情報の個別カテゴリ削除
  const deleteTransitCategory = useCallback((key) => {
    const current = AppStorage.get(APP_CONSTANTS.STORAGE_KEYS.TRANSIT_INFO, {});
    delete current[key];
    AppStorage.set(APP_CONSTANTS.STORAGE_KEYS.TRANSIT_INFO, current);
    setRefreshKey(k => k + 1);
  }, []);

  // マップピッカーの初期化・クリックハンドラ
  useEffect(() => {
    if (!mapPickerField || !mapPickerRef.current || !window.google || !window.google.maps) return;
    setTimeout(() => { mapPickerRef.current && mapPickerRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' }); }, 100);
    const center = APP_CONSTANTS.DEFAULT_MAP_CENTER;
    const map = new google.maps.Map(mapPickerRef.current, {
      center, zoom: 13, mapTypeId: 'roadmap', disableDefaultUI: true,
      zoomControl: true, fullscreenControl: false, mapTypeControl: false,
    });
    mapPickerInstanceRef.current = map;
    const marker = new google.maps.Marker({ map, position: center, visible: false });
    mapPickerMarkerRef.current = marker;

    // GPS現在地を取得してマップの中心に設定
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const currentPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
          map.setCenter(currentPos);
          map.setZoom(13);
          new google.maps.Marker({ map, position: currentPos, icon: { path: google.maps.SymbolPath.CIRCLE, scale: 8, fillColor: '#4285F4', fillOpacity: 1, strokeColor: '#fff', strokeWeight: 2 }, title: '現在地', clickable: false });
        },
        () => {},
        { enableHighAccuracy: true, timeout: 5000, maximumAge: 10000 }
      );
    }

    // 住所コンポーネントから日本語住所を抽出
    function _extractAddress(result) {
      const comps = result.address_components;
      let prefecture = '', city = '', ward = '', town = '', sublocality = '', chome = '', banchi = '', route = '';
      for (const c of comps) {
        if (c.types.includes('administrative_area_level_1')) prefecture = c.long_name;
        if (c.types.includes('locality')) city = c.long_name;
        if (c.types.includes('sublocality_level_1') || c.types.includes('ward')) ward = c.long_name;
        if (c.types.includes('sublocality_level_2')) town = c.long_name;
        if (c.types.includes('sublocality_level_3')) sublocality = c.long_name;
        if (c.types.includes('sublocality_level_4')) chome = c.long_name;
        if (c.types.includes('premise')) banchi = c.long_name;
        if (c.types.includes('route')) route = c.long_name;
      }
      // 日本語住所: 区/市 + 町名 + 丁目 + 番地
      const area = ward || city || prefecture;
      const detail = [town, sublocality, chome, banchi].filter(Boolean).join('');
      if (area && detail) return area + ' ' + detail;
      if (area && route) return area + ' ' + route;
      if (area) return area;
      // フォールバック: formatted_address から郵便番号・国名を除去
      return result.formatted_address
        .replace(/〒\d{3}-?\d{4}\s*/, '')
        .replace(/、日本$/, '').replace(/^日本、\s*/, '')
        .replace(/^日本\s*/, '');
    }

    map.addListener('click', (e) => {
      const lat = e.latLng.lat();
      const lng = e.latLng.lng();
      marker.setPosition(e.latLng);
      marker.setVisible(true);

      // 逆ジオコーディング
      const geocoder = new google.maps.Geocoder();
      geocoder.geocode({ location: { lat, lng } }, (results, status) => {
        if (status === 'OK' && results && results.length > 0) {
          // 最も詳細な結果を選択（street_address > route > sublocality > locality）
          const preferred = results.find(r => r.types.includes('street_address'))
            || results.find(r => r.types.includes('premise'))
            || results.find(r => r.types.includes('sublocality_level_3') || r.types.includes('sublocality_level_2'))
            || results.find(r => r.types.includes('route'))
            || results[0];
          const addr = _extractAddress(preferred);
          const coordsKey = mapPickerField === 'pickup' ? 'pickupCoords' : 'dropoffCoords';
          setAddForm(f => ({ ...f, [mapPickerField]: addr }));
          setAddCoords(c => ({ ...c, [coordsKey]: { lat, lng } }));
        } else {
          // Nominatimフォールバック
          fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=ja`)
            .then(r => r.json()).then(data => {
              const a = data.address || {};
              const parts = [a.city || a.town || a.village || '', a.suburb || a.neighbourhood || a.quarter || '', a.road || '', a.house_number || ''].filter(Boolean);
              const addr = parts.join(' ') || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
              const coordsKey = mapPickerField === 'pickup' ? 'pickupCoords' : 'dropoffCoords';
              setAddForm(f => ({ ...f, [mapPickerField]: addr }));
              setAddCoords(c => ({ ...c, [coordsKey]: { lat, lng } }));
            }).catch(() => {
              const coordsKey = mapPickerField === 'pickup' ? 'pickupCoords' : 'dropoffCoords';
              setAddForm(f => ({ ...f, [mapPickerField]: `${lat.toFixed(6)}, ${lng.toFixed(6)}` }));
              setAddCoords(c => ({ ...c, [coordsKey]: { lat, lng } }));
            });
        }
      });
    });

    return () => { mapPickerInstanceRef.current = null; mapPickerMarkerRef.current = null; };
  }, [mapPickerField]);

  // 編集用マップピッカーの初期化・クリックハンドラ
  useEffect(() => {
    if (!editMapPickerField || !editMapPickerRef.current || !window.google || !window.google.maps) return;
    setTimeout(() => { editMapPickerRef.current && editMapPickerRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' }); }, 100);
    const center = APP_CONSTANTS.DEFAULT_MAP_CENTER;
    const map = new google.maps.Map(editMapPickerRef.current, {
      center, zoom: 13, mapTypeId: 'roadmap', disableDefaultUI: true,
      zoomControl: true, fullscreenControl: false, mapTypeControl: false,
    });
    editMapPickerInstanceRef.current = map;
    const marker = new google.maps.Marker({ map, position: center, visible: false });
    editMapPickerMarkerRef.current = marker;

    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const currentPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
          map.setCenter(currentPos);
          map.setZoom(13);
          new google.maps.Marker({ map, position: currentPos, icon: { path: google.maps.SymbolPath.CIRCLE, scale: 8, fillColor: '#4285F4', fillOpacity: 1, strokeColor: '#fff', strokeWeight: 2 }, title: '現在地', clickable: false });
        },
        () => {},
        { enableHighAccuracy: true, timeout: 5000, maximumAge: 10000 }
      );
    }

    function _extractAddress(result) {
      const comps = result.address_components;
      let prefecture = '', city = '', ward = '', town = '', sublocality = '', chome = '', banchi = '', route = '';
      for (const c of comps) {
        if (c.types.includes('administrative_area_level_1')) prefecture = c.long_name;
        if (c.types.includes('locality')) city = c.long_name;
        if (c.types.includes('sublocality_level_1') || c.types.includes('ward')) ward = c.long_name;
        if (c.types.includes('sublocality_level_2')) town = c.long_name;
        if (c.types.includes('sublocality_level_3')) sublocality = c.long_name;
        if (c.types.includes('sublocality_level_4')) chome = c.long_name;
        if (c.types.includes('premise')) banchi = c.long_name;
        if (c.types.includes('route')) route = c.long_name;
      }
      const area = ward || city || prefecture;
      const detail = [town, sublocality, chome, banchi].filter(Boolean).join('');
      if (area && detail) return area + ' ' + detail;
      if (area && route) return area + ' ' + route;
      if (area) return area;
      return result.formatted_address
        .replace(/〒\d{3}-?\d{4}\s*/, '')
        .replace(/、日本$/, '').replace(/^日本、\s*/, '')
        .replace(/^日本\s*/, '');
    }

    map.addListener('click', (e) => {
      const lat = e.latLng.lat();
      const lng = e.latLng.lng();
      marker.setPosition(e.latLng);
      marker.setVisible(true);

      const geocoder = new google.maps.Geocoder();
      geocoder.geocode({ location: { lat, lng } }, (results, status) => {
        if (status === 'OK' && results && results.length > 0) {
          const preferred = results.find(r => r.types.includes('street_address'))
            || results.find(r => r.types.includes('premise'))
            || results.find(r => r.types.includes('sublocality_level_3') || r.types.includes('sublocality_level_2'))
            || results.find(r => r.types.includes('route'))
            || results[0];
          const addr = _extractAddress(preferred);
          setEditForm(f => ({ ...f, pickup: addr }));
        } else {
          fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=ja`)
            .then(r => r.json()).then(data => {
              const a = data.address || {};
              const parts = [a.city || a.town || a.village || '', a.suburb || a.neighbourhood || a.quarter || '', a.road || '', a.house_number || ''].filter(Boolean);
              const addr = parts.join(' ') || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
              setEditForm(f => ({ ...f, pickup: addr }));
            }).catch(() => {
              setEditForm(f => ({ ...f, pickup: `${lat.toFixed(6)}, ${lng.toFixed(6)}` }));
            });
        }
      });
    });

    return () => { editMapPickerInstanceRef.current = null; editMapPickerMarkerRef.current = null; };
  }, [editMapPickerField]);

  // 手動追加
  const handleManualAdd = useCallback(() => {
    setAddErrors([]);
    const formWithCoords = { ...addForm, pickupCoords: addCoords.pickupCoords, dropoffCoords: addCoords.dropoffCoords };
    const result = DataService.addEntry(formWithCoords);
    if (!result.success) { setAddErrors(result.errors); return; }
    setAddForm({ date: todayDefault, weather: addForm.weather, amount: '', pickup: '', pickupTime: '', dropoff: '', dropoffTime: '', passengers: '1', gender: '', purpose: '', memo: '', source: '' });
    setAddCoords({ pickupCoords: null, dropoffCoords: null });
    setMapPickerField(null);
    setShowAddForm(false);
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
    setRefreshKey(k => k + 1);
  }, [addForm, addCoords, todayDefault]);

  // 音声入力トグル
  const toggleVoiceInput = useCallback(() => {
    if (isListening && recognitionRef.current) {
      recognitionRef.current.stop();
      setIsListening(false);
      return;
    }
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) return;
    const recognition = new SpeechRecognition();
    recognition.lang = 'ja-JP';
    recognition.continuous = false;
    recognition.interimResults = true;
    recognition.maxAlternatives = 1;
    // 認識済みテキストを蓄積（onresultは複数回呼ばれる可能性）
    let accumulatedFinal = '';
    recognition.onresult = (event) => {
      let interimTranscript = '';
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const transcript = event.results[i][0].transcript;
        if (event.results[i].isFinal) {
          accumulatedFinal += transcript;
        } else {
          interimTranscript += transcript;
        }
      }
      setInterimText(interimTranscript || accumulatedFinal);
    };
    recognition.onend = () => {
      setIsListening(false);
      if (accumulatedFinal) {
        console.log('[Voice] 認識テキスト:', accumulatedFinal);
        const parsed = parseVoiceInput(accumulatedFinal);
        console.log('[Voice] パース結果:', JSON.stringify(parsed));
        setAddForm(f => {
          const updated = { ...f };
          if (parsed.amount) updated.amount = parsed.amount;
          if (parsed.weather) updated.weather = parsed.weather;
          if (parsed.passengers) updated.passengers = parsed.passengers;
          if (parsed.gender) updated.gender = parsed.gender;
          if (parsed.source) updated.source = parsed.source;
          if (parsed.purpose) updated.purpose = parsed.purpose;
          if (parsed.pickup) updated.pickup = parsed.pickup;
          if (parsed.dropoff) updated.dropoff = parsed.dropoff;
          if (parsed.memo && !f.memo) updated.memo = parsed.memo;
          // 日付未設定なら今日
          if (!f.date) updated.date = new Date().toISOString().split('T')[0];
          // 乗車時刻未設定なら現在時刻
          if (!f.pickupTime) {
            const now = new Date();
            updated.pickupTime = String(now.getHours()).padStart(2, '0') + ':' + String(now.getMinutes()).padStart(2, '0');
          }
          return updated;
        });
        setVoiceSuccess(true);
        setTimeout(() => setVoiceSuccess(false), 1500);
        setInterimText('');
      } else {
        setInterimText('');
      }
    };
    recognition.onerror = (e) => {
      console.warn('[Voice] エラー:', e.error);
      setIsListening(false);
      setInterimText('');
    };
    recognitionRef.current = recognition;
    try {
      recognition.start();
      setIsListening(true);
      setInterimText('');
    } catch (e) {
      console.warn('[Voice] 開始エラー:', e);
      setIsListening(false);
    }
  }, [isListening]);

  // 音声認識クリーンアップ
  useEffect(() => {
    return () => { if (recognitionRef.current) { try { recognitionRef.current.abort(); } catch(e) {} } };
  }, []);

  // 検索フィルター
  const filteredRevenue = useMemo(() => {
    if (!search) return revenueEntries;
    const q = search.toLowerCase();
    return revenueEntries.filter(e =>
      (e.pickup || '').toLowerCase().includes(q) || (e.dropoff || '').toLowerCase().includes(q) ||
      (e.date || '').includes(q) || (e.memo || '').toLowerCase().includes(q) ||
      String(e.amount).includes(q)
    );
  }, [revenueEntries, search]);

  const filteredRival = useMemo(() => {
    if (!search) return rivalEntries;
    const q = search.toLowerCase();
    return rivalEntries.filter(e =>
      (e.location || '').toLowerCase().includes(q) || (e.date || '').includes(q) ||
      (e.memo || '').toLowerCase().includes(q)
    );
  }, [rivalEntries, search]);

  // 天候選択肢
  const weatherOptions = ['', '晴れ', '曇り', '雨', '雪'];

  // 共通入力フィールド生成
  const field = (label, key, type, opts) => {
    const val = editForm[key] || '';
    return React.createElement('div', { key, style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '6px' } },
      React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', minWidth: '56px', textAlign: 'right' } }, label),
      type === 'select'
        ? React.createElement('select', {
            value: val,
            onChange: e => setEditForm(f => ({ ...f, [key]: e.target.value })),
            style: { flex: 1, padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px' },
          }, (opts || []).map(o => React.createElement('option', { key: o, value: o }, o || '未設定')))
        : React.createElement('input', {
            type: type || 'text',
            value: val,
            onChange: e => setEditForm(f => ({ ...f, [key]: e.target.value })),
            style: { flex: 1, padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px' },
          })
    );
  };

  // 編集フォーム
  const editPanel = (type) => {
    if (!editingId) return null;
    return React.createElement('div', {
      style: { background: 'rgba(26,115,232,0.08)', border: '1px solid rgba(26,115,232,0.3)', borderRadius: '10px', padding: '14px', marginBottom: '12px' },
    },
      React.createElement('div', { style: { fontWeight: 600, fontSize: '13px', marginBottom: '10px', display: 'flex', alignItems: 'center', gap: '6px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: 'var(--color-primary-light)' } }, 'edit'),
        'データ編集'
      ),
      type === 'revenue' ? React.createElement(React.Fragment, null,
        field('金額', 'amount', 'number'),
        field('日付', 'date', 'date'),
        field('天候', 'weather', 'select', weatherOptions),
        React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '6px' } },
          React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', minWidth: '56px', textAlign: 'right' } }, '乗車地'),
          React.createElement('div', { style: { flex: 1 } },
            React.createElement('div', { style: { display: 'flex', gap: '4px' } },
              React.createElement('input', { type: 'text', value: editForm.pickup || '', onChange: e => setEditForm(f => ({ ...f, pickup: e.target.value })), style: { flex: 1, padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px' } }),
              React.createElement('button', {
                onClick: () => setEditMapPickerField(editMapPickerField === 'pickup' ? null : 'pickup'),
                style: { padding: '6px 10px', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '12px', fontWeight: 600, display: 'flex', alignItems: 'center', gap: '3px', background: editMapPickerField === 'pickup' ? 'var(--color-primary)' : 'var(--bg-tertiary)', color: editMapPickerField === 'pickup' ? '#fff' : 'var(--text-secondary)', whiteSpace: 'nowrap' },
              }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'map'), '地図')
            ),
            editMapPickerField === 'pickup' && React.createElement('div', { style: { marginTop: '6px' } },
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '4px', fontSize: '11px', color: 'var(--color-primary-light)' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'touch_app'),
                '地図をタップして乗車地を選択'
              ),
              (window.google && window.google.maps)
                ? React.createElement('div', { ref: editMapPickerRef, style: { width: '100%', height: '660px', borderRadius: '8px', border: '2px solid var(--color-primary)', overflow: 'hidden' } })
                : React.createElement('div', { style: { padding: '20px', textAlign: 'center', color: 'var(--text-muted)', fontSize: '12px', background: 'var(--bg-tertiary)', borderRadius: '8px' } }, 'Google Maps APIキーを設定してください')
            )
          )
        ),
        field('乗車時刻', 'pickupTime', 'time'),
        field('降車地', 'dropoff', 'text'),
        field('降車時刻', 'dropoffTime', 'time'),
        field('人数', 'passengers', 'number'),
        field('性別', 'gender', 'select', ['', '男性', '女性', 'その他']),
        field('目的', 'purpose', 'text'),
        field('配車方法', 'source', 'select', ['', 'Go', 'Uber', 'DIDI', '電話', '流し']),
        field('メモ', 'memo', 'text')
      ) : React.createElement(React.Fragment, null,
        field('日付', 'date', 'date'),
        field('時刻', 'time', 'time'),
        field('天候', 'weather', 'select', weatherOptions),
        field('場所', 'location', 'text'),
        field('メモ', 'memo', 'text')
      ),
      errors.length > 0 && React.createElement('div', { style: { color: 'var(--color-danger)', fontSize: '12px', marginTop: '6px' } },
        errors.join(', ')
      ),
      React.createElement('div', { style: { display: 'flex', gap: '8px', marginTop: '10px', justifyContent: 'flex-end' } },
        React.createElement(Button, { variant: 'ghost', onClick: () => { setEditingId(null); setErrors([]); setEditMapPickerField(null); } }, 'キャンセル'),
        React.createElement(Button, { icon: 'save', onClick: saveEdit }, '保存')
      )
    );
  };

  // 売上エントリ行
  const revenueRow = (entry) => {
    const isEditing = editingId === entry.id;
    const isConfirm = confirmDelete === entry.id;
    const eDate = entry.date || new Date(entry.timestamp).toISOString().split('T')[0];
    const info = entry.dayOfWeek ? { dayOfWeek: entry.dayOfWeek, holiday: entry.holiday, isSunday: entry.dayOfWeek === '日', isSaturday: entry.dayOfWeek === '土', isHoliday: !!entry.holiday } : JapaneseHolidays.getDateInfo(eDate);
    const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-muted)';

    return React.createElement('div', { key: entry.id },
      isEditing && editPanel('revenue'),
      React.createElement('div', {
        style: { display: 'flex', alignItems: 'center', padding: '10px 0', borderBottom: '1px solid rgba(255,255,255,0.06)', opacity: isEditing ? 0.5 : 1 },
      },
        React.createElement('div', { style: { flex: 1, minWidth: 0 } },
          React.createElement('div', { style: { fontWeight: 500, display: 'flex', alignItems: 'center', gap: '4px', flexWrap: 'wrap', fontSize: '13px' } },
            entry.pickupTime && React.createElement('span', { style: { fontSize: '10px', color: 'var(--color-primary-light)', fontWeight: 600, padding: '1px 5px', borderRadius: '3px', background: 'rgba(26,115,232,0.12)' } }, entry.pickupTime),
            React.createElement('span', null, entry.pickup || '---'),
            React.createElement('span', { style: { color: 'var(--text-muted)', margin: '0 2px' } }, '→'),
            entry.dropoffTime && React.createElement('span', { style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: 600, padding: '1px 5px', borderRadius: '3px', background: 'rgba(0,200,83,0.12)' } }, entry.dropoffTime),
            React.createElement('span', null, entry.dropoff || '---')
          ),
          React.createElement('div', { style: { fontSize: '11px', color: 'var(--text-muted)', display: 'flex', flexWrap: 'wrap', gap: '4px', marginTop: '2px' } },
            React.createElement('span', null, eDate),
            React.createElement('span', { style: { color: dayColor, fontWeight: 600 } }, `(${info.dayOfWeek})`),
            info.holiday && React.createElement('span', { style: { color: '#ef4444', fontSize: '10px', padding: '1px 5px', borderRadius: '3px', background: 'rgba(239,68,68,0.1)' } }, info.holiday),
            entry.weather && React.createElement('span', null, entry.weather),
            entry.passengers && React.createElement('span', { style: { fontSize: '10px', padding: '1px 4px', borderRadius: '3px', background: 'rgba(255,255,255,0.08)' } }, `${entry.passengers}名`),
            entry.source && React.createElement('span', { style: { fontSize: '10px', padding: '1px 4px', borderRadius: '3px', background: 'rgba(255,152,0,0.15)', color: '#ffb74d', fontWeight: 600 } }, entry.source),
            entry.memo && React.createElement('span', { style: { color: 'var(--text-muted)' } }, `| ${entry.memo}`)
          )
        ),
        React.createElement('div', { style: { marginRight: '8px', whiteSpace: 'nowrap', textAlign: 'right' } },
          entry.noPassenger
            ? React.createElement('div', { style: { fontWeight: 700, color: '#d32f2f', fontSize: '15px' } }, '¥0（待機）')
            : React.createElement('div', { style: { fontWeight: 700, color: 'var(--color-secondary)', fontSize: '15px' } }, `¥${entry.amount.toLocaleString()}`),
          !entry.noPassenger && React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(entry.amount / 1.1).toLocaleString()} 税¥${(entry.amount - Math.floor(entry.amount / 1.1)).toLocaleString()}`)
        ),
        React.createElement('button', {
          onClick: () => startEdit(entry, 'revenue'),
          style: { background: 'none', border: 'none', cursor: 'pointer', color: 'var(--color-primary-light)', padding: '4px' },
          title: '編集',
        }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, 'edit')),
        React.createElement('button', {
          onClick: () => handleDelete(entry.id),
          style: { background: 'none', border: 'none', cursor: 'pointer', color: isConfirm ? 'var(--color-danger)' : 'var(--text-muted)', padding: '4px' },
          title: isConfirm ? 'もう一度押して削除' : '削除',
        }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, isConfirm ? 'delete_forever' : 'delete_outline'))
      )
    );
  };

  // 他社エントリ行
  const rivalRow = (entry) => {
    const isEditing = editingId === entry.id;
    const isConfirm = confirmDelete === entry.id;
    const info = entry.dayOfWeek ? { dayOfWeek: entry.dayOfWeek, holiday: entry.holiday, isSunday: entry.dayOfWeek === '日', isSaturday: entry.dayOfWeek === '土', isHoliday: !!entry.holiday } : JapaneseHolidays.getDateInfo(entry.date);
    const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-muted)';

    return React.createElement('div', { key: entry.id },
      isEditing && editPanel('rival'),
      React.createElement('div', {
        style: { display: 'flex', alignItems: 'center', padding: '10px 0', borderBottom: '1px solid rgba(255,255,255,0.06)', opacity: isEditing ? 0.5 : 1 },
      },
        React.createElement('div', { style: { flex: 1, minWidth: 0 } },
          React.createElement('div', { style: { fontWeight: 500, display: 'flex', alignItems: 'center', gap: '6px', fontSize: '13px' } },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: 'var(--color-primary-light)' } }, 'local_taxi'),
            React.createElement('span', null, entry.location || '---')
          ),
          React.createElement('div', { style: { fontSize: '11px', color: 'var(--text-muted)', display: 'flex', flexWrap: 'wrap', gap: '4px', marginTop: '2px' } },
            React.createElement('span', null, entry.date),
            React.createElement('span', { style: { color: dayColor, fontWeight: 600 } }, `(${info.dayOfWeek})`),
            info.holiday && React.createElement('span', { style: { color: '#ef4444', fontSize: '10px', padding: '1px 5px', borderRadius: '3px', background: 'rgba(239,68,68,0.1)' } }, info.holiday),
            entry.time && React.createElement('span', { style: { fontSize: '11px', color: 'var(--color-primary-light)', fontWeight: 600, padding: '1px 5px', borderRadius: '3px', background: 'rgba(26,115,232,0.12)' } }, entry.time),
            entry.weather && React.createElement('span', null, entry.weather),
            entry.memo && React.createElement('span', { style: { color: 'var(--text-muted)' } }, `| ${entry.memo}`)
          )
        ),
        React.createElement('button', {
          onClick: () => startEdit(entry, 'rival'),
          style: { background: 'none', border: 'none', cursor: 'pointer', color: 'var(--color-primary-light)', padding: '4px' },
          title: '編集',
        }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, 'edit')),
        React.createElement('button', {
          onClick: () => handleDelete(entry.id),
          style: { background: 'none', border: 'none', cursor: 'pointer', color: isConfirm ? 'var(--color-danger)' : 'var(--text-muted)', padding: '4px' },
          title: isConfirm ? 'もう一度押して削除' : '削除',
        }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, isConfirm ? 'delete_forever' : 'delete_outline'))
      )
    );
  };

  // 交通情報カテゴリラベル
  const transitLabels = { trouble: '遅延・運休情報', train: '電車情報', bus: 'バス情報', flight: 'フライト情報' };
  const transitIcons = { trouble: 'warning', train: 'train', bus: 'directions_bus', flight: 'flight' };

  return React.createElement('div', null,
    // タブバー
    React.createElement('div', { style: { display: 'flex', gap: '4px', marginBottom: '16px', overflowX: 'auto', paddingBottom: '4px' } },
      tabs.map(t => React.createElement('button', {
        key: t.id,
        onClick: () => { setTab(t.id); setEditingId(null); setErrors([]); setSearch(''); },
        style: {
          display: 'flex', alignItems: 'center', gap: '4px', padding: '8px 14px',
          borderRadius: '8px', border: 'none', cursor: 'pointer', fontSize: '12px', fontWeight: 600,
          background: tab === t.id ? 'var(--color-primary)' : 'var(--bg-tertiary)',
          color: tab === t.id ? '#fff' : 'var(--text-secondary)',
          whiteSpace: 'nowrap', transition: 'all 0.2s',
        },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, t.icon),
        t.label
      ))
    ),

    // 検索バー（売上・他社タブ）
    tab !== 'transit' && React.createElement('div', { style: { marginBottom: '12px' } },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', background: 'var(--bg-tertiary)', borderRadius: '8px', padding: '8px 12px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--text-muted)' } }, 'search'),
        React.createElement('input', {
          type: 'text', value: search, placeholder: '検索...',
          onChange: e => setSearch(e.target.value),
          style: { flex: 1, border: 'none', background: 'transparent', color: 'var(--text-primary)', fontSize: '13px', outline: 'none' },
        }),
        search && React.createElement('button', {
          onClick: () => setSearch(''),
          style: { background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-muted)', padding: '2px' },
        }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'close'))
      )
    ),

    // 保存成功バナー
    saved && React.createElement('div', {
      style: { background: 'rgba(0,200,83,0.15)', border: '1px solid rgba(0,200,83,0.3)', borderRadius: '8px', padding: '10px 14px', marginBottom: '12px', display: 'flex', alignItems: 'center', gap: '8px', fontSize: '13px', color: 'var(--color-accent)' },
    },
      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, 'check_circle'),
      '保存しました'
    ),

    // === 売上記録タブ ===
    tab === 'revenue' && React.createElement(React.Fragment, null,
      // 手動追加ボタン / フォーム
      !showAddForm
        ? React.createElement('div', { style: { marginBottom: '12px', display: 'flex', gap: '8px' } },
            React.createElement(Button, {
              icon: 'add', onClick: () => setShowAddForm(true),
              style: { flex: 1, padding: '10px', fontSize: '13px', fontWeight: 600 },
            }, '手動で売上を追加'),
            React.createElement('button', {
              onClick: () => {
                setShowAddForm(true);
                // フォームを開いてから乗客なしモードであることを示す
                // ユーザーが乗車地・乗車時刻を入力後に降車地欄の「乗客なし」ボタンで保存
              },
              style: { display: 'flex', alignItems: 'center', gap: '6px', padding: '10px 16px', borderRadius: '8px', border: 'none', cursor: 'pointer', fontSize: '13px', fontWeight: 700, background: '#d32f2f', color: '#fff', whiteSpace: 'nowrap' },
            },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, 'person_off'),
              '乗客なし'
            )
          )
        : React.createElement('div', {
            style: { background: 'rgba(0,200,83,0.08)', border: '1px solid rgba(0,200,83,0.3)', borderRadius: '10px', padding: '14px', marginBottom: '12px' },
          },
            React.createElement('div', { style: { fontWeight: 600, fontSize: '13px', marginBottom: '10px', display: 'flex', alignItems: 'center', gap: '6px' } },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: 'var(--color-accent)' } }, 'add_circle'),
              '売上を手動入力',
              speechSupported.current && React.createElement('button', {
                onClick: toggleVoiceInput,
                style: {
                  marginLeft: 'auto', padding: '4px 10px', borderRadius: '16px', border: 'none', cursor: 'pointer',
                  display: 'flex', alignItems: 'center', gap: '4px', fontSize: '12px', fontWeight: 600,
                  background: isListening ? 'rgba(244,67,54,0.9)' : voiceSuccess ? 'rgba(0,200,83,0.9)' : 'var(--bg-tertiary)',
                  color: (isListening || voiceSuccess) ? '#fff' : 'var(--text-secondary)',
                  animation: isListening ? 'voicePulse 1.2s infinite' : 'none',
                  transition: 'background 0.2s, color 0.2s',
                },
              },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, voiceSuccess ? 'check_circle' : 'mic'),
                isListening ? '録音中…' : voiceSuccess ? '入力完了' : '音声'
              )
            ),
            isListening && interimText && React.createElement('div', {
              style: { padding: '8px 12px', marginBottom: '8px', borderRadius: '8px', background: 'rgba(244,67,54,0.1)', border: '1px solid rgba(244,67,54,0.3)', fontSize: '13px', color: 'var(--text-primary)' },
            }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px', verticalAlign: 'middle', marginRight: '6px', color: 'rgba(244,67,54,0.8)' } }, 'hearing'), interimText),
            React.createElement('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '6px' } },
              React.createElement('div', { style: { gridColumn: '1 / -1' } },
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '金額 *'),
                React.createElement('input', { type: 'number', value: addForm.amount, placeholder: '例: 3500', onChange: e => setAddForm(f => ({ ...f, amount: e.target.value })), style: { width: '100%', padding: '8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '15px', fontWeight: 700, boxSizing: 'border-box' } })
              ),
              React.createElement('div', null,
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '日付'),
                React.createElement('input', { type: 'date', value: addForm.date, onChange: e => setAddForm(f => ({ ...f, date: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } })
              ),
              React.createElement('div', null,
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '天候'),
                React.createElement('select', { value: addForm.weather, onChange: e => setAddForm(f => ({ ...f, weather: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } },
                  ['', '晴れ', '曇り', '雨', '雪'].map(o => React.createElement('option', { key: o, value: o }, o || '未設定'))
                )
              ),
              React.createElement('div', { style: { gridColumn: '1 / -1' } },
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '乗車地'),
                React.createElement('div', { style: { display: 'flex', gap: '4px' } },
                  React.createElement('input', { type: 'text', value: addForm.pickup, placeholder: '地図をクリックまたは手入力', onChange: e => setAddForm(f => ({ ...f, pickup: e.target.value })), style: { flex: 1, padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } }),
                  React.createElement('button', {
                    onClick: () => setMapPickerField(mapPickerField === 'pickup' ? null : 'pickup'),
                    style: { padding: '6px 10px', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '12px', fontWeight: 600, display: 'flex', alignItems: 'center', gap: '3px', background: mapPickerField === 'pickup' ? 'var(--color-primary)' : 'var(--bg-tertiary)', color: mapPickerField === 'pickup' ? '#fff' : 'var(--text-secondary)', whiteSpace: 'nowrap' },
                  }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'map'), '地図')
                ),
                addCoords.pickupCoords && React.createElement('div', { style: { fontSize: '10px', color: 'var(--color-accent)', marginTop: '2px' } }, `${addCoords.pickupCoords.lat.toFixed(5)}, ${addCoords.pickupCoords.lng.toFixed(5)}`)
              ),
              // 乗車地マップピッカー
              mapPickerField === 'pickup' && React.createElement('div', { style: { gridColumn: '1 / -1' } },
                React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '4px', fontSize: '11px', color: 'var(--color-primary-light)' } },
                  React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'touch_app'),
                  '地図をタップして乗車地を選択'
                ),
                (window.google && window.google.maps)
                  ? React.createElement('div', { ref: mapPickerRef, style: { width: '100%', height: '660px', borderRadius: '8px', border: '2px solid var(--color-primary)', overflow: 'hidden' } })
                  : React.createElement('div', { style: { padding: '20px', textAlign: 'center', color: 'var(--text-muted)', fontSize: '12px', background: 'var(--bg-tertiary)', borderRadius: '8px' } }, 'Google Maps APIキーを設定してください')
              ),
              React.createElement('div', null,
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '乗車時刻'),
                React.createElement('input', { type: 'time', value: addForm.pickupTime, onChange: e => setAddForm(f => ({ ...f, pickupTime: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } })
              ),
              React.createElement('div', { style: { gridColumn: '1 / -1' } },
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '降車地'),
                React.createElement('div', { style: { display: 'flex', gap: '4px' } },
                  React.createElement('input', { type: 'text', value: addForm.dropoff, placeholder: '地図をクリックまたは手入力', onChange: e => setAddForm(f => ({ ...f, dropoff: e.target.value })), style: { flex: 1, padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } }),
                  React.createElement('button', {
                    onClick: () => setMapPickerField(mapPickerField === 'dropoff' ? null : 'dropoff'),
                    style: { padding: '6px 10px', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '12px', fontWeight: 600, display: 'flex', alignItems: 'center', gap: '3px', background: mapPickerField === 'dropoff' ? 'var(--color-secondary)' : 'var(--bg-tertiary)', color: mapPickerField === 'dropoff' ? '#fff' : 'var(--text-secondary)', whiteSpace: 'nowrap' },
                  }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'map'), '地図'),
                  React.createElement('button', {
                    onClick: () => {
                      const now = new Date();
                      const hh = String(now.getHours()).padStart(2, '0');
                      const mm = String(now.getMinutes()).padStart(2, '0');
                      const dropoffTime = `${hh}:${mm}`;
                      const formData = {
                        ...addForm,
                        dropoffTime,
                        amount: '0',
                        passengers: '0',
                        noPassenger: true,
                        pickupCoords: addCoords.pickupCoords,
                        dropoffCoords: addCoords.dropoffCoords,
                      };
                      const result = DataService.addEntry(formData);
                      if (result.success) {
                        setAddForm({ date: todayDefault, weather: addForm.weather, amount: '', pickup: '', pickupTime: '', dropoff: '', dropoffTime: '', passengers: '1', gender: '', purpose: '', memo: '', source: '' });
                        setAddCoords({ pickupCoords: null, dropoffCoords: null });
                        setMapPickerField(null);
                        setShowAddForm(false);
                        setSaved(true);
                        setTimeout(() => setSaved(false), 2000);
                        setRefreshKey(k => k + 1);
                      } else {
                        setAddErrors(result.errors);
                      }
                    },
                    style: { padding: '6px 10px', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '12px', fontWeight: 600, display: 'flex', alignItems: 'center', gap: '3px', background: '#d32f2f', color: '#fff', whiteSpace: 'nowrap' },
                  }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'person_off'), '乗客なし')
                ),
                addCoords.dropoffCoords && React.createElement('div', { style: { fontSize: '10px', color: 'var(--color-accent)', marginTop: '2px' } }, `${addCoords.dropoffCoords.lat.toFixed(5)}, ${addCoords.dropoffCoords.lng.toFixed(5)}`)
              ),
              // 降車地マップピッカー
              mapPickerField === 'dropoff' && React.createElement('div', { style: { gridColumn: '1 / -1' } },
                React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '4px', fontSize: '11px', color: 'var(--color-secondary)' } },
                  React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'touch_app'),
                  '地図をタップして降車地を選択'
                ),
                (window.google && window.google.maps)
                  ? React.createElement('div', { ref: mapPickerRef, style: { width: '100%', height: '660px', borderRadius: '8px', border: '2px solid var(--color-secondary)', overflow: 'hidden' } })
                  : React.createElement('div', { style: { padding: '20px', textAlign: 'center', color: 'var(--text-muted)', fontSize: '12px', background: 'var(--bg-tertiary)', borderRadius: '8px' } }, 'Google Maps APIキーを設定してください')
              ),
              React.createElement('div', null,
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '降車時刻'),
                React.createElement('input', { type: 'time', value: addForm.dropoffTime, onChange: e => setAddForm(f => ({ ...f, dropoffTime: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } })
              ),
              React.createElement('div', null,
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '人数'),
                React.createElement('input', { type: 'number', value: addForm.passengers, min: 1, max: 9, onChange: e => setAddForm(f => ({ ...f, passengers: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } })
              ),
              React.createElement('div', null,
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '性別'),
                React.createElement('select', { value: addForm.gender, onChange: e => setAddForm(f => ({ ...f, gender: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } },
                  ['', '男性', '女性', 'その他'].map(o => React.createElement('option', { key: o, value: o }, o || '未設定'))
                )
              ),
              React.createElement('div', null,
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '配車方法'),
                React.createElement('select', { value: addForm.source, onChange: e => setAddForm(f => ({ ...f, source: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } },
                  ['', 'Go', 'Uber', 'DIDI', '電話', '流し'].map(o => React.createElement('option', { key: o, value: o }, o || '未設定'))
                )
              ),
              React.createElement('div', { style: { gridColumn: '1 / -1' } },
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '4px' } }, '用途'),
                React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
                  ...[
                    { value: '通勤', icon: '🏢' },
                    { value: '通院', icon: '🏥' },
                    { value: '買物', icon: '🛒' },
                    { value: '観光', icon: '📸' },
                    { value: '出張', icon: '💼' },
                    { value: '送迎', icon: '🚗' },
                    { value: '空港', icon: '✈️' },
                    { value: '飲食', icon: '🍺' },
                    { value: 'その他', icon: '📝' },
                  ].map(p =>
                    React.createElement('button', {
                      key: p.value,
                      type: 'button',
                      onClick: () => setAddForm(f => ({ ...f, purpose: f.purpose === p.value ? '' : p.value })),
                      style: {
                        display: 'flex', alignItems: 'center', gap: '4px',
                        padding: '6px 10px', borderRadius: '8px',
                        fontSize: '12px', fontWeight: addForm.purpose === p.value ? '700' : '400',
                        cursor: 'pointer',
                        border: addForm.purpose === p.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                        background: addForm.purpose === p.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                        color: addForm.purpose === p.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                        transition: 'all 0.15s ease',
                      },
                    },
                      React.createElement('span', { style: { fontSize: '14px' } }, p.icon),
                      p.value
                    )
                  )
                )
              ),
              React.createElement('div', { style: { gridColumn: '1 / -1' } },
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, 'メモ'),
                React.createElement('input', { type: 'text', value: addForm.memo, placeholder: '自由入力', onChange: e => setAddForm(f => ({ ...f, memo: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } })
              )
            ),
            addErrors.length > 0 && React.createElement('div', { style: { color: 'var(--color-danger)', fontSize: '12px', marginTop: '8px' } }, addErrors.join(', ')),
            React.createElement('div', { style: { display: 'flex', gap: '8px', marginTop: '12px', justifyContent: 'flex-end' } },
              React.createElement(Button, { variant: 'ghost', onClick: () => { if (recognitionRef.current && isListening) { recognitionRef.current.stop(); setIsListening(false); setInterimText(''); } setShowAddForm(false); setAddErrors([]); } }, 'キャンセル'),
              React.createElement(Button, { icon: 'save', onClick: handleManualAdd }, '記録を追加')
            )
          ),

      React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' } },
        React.createElement('div', { style: { fontSize: '13px', color: 'var(--text-secondary)' } },
          `${filteredRevenue.length}件${search ? ` (全${revenueEntries.length}件中)` : ''}`
        ),
        revenueEntries.length > 0 && React.createElement(Button, {
          variant: 'danger', icon: 'delete_forever',
          onClick: () => { if (confirm('全ての売上記録を削除しますか？この操作は取り消せません。')) { DataService.clearAllEntries(); setRefreshKey(k => k + 1); } },
          style: { padding: '5px 10px', fontSize: '11px' },
        }, '全削除')
      ),
      filteredRevenue.length === 0
        ? React.createElement('div', { style: { textAlign: 'center', padding: '40px 20px', color: 'var(--text-muted)' } },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '48px', opacity: 0.3, display: 'block', marginBottom: '8px' } }, 'receipt_long'),
            search ? '該当する記録がありません' : '売上記録がありません'
          )
        : React.createElement(Card, null, filteredRevenue.map(e => revenueRow(e)))
    ),

    // === 他社記録タブ ===
    tab === 'rival' && React.createElement(React.Fragment, null,
      React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' } },
        React.createElement('div', { style: { fontSize: '13px', color: 'var(--text-secondary)' } },
          `${filteredRival.length}件${search ? ` (全${rivalEntries.length}件中)` : ''}`
        ),
        rivalEntries.length > 0 && React.createElement(Button, {
          variant: 'danger', icon: 'delete_forever',
          onClick: () => { if (confirm('全ての他社乗車記録を削除しますか？この操作は取り消せません。')) { DataService.clearAllRivalEntries(); setRefreshKey(k => k + 1); } },
          style: { padding: '5px 10px', fontSize: '11px' },
        }, '全削除')
      ),
      filteredRival.length === 0
        ? React.createElement('div', { style: { textAlign: 'center', padding: '40px 20px', color: 'var(--text-muted)' } },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '48px', opacity: 0.3, display: 'block', marginBottom: '8px' } }, 'local_taxi'),
            search ? '該当する記録がありません' : '他社乗車記録がありません'
          )
        : React.createElement(Card, null, filteredRival.map(e => rivalRow(e)))
    ),

    // === 交通情報タブ ===
    tab === 'transit' && React.createElement(React.Fragment, null,
      React.createElement('div', { style: { fontSize: '13px', color: 'var(--text-secondary)', marginBottom: '12px' } },
        '保存済みの公共交通機関情報'
      ),
      Object.keys(transitData).length === 0
        ? React.createElement('div', { style: { textAlign: 'center', padding: '40px 20px', color: 'var(--text-muted)' } },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '48px', opacity: 0.3, display: 'block', marginBottom: '8px' } }, 'directions_transit'),
            '保存された交通情報がありません'
          )
        : React.createElement(Card, null,
            Object.entries(transitData).map(([key, val]) =>
              React.createElement('div', {
                key,
                style: { padding: '12px 0', borderBottom: '1px solid rgba(255,255,255,0.06)' },
              },
                React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '6px' } },
                  React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', fontWeight: 600, fontSize: '13px' } },
                    React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: key === 'trouble' ? 'var(--color-warning)' : 'var(--color-primary-light)' } }, transitIcons[key] || 'info'),
                    transitLabels[key] || key
                  ),
                  React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
                    val.fetchedAt && React.createElement('span', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, new Date(val.fetchedAt).toLocaleString('ja-JP')),
                    React.createElement('button', {
                      onClick: () => { if (confirm(`「${transitLabels[key] || key}」のデータを削除しますか？`)) deleteTransitCategory(key); },
                      style: { background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-muted)', padding: '4px' },
                      title: '削除',
                    }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, 'delete_outline'))
                  )
                ),
                val.text && React.createElement('div', {
                  style: { fontSize: '12px', color: 'var(--text-secondary)', lineHeight: 1.5, maxHeight: '120px', overflow: 'auto', padding: '8px', background: 'rgba(255,255,255,0.03)', borderRadius: '6px', whiteSpace: 'pre-wrap' },
                }, val.text.slice(0, 500) + (val.text.length > 500 ? '...' : ''))
              )
            )
          ),
      Object.keys(transitData).length > 0 && React.createElement('div', { style: { marginTop: '12px', display: 'flex', justifyContent: 'flex-end' } },
        React.createElement(Button, {
          variant: 'danger', icon: 'delete_forever',
          onClick: () => { if (confirm('全ての交通情報を削除しますか？')) { AppStorage.set(APP_CONSTANTS.STORAGE_KEYS.TRANSIT_INFO, {}); setRefreshKey(k => k + 1); } },
          style: { padding: '5px 10px', fontSize: '11px' },
        }, '全削除')
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/dev/Logs.jsx
// ============================================================
(function() {
// Logs.jsx - ログビューアページ
window.LogsPage = () => {
  const { useState, useMemo } = React;
  const { logs, clearLogs } = useLogContext();
  const [filter, setFilter] = useState('all');
  const [search, setSearch] = useState('');

  const filteredLogs = useMemo(() => {
    let result = [...logs].reverse();
    if (filter !== 'all') {
      result = result.filter(log => log.level === filter);
    }
    if (search) {
      const s = search.toLowerCase();
      result = result.filter(log => log.message.toLowerCase().includes(s));
    }
    return result;
  }, [logs, filter, search]);

  const counts = useMemo(() => ({
    all: logs.length,
    info: logs.filter(l => l.level === 'info').length,
    warn: logs.filter(l => l.level === 'warn').length,
    error: logs.filter(l => l.level === 'error').length,
    debug: logs.filter(l => l.level === 'debug').length,
  }), [logs]);

  const formatTime = (ts) => {
    const d = new Date(ts);
    return d.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  };

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'terminal'),
      'ログビューア'
    ),

    // フィルター
    React.createElement('div', {
      style: { display: 'flex', gap: '8px', marginBottom: 'var(--space-md)', flexWrap: 'wrap', alignItems: 'center' },
    },
      ['all', 'info', 'warn', 'error', 'debug'].map(level =>
        React.createElement('button', {
          key: level,
          className: `tab ${filter === level ? 'active' : ''}`,
          onClick: () => setFilter(level),
          style: { border: 'none', background: filter === level ? 'rgba(26,115,232,0.15)' : 'rgba(255,255,255,0.04)', borderRadius: '20px', padding: '4px 12px' },
        },
          `${level === 'all' ? '全て' : level.toUpperCase()} (${counts[level]})`
        )
      ),

      React.createElement('input', {
        className: 'form-input',
        type: 'text',
        placeholder: '検索...',
        value: search,
        onChange: (e) => setSearch(e.target.value),
        style: { maxWidth: '200px', padding: '4px 12px', marginLeft: 'auto' },
      }),

      React.createElement(Button, {
        variant: 'danger',
        icon: 'delete',
        onClick: clearLogs,
        style: { padding: '4px 12px', fontSize: '12px' },
      }, 'クリア')
    ),

    // ログ一覧
    React.createElement(Card, { style: { padding: 0, maxHeight: '600px', overflowY: 'auto' } },
      filteredLogs.length === 0
        ? React.createElement('div', {
            style: { padding: 'var(--space-2xl)', textAlign: 'center', color: 'var(--text-muted)' },
          }, 'ログはありません')
        : filteredLogs.map(log =>
            React.createElement('div', { key: log.id, className: 'dev-log-entry' },
              React.createElement('span', { className: 'dev-log-entry__time' }, formatTime(log.timestamp)),
              React.createElement('span', { className: `dev-log-entry__level dev-log-entry__level--${log.level}` },
                log.level.toUpperCase()
              ),
              React.createElement('span', { className: 'dev-log-entry__message' }, log.message)
            )
          )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/dev/Structure.jsx
// ============================================================
(function() {
// Structure.jsx - サイト構造ビューアページ
window.StructurePage = () => {
  const { useState } = React;

  const iconMap = {
    folder: { icon: 'folder', class: 'file-tree__icon--folder' },
    react: { icon: 'description', class: 'file-tree__icon--react' },
    js: { icon: 'javascript', class: 'file-tree__icon--js' },
    css: { icon: 'style', class: 'file-tree__icon--css' },
    html: { icon: 'html', class: 'file-tree__icon--html' },
    md: { icon: 'article', class: 'file-tree__icon--md' },
    file: { icon: 'insert_drive_file', class: 'file-tree__icon--file' },
  };

  const TreeNode = ({ node, depth = 0 }) => {
    const [expanded, setExpanded] = useState(depth < 2);
    const isFolder = node.type === 'folder';
    const iconInfo = iconMap[node.type] || iconMap.file;

    return React.createElement('div', { style: { marginLeft: `${depth * 16}px` } },
      React.createElement('div', {
        className: 'file-tree__item',
        onClick: isFolder ? () => setExpanded(!expanded) : undefined,
        style: { cursor: isFolder ? 'pointer' : 'default' },
      },
        isFolder && React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '14px', color: 'var(--text-muted)', transition: 'transform 0.15s', transform: expanded ? 'rotate(90deg)' : 'rotate(0)' },
        }, 'chevron_right'),

        React.createElement('span', {
          className: `material-icons-round file-tree__icon ${iconInfo.class}`,
        }, iconInfo.icon),

        React.createElement('span', {
          style: { color: isFolder ? 'var(--color-secondary)' : 'var(--text-primary)' },
        }, node.name),

        node.desc && React.createElement('span', {
          style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-xs)', marginLeft: '8px' },
        }, `— ${node.desc}`)
      ),

      isFolder && expanded && node.children && node.children.map((child, i) =>
        React.createElement(TreeNode, { key: i, node: child, depth: depth + 1 })
      )
    );
  };

  // ルート構造
  const routes = [
    { path: '/', page: 'dashboard', desc: 'ダッシュボード（ホーム画面）' },
    { path: '/map', page: 'map', desc: 'Google Maps + GPS地図表示' },
    { path: '/revenue', page: 'revenue', desc: '売上記録・管理' },
    { path: '/analytics', page: 'analytics', desc: '売上分析・統計' },
    { path: '/settings', page: 'settings', desc: '設定（APIキー設定含む）' },
    { path: '/dev', page: 'dev', desc: '開発者ツールハブ' },
    { path: '/dev/structure', page: 'dev-structure', desc: 'サイト構造ビューア（このページ）' },
    { path: '/dev/logs', page: 'dev-logs', desc: 'アプリケーションログ' },
    { path: '/dev/api-status', page: 'dev-api', desc: 'API接続ステータス' },
  ];

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'account_tree'),
      'サイト構造'
    ),

    // ルーティング一覧
    React.createElement(Card, {
      title: 'ページルーティング',
      subtitle: 'アプリ内のすべてのページとそのパス',
      style: { marginBottom: 'var(--space-lg)' },
    },
      React.createElement('div', { style: { display: 'grid', gap: '4px' } },
        routes.map((route, i) =>
          React.createElement('div', {
            key: i,
            style: {
              display: 'flex',
              alignItems: 'center',
              gap: '12px',
              padding: '8px 12px',
              borderRadius: '6px',
              background: 'rgba(255,255,255,0.02)',
              fontSize: 'var(--font-size-sm)',
            },
          },
            React.createElement('code', {
              style: { color: 'var(--color-primary-light)', fontFamily: 'monospace', minWidth: '160px' },
            }, route.path),
            React.createElement('span', {
              style: { color: 'var(--text-muted)', fontSize: '14px' },
            }, '→'),
            React.createElement('span', { style: { color: 'var(--text-secondary)' } }, route.desc)
          )
        )
      )
    ),

    // ファイルツリー
    React.createElement(Card, {
      title: 'ファイル構造',
      subtitle: 'プロジェクトのディレクトリ構造（クリックで展開/折りたたみ）',
    },
      React.createElement('div', { className: 'file-tree', style: { padding: '8px 0' } },
        React.createElement(TreeNode, { node: APP_CONSTANTS.SITE_STRUCTURE })
      )
    ),

    // コンポーネント依存関係
    React.createElement(Card, {
      title: 'コンポーネント階層',
      subtitle: 'Reactコンポーネントのツリー構造',
      style: { marginTop: 'var(--space-lg)' },
    },
      React.createElement('pre', {
        style: {
          fontFamily: 'monospace',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--text-secondary)',
          lineHeight: 1.8,
          overflowX: 'auto',
        },
      },
`App
├── AppProvider (グローバル状態)
│   ├── MapProvider (地図状態)
│   │   └── LogProvider (ログ状態)
│   │       └── Layout
│   │           ├── Header (ヘッダー)
│   │           ├── Sidebar (PC用サイドバー)
│   │           ├── BottomNav (モバイル用ナビ)
│   │           └── [CurrentPage]
│   │               ├── DashboardPage
│   │               ├── MapViewPage
│   │               │   ├── GoogleMapView
│   │               │   └── GpsTracker
│   │               ├── RevenuePage
│   │               ├── AnalyticsPage
│   │               ├── SettingsPage
│   │               └── DevToolsPage
│   │                   ├── StructurePage
│   │                   ├── LogsPage
│   │                   └── ApiStatusPage
`)
    )
  );
};

})();

// ============================================================
// FILE: src/pages/dev/ApiStatus.jsx
// ============================================================
(function() {
// ApiStatus.jsx - API接続ステータスページ
window.ApiStatusPage = () => {
  const { useState, useEffect } = React;
  const { apiKey } = useAppContext();
  const { isTracking, currentPosition } = useMapContext();

  const [checks, setChecks] = useState([]);

  useEffect(() => {
    const results = [
      {
        name: 'Google Maps JavaScript API',
        status: apiKey ? (window.google && window.google.maps ? 'connected' : 'error') : 'not_configured',
        detail: apiKey
          ? (window.google && window.google.maps ? '正常に読み込まれています' : 'APIの読み込みに失敗しました')
          : 'APIキーが設定されていません（設定画面で入力してください）',
        icon: 'map',
      },
      {
        name: 'Geolocation API (GPS)',
        status: 'geolocation' in navigator ? 'connected' : 'error',
        detail: 'geolocation' in navigator
          ? (isTracking ? `追跡中 (${currentPosition ? `${currentPosition.lat.toFixed(4)}, ${currentPosition.lng.toFixed(4)}` : '取得中...'})` : '利用可能（追跡停止中）')
          : 'このブラウザはGeolocation APIに対応していません',
        icon: 'gps_fixed',
      },
      {
        name: 'localStorage',
        status: (() => { try { localStorage.setItem('_test', '1'); localStorage.removeItem('_test'); return 'connected'; } catch { return 'error'; } })(),
        detail: (() => { try { localStorage.setItem('_test', '1'); localStorage.removeItem('_test'); return '正常に動作しています'; } catch { return 'localStorageが利用できません'; } })(),
        icon: 'storage',
      },
      {
        name: 'Service Worker (PWA)',
        status: 'serviceWorker' in navigator ? 'available' : 'not_available',
        detail: 'serviceWorker' in navigator ? '利用可能（未登録）' : 'このブラウザはService Workerに対応していません',
        icon: 'install_mobile',
      },
      {
        name: 'HTTPS',
        status: location.protocol === 'https:' ? 'connected' : 'warning',
        detail: location.protocol === 'https:'
          ? 'HTTPS接続です'
          : `HTTP接続です（${location.protocol}）。GPSやPWAにはHTTPSが必要な場合があります`,
        icon: 'lock',
      },
    ];

    setChecks(results);
  }, [apiKey, isTracking, currentPosition]);

  const statusIcon = (status) => {
    switch (status) {
      case 'connected': return { icon: 'check_circle', color: 'var(--color-accent)' };
      case 'error': return { icon: 'error', color: 'var(--color-danger)' };
      case 'warning': return { icon: 'warning', color: 'var(--color-warning)' };
      case 'not_configured': return { icon: 'settings', color: 'var(--color-warning)' };
      default: return { icon: 'help', color: 'var(--text-muted)' };
    }
  };

  const statusBadge = (status) => {
    switch (status) {
      case 'connected': return 'badge--success';
      case 'error': return 'badge--error';
      case 'warning': return 'badge--warning';
      case 'not_configured': return 'badge--warning';
      default: return 'badge--info';
    }
  };

  const statusLabel = (status) => {
    switch (status) {
      case 'connected': return '接続済み';
      case 'error': return 'エラー';
      case 'warning': return '警告';
      case 'not_configured': return '未設定';
      case 'available': return '利用可能';
      default: return '不明';
    }
  };

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'cloud'),
      'API接続状態'
    ),

    // ステータス一覧
    React.createElement('div', { style: { display: 'grid', gap: 'var(--space-md)' } },
      checks.map((check, i) => {
        const si = statusIcon(check.status);
        return React.createElement(Card, { key: i },
          React.createElement('div', { style: { display: 'flex', alignItems: 'flex-start', gap: '16px' } },
            React.createElement('span', {
              className: 'material-icons-round',
              style: { fontSize: '32px', color: si.color },
            }, check.icon),
            React.createElement('div', { style: { flex: 1 } },
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' } },
                React.createElement('span', { style: { fontWeight: 500 } }, check.name),
                React.createElement('span', { className: `badge ${statusBadge(check.status)}` },
                  React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px' } }, si.icon),
                  statusLabel(check.status)
                )
              ),
              React.createElement('div', {
                style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)' },
              }, check.detail)
            )
          )
        );
      })
    ),

    // ブラウザ情報
    React.createElement(Card, {
      title: 'ブラウザ環境',
      style: { marginTop: 'var(--space-lg)' },
    },
      React.createElement('div', { style: { display: 'grid', gap: '8px', fontSize: 'var(--font-size-sm)' } },
        [
          ['ユーザーエージェント', navigator.userAgent.substring(0, 80) + '...'],
          ['プラットフォーム', navigator.platform || 'N/A'],
          ['言語', navigator.language],
          ['オンライン', navigator.onLine ? 'はい' : 'いいえ'],
          ['画面サイズ', `${window.innerWidth} x ${window.innerHeight}`],
          ['デバイスピクセル比', window.devicePixelRatio],
          ['React バージョン', React.version],
        ].map(([label, value], i) =>
          React.createElement('div', {
            key: i,
            style: { display: 'flex', justifyContent: 'space-between', padding: '4px 0', borderBottom: '1px solid rgba(255,255,255,0.04)' },
          },
            React.createElement('span', { style: { color: 'var(--text-muted)' } }, label),
            React.createElement('span', { style: { fontFamily: 'monospace', textAlign: 'right', maxWidth: '60%', overflow: 'hidden', textOverflow: 'ellipsis' } }, String(value))
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/dev/DevTools.jsx
// ============================================================
(function() {
// DevTools.jsx - 開発者ツールハブ
window.DevToolsPage = () => {
  const { navigate } = useAppContext();
  const { logs } = useLogContext();

  const tools = [
    {
      id: 'dev-structure',
      title: 'サイト構造',
      desc: 'ファイル構造、ルーティング、コンポーネント階層を確認',
      icon: 'account_tree',
      color: 'var(--color-primary-light)',
      badge: null,
    },
    {
      id: 'dev-logs',
      title: 'ログビューア',
      desc: 'アプリケーションのリアルタイムログを確認・検索',
      icon: 'terminal',
      color: 'var(--color-accent)',
      badge: `${logs.length} 件`,
    },
    {
      id: 'dev-api',
      title: 'API接続状態',
      desc: 'Google Maps API、GPS、ブラウザAPIの接続状態を確認',
      icon: 'cloud',
      color: 'var(--color-secondary)',
      badge: null,
    },
  ];

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'code'),
      '開発者ツール'
    ),

    React.createElement('p', {
      style: { color: 'var(--text-secondary)', marginBottom: 'var(--space-lg)', fontSize: 'var(--font-size-sm)' },
    }, 'アプリの内部構造やログ、API接続状態を確認できます。生成AIでの開発時にこのページを参照してください。'),

    // ツール一覧
    React.createElement('div', { className: 'grid grid--3' },
      tools.map(tool =>
        React.createElement(Card, {
          key: tool.id,
          onClick: () => navigate(tool.id),
          style: { cursor: 'pointer', textAlign: 'center', padding: 'var(--space-xl)' },
        },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '48px', color: tool.color, marginBottom: '12px' },
          }, tool.icon),
          React.createElement('div', { style: { fontWeight: 700, marginBottom: '8px' } }, tool.title),
          React.createElement('div', {
            style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' },
          }, tool.desc),
          tool.badge && React.createElement('span', { className: 'badge badge--info' }, tool.badge)
        )
      )
    ),

    // 最新ログプレビュー
    React.createElement(Card, {
      title: '最新ログ（直近5件）',
      style: { marginTop: 'var(--space-lg)' },
    },
      logs.length === 0
        ? React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-sm)' } }, 'ログはまだありません')
        : [...logs].reverse().slice(0, 5).map(log =>
            React.createElement('div', { key: log.id, className: 'dev-log-entry' },
              React.createElement('span', { className: 'dev-log-entry__time' },
                new Date(log.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit', second: '2-digit' })
              ),
              React.createElement('span', { className: `dev-log-entry__level dev-log-entry__level--${log.level}` },
                log.level.toUpperCase()
              ),
              React.createElement('span', { className: 'dev-log-entry__message' }, log.message)
            )
          ),
      logs.length > 5 && React.createElement(Button, {
        variant: 'secondary',
        icon: 'arrow_forward',
        onClick: () => navigate('dev-logs'),
        style: { marginTop: 'var(--space-md)' },
      }, 'すべてのログを表示')
    ),

    // クイック情報
    React.createElement(Card, {
      title: 'プロジェクト情報',
      style: { marginTop: 'var(--space-lg)' },
    },
      React.createElement('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px', fontSize: 'var(--font-size-sm)' } },
        [
          ['フレームワーク', `React ${React.version}`],
          ['ビルド', 'CDN (Babel トランスパイル)'],
          ['地図', 'Google Maps JavaScript API'],
          ['バージョン', APP_CONSTANTS.VERSION],
          ['GPS', 'Geolocation API'],
          ['レスポンシブ', 'PC / タブレット / Android'],
        ].map(([k, v], i) =>
          React.createElement('div', { key: i },
            React.createElement('span', { style: { color: 'var(--text-muted)' } }, `${k}: `),
            React.createElement('span', null, v)
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/App.jsx
// ============================================================
(function() {
// App.jsx - ルートコンポーネント（ハッシュルーティング対応）
window.App = () => {
  const { currentPage, navigate } = useAppContext();

  // レガシー: カスタムイベントでのナビゲーション対応（後方互換性）
  React.useEffect(() => {
    const handler = (e) => navigate(e.detail);
    document.addEventListener('navigate', handler);
    return () => document.removeEventListener('navigate', handler);
  }, [navigate]);

  // ページルーティング（useMemoで不要な再生成を防止）
  const page = React.useMemo(() => {
    switch (currentPage) {
      case 'dashboard': return React.createElement(DashboardPage);
      case 'map': return React.createElement(MapViewPage);
      case 'revenue': return React.createElement(RevenuePage);
      case 'rival-ride': return React.createElement(RivalRidePage);
      case 'transit-info': return React.createElement(TransitInfoPage);
      case 'events': return React.createElement(EventsPage);
      case 'analytics': return React.createElement(AnalyticsPage);
      case 'data-manage': return React.createElement(DataManagePage);
      case 'settings': return React.createElement(SettingsPage);
      case 'dev': return React.createElement(DevToolsPage);
      case 'dev-logs': return React.createElement(LogsPage);
      case 'dev-structure': return React.createElement(StructurePage);
      case 'dev-api': return React.createElement(ApiStatusPage);
      default: return React.createElement(DashboardPage);
    }
  }, [currentPage]);

  return React.createElement(Layout, null, page);
};

})();

// ============================================================
// FILE: src/main.jsx
// ============================================================
(function() {
// main.jsx - エントリーポイント（TaxiApp名前空間登録 + アプリ起動）
(() => {
  // ============================================================
  // TaxiApp 名前空間にすべてのグローバルを整理
  // window.XXX は後方互換のために残すが、正規の参照先は TaxiApp
  // ============================================================
  const T = window.TaxiApp;

  // Utils
  T.utils.constants = APP_CONSTANTS;
  T.utils.logger = AppLogger;
  T.utils.storage = AppStorage;
  T.utils.dataService = DataService;
  T.utils.geminiService = GeminiService;

  // Contexts
  T.contexts.AppContext = AppContext;
  T.contexts.AppProvider = AppProvider;
  T.contexts.MapContext = MapContext;
  T.contexts.MapProvider = MapProvider;
  T.contexts.LogContext = LogContext;
  T.contexts.LogProvider = LogProvider;

  // Hooks
  T.hooks.useAppContext = useAppContext;
  T.hooks.useMapContext = useMapContext;
  T.hooks.useLogContext = useLogContext;
  T.hooks.useGeolocation = useGeolocation;
  T.hooks.useGoogleMaps = useGoogleMaps;
  T.hooks.useLogger = useLogger;

  // Components
  T.components.Loading = Loading;
  T.components.Card = Card;
  T.components.Button = Button;
  T.components.ErrorBoundary = ErrorBoundary;
  T.components.Header = Header;
  T.components.Sidebar = Sidebar;
  T.components.BottomNav = BottomNav;
  T.components.Layout = Layout;
  T.components.GoogleMapView = GoogleMapView;
  T.components.GpsTracker = GpsTracker;
  T.components.MapControls = MapControls;
  T.components.TrafficLegend = TrafficLegend;

  // Pages
  T.pages.Dashboard = DashboardPage;
  T.pages.MapView = MapViewPage;
  T.pages.Revenue = RevenuePage;
  T.pages.RivalRide = RivalRidePage;
  T.pages.TransitInfo = TransitInfoPage;
  T.pages.Events = EventsPage;
  T.pages.Analytics = AnalyticsPage;
  T.pages.Settings = SettingsPage;
  T.pages.DevTools = DevToolsPage;
  T.pages.Logs = LogsPage;
  T.pages.Structure = StructurePage;
  T.pages.ApiStatus = ApiStatusPage;

  // App
  T.App = App;

  // ============================================================
  // アプリケーション起動
  // ============================================================
  AppLogger.info('アプリケーション起動中...');
  AppLogger.info(`バージョン: ${APP_CONSTANTS.VERSION}`);
  AppLogger.info(`React バージョン: ${React.version}`);

  const root = ReactDOM.createRoot(document.getElementById('root'));

  root.render(
    React.createElement(ErrorBoundary, null,
      React.createElement(AppProvider, null,
        React.createElement(MapProvider, null,
          React.createElement(LogProvider, null,
            React.createElement(App)
          )
        )
      )
    )
  );

  AppLogger.info('アプリケーション起動完了');
  AppLogger.info(`登録済みコンポーネント: ${Object.keys(T.components).length}個, ページ: ${Object.keys(T.pages).length}個`);
})();

})();

  </script>

  <!-- Service Worker登録 & PWAインストールプロンプト -->
  <script>
  // Service Worker登録
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js')
        .then(reg => {
          console.log('[PWA] Service Worker登録成功:', reg.scope);
          if (window.AppLogger) AppLogger.info('Service Worker登録完了');
        })
        .catch(err => {
          console.warn('[PWA] Service Worker登録失敗:', err);
        });
    });
  }

  // PWAインストールプロンプト
  window._pwaInstallPrompt = null;
  window._pwaInstalled = false;

  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    window._pwaInstallPrompt = e;
    console.log('[PWA] インストールプロンプト利用可能');
    // カスタムイベントで通知
    document.dispatchEvent(new CustomEvent('pwa-install-available'));
  });

  window.addEventListener('appinstalled', () => {
    window._pwaInstalled = true;
    window._pwaInstallPrompt = null;
    console.log('[PWA] アプリがインストールされました');
    if (window.AppLogger) AppLogger.info('PWAインストール完了');
    document.dispatchEvent(new CustomEvent('pwa-installed'));
  });

  // インストール実行関数
  window.triggerPwaInstall = async () => {
    if (!window._pwaInstallPrompt) return { success: false, reason: 'prompt_not_available' };
    try {
      window._pwaInstallPrompt.prompt();
      const result = await window._pwaInstallPrompt.userChoice;
      window._pwaInstallPrompt = null;
      return { success: result.outcome === 'accepted', reason: result.outcome };
    } catch (e) {
      return { success: false, reason: e.message };
    }
  };
  </script>
</body>
</html>
