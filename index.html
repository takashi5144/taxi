<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com https://maps.googleapis.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: blob: https://maps.googleapis.com https://maps.gstatic.com https://*.tile.openstreetmap.org; connect-src 'self' https://api.open-meteo.com https://nominatim.openstreetmap.org https://generativelanguage.googleapis.com https://maps.googleapis.com; frame-ancestors 'none'" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="theme-color" content="#1a1a2e" />
  <meta name="description" content="タクシードライバー向けの売上サポートツール" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="manifest" href="./manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192.png" />
  <link rel="apple-touch-icon" href="./icons/icon-192.png" />
  <title>タクシー売上サポート v1.0.3</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="preconnect" href="https://maps.googleapis.com" />
  <link rel="preconnect" href="https://maps.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet" />
<style>
/* FILE: variables.css */
:root {
  /* カラーパレット */
  --color-primary: #1a73e8;
  --color-primary-dark: #1557b0;
  --color-primary-light: #4a90e2;
  --color-secondary: #f9a825;
  --color-secondary-dark: #c17900;
  --color-accent: #00c853;
  --color-danger: #e53935;
  --color-warning: #ff9800;

  /* 背景色 */
  --bg-dark: #1a1a2e;
  --bg-medium: #16213e;
  --bg-light: #0f3460;
  --bg-card: #1e2a4a;
  --bg-card-hover: #253252;
  --bg-secondary: #1e2a4a;
  --bg-tertiary: #253252;
  --bg-surface: #f5f5f5;

  /* テキスト色 */
  --text-primary: #ffffff;
  --text-secondary: #b0b8c8;
  --text-muted: #6c757d;
  --text-dark: #1a1a2e;

  /* フォント */
  --font-family: 'Noto Sans JP', -apple-system, BlinkMacSystemFont, sans-serif;
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-base: 1rem;
  --font-size-lg: 1.125rem;
  --font-size-xl: 1.5rem;
  --font-size-2xl: 2rem;

  /* スペーシング */
  --space-xs: 0.25rem;
  --space-sm: 0.5rem;
  --space-md: 1rem;
  --space-lg: 1.5rem;
  --space-xl: 2rem;
  --space-2xl: 3rem;

  /* レイアウト */
  --header-height: 56px;
  --sidebar-width: 240px;
  --bottom-nav-height: 64px;
  --border-radius: 12px;
  --border-radius-sm: 8px;

  /* シャドウ */
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.3);
  --shadow-lg: 0 8px 24px rgba(0,0,0,0.4);

  /* トランジション */
  --transition-fast: 150ms ease;
  --transition-normal: 250ms ease;
}

/* FILE: global.css */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  font-size: 16px;
  -webkit-text-size-adjust: 100%;
}

body {
  font-family: var(--font-family);
  background-color: var(--bg-dark);
  color: var(--text-primary);
  line-height: 1.6;
  min-height: 100vh;
  overflow-x: hidden;
  -webkit-font-smoothing: antialiased;
}

#root {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

a {
  color: var(--color-primary-light);
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* スクロールバー */
::-webkit-scrollbar {
  width: 6px;
}
::-webkit-scrollbar-track {
  background: var(--bg-medium);
}
::-webkit-scrollbar-thumb {
  background: var(--bg-light);
  border-radius: 3px;
}

/* ヘッダー */
.header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: var(--header-height);
  background: var(--bg-medium);
  border-bottom: 1px solid rgba(255,255,255,0.08);
  display: flex;
  align-items: center;
  padding: 0 var(--space-md);
  z-index: 1000;
  backdrop-filter: blur(10px);
}

.header__logo {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  font-weight: 700;
  font-size: var(--font-size-lg);
  color: var(--color-secondary);
  cursor: pointer;
}

.header__logo .material-icons-round {
  font-size: 28px;
}

.header__nav {
  display: none;
}

.header__nav-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  padding: var(--space-sm) var(--space-md);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  font-size: var(--font-size-sm);
  font-family: var(--font-family);
  transition: all var(--transition-fast);
  display: flex;
  align-items: center;
  gap: var(--space-xs);
}

.header__nav-btn:hover,
.header__nav-btn.active {
  background: rgba(255,255,255,0.08);
  color: var(--text-primary);
}

.header__nav-btn.active {
  color: var(--color-primary-light);
}

.header__menu-toggle {
  display: none;
  background: none;
  border: none;
  color: var(--text-primary);
  font-size: 24px;
  cursor: pointer;
  padding: var(--space-sm);
}

/* サイドバー */
.sidebar {
  position: fixed;
  top: var(--header-height);
  left: 0;
  width: var(--sidebar-width);
  height: calc(100vh - var(--header-height));
  background: var(--bg-medium);
  border-right: 1px solid rgba(255,255,255,0.06);
  padding: var(--space-md) 0;
  overflow-y: auto;
  z-index: 900;
  transition: transform var(--transition-normal);
}

.sidebar__section {
  padding: var(--space-sm) var(--space-md);
  margin-bottom: var(--space-sm);
}

.sidebar__section-title {
  font-size: var(--font-size-xs);
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: var(--space-sm);
  padding: 0 var(--space-sm);
}

.sidebar__item {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  padding: var(--space-sm) var(--space-md);
  border-radius: var(--border-radius-sm);
  color: var(--text-secondary);
  cursor: pointer;
  transition: all var(--transition-fast);
  font-size: var(--font-size-sm);
  border: none;
  background: none;
  width: 100%;
  text-align: left;
  font-family: var(--font-family);
}

.sidebar__item:hover {
  background: rgba(255,255,255,0.06);
  color: var(--text-primary);
}

.sidebar__item.active {
  background: rgba(26, 115, 232, 0.15);
  color: var(--color-primary-light);
}

.sidebar__item .material-icons-round {
  font-size: 20px;
}

/* メインコンテンツ */
.main-content {
  margin-top: var(--header-height);
  margin-left: var(--sidebar-width);
  padding: var(--space-lg);
  min-height: calc(100vh - var(--header-height));
  transition: margin-left var(--transition-normal);
}

/* ボトムナビ */
.bottom-nav {
  display: none;
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: var(--bottom-nav-height);
  background: var(--bg-medium);
  border-top: 1px solid rgba(255,255,255,0.08);
  z-index: 1000;
}

.bottom-nav__items {
  display: flex;
  justify-content: space-around;
  align-items: center;
  height: 100%;
  padding: 0 var(--space-sm);
}

.bottom-nav__item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  background: none;
  border: none;
  color: var(--text-muted);
  font-size: var(--font-size-xs);
  cursor: pointer;
  padding: var(--space-xs) var(--space-sm);
  border-radius: var(--border-radius-sm);
  transition: color var(--transition-fast);
  font-family: var(--font-family);
  min-width: 56px;
}

.bottom-nav__item .material-icons-round {
  font-size: 22px;
}

.bottom-nav__item.active {
  color: var(--color-primary-light);
}

.bottom-nav__item:hover {
  color: var(--text-primary);
}

/* カード */
.card {
  background: var(--bg-card);
  border: 1px solid rgba(255,255,255,0.06);
  border-radius: var(--border-radius);
  padding: var(--space-lg);
  transition: all var(--transition-fast);
}

.card:hover {
  background: var(--bg-card-hover);
  border-color: rgba(255,255,255,0.1);
}

.card__title {
  font-size: var(--font-size-lg);
  font-weight: 700;
  margin-bottom: var(--space-sm);
}

.card__subtitle {
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
  margin-bottom: var(--space-md);
}

/* ボタン */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-sm);
  padding: var(--space-sm) var(--space-lg);
  border: none;
  border-radius: var(--border-radius-sm);
  font-size: var(--font-size-sm);
  font-family: var(--font-family);
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-fast);
  white-space: nowrap;
}

.btn--primary {
  background: var(--color-primary);
  color: white;
}
.btn--primary:hover {
  background: var(--color-primary-dark);
}

.btn--secondary {
  background: rgba(255,255,255,0.08);
  color: var(--text-primary);
}
.btn--secondary:hover {
  background: rgba(255,255,255,0.14);
}

.btn--success {
  background: var(--color-accent);
  color: white;
}

.btn--danger {
  background: var(--color-danger);
  color: white;
}

.btn--icon {
  padding: var(--space-sm);
  border-radius: 50%;
}

.btn--ghost {
  background: transparent;
  color: var(--text-secondary);
}
.btn--ghost:hover {
  background: rgba(255,255,255,0.08);
}

/* グリッド */
.grid {
  display: grid;
  gap: var(--space-md);
}

.grid--2 { grid-template-columns: repeat(2, 1fr); }
.grid--3 { grid-template-columns: repeat(3, 1fr); }
.grid--4 { grid-template-columns: repeat(4, 1fr); }

/* ページタイトル */
.page-title {
  font-size: var(--font-size-xl);
  font-weight: 700;
  margin-bottom: var(--space-lg);
  display: flex;
  align-items: center;
  gap: var(--space-sm);
}

.page-title .material-icons-round {
  color: var(--color-secondary);
}

/* InfoPage内の子ページタイトルを非表示 */
.info-page-content .page-title {
  display: none;
}

/* 地図コンテナ */
.map-container {
  width: 100%;
  height: 500px;
  border-radius: var(--border-radius);
  overflow: hidden;
  position: relative;
  background: var(--bg-card);
}

.map-container--fullscreen {
  position: fixed;
  top: var(--header-height);
  left: var(--sidebar-width);
  right: 0;
  bottom: 0;
  height: auto;
  border-radius: 0;
  z-index: 500;
}

/* GPS情報パネル */
.gps-panel {
  background: rgba(26, 26, 46, 0.95);
  backdrop-filter: blur(10px);
  border-radius: var(--border-radius-sm);
  padding: var(--space-md);
  margin-top: var(--space-md);
  border: 1px solid rgba(255,255,255,0.1);
}

.gps-panel__row {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  font-size: var(--font-size-sm);
}

.gps-panel__label {
  color: var(--text-muted);
  min-width: 60px;
}

.gps-panel__value {
  color: var(--color-accent);
  font-weight: 500;
  font-family: 'Courier New', monospace;
}

/* ステータスバッジ */
.badge {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 8px;
  border-radius: 20px;
  font-size: var(--font-size-xs);
  font-weight: 500;
}

.badge--success {
  background: rgba(0, 200, 83, 0.15);
  color: var(--color-accent);
}

.badge--warning {
  background: rgba(255, 152, 0, 0.15);
  color: var(--color-warning);
}

.badge--error {
  background: rgba(229, 57, 53, 0.15);
  color: var(--color-danger);
}

.badge--info {
  background: rgba(26, 115, 232, 0.15);
  color: var(--color-primary-light);
}

/* 開発ツール */
.dev-log-entry {
  display: flex;
  gap: var(--space-sm);
  padding: var(--space-sm) var(--space-md);
  border-bottom: 1px solid rgba(255,255,255,0.04);
  font-size: var(--font-size-sm);
  font-family: 'Courier New', monospace;
}

.dev-log-entry__time {
  color: var(--text-muted);
  white-space: nowrap;
}

.dev-log-entry__level {
  min-width: 50px;
  font-weight: 700;
}

.dev-log-entry__level--info { color: var(--color-primary-light); }
.dev-log-entry__level--warn { color: var(--color-warning); }
.dev-log-entry__level--error { color: var(--color-danger); }
.dev-log-entry__level--debug { color: var(--text-muted); }

.dev-log-entry__message {
  color: var(--text-secondary);
  word-break: break-all;
}

/* フォーム */
.form-group {
  margin-bottom: var(--space-md);
}

.form-label {
  display: block;
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
  margin-bottom: var(--space-xs);
}

.form-input {
  width: 100%;
  padding: var(--space-sm) var(--space-md);
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: var(--border-radius-sm);
  color: var(--text-primary);
  font-size: var(--font-size-base);
  font-family: var(--font-family);
  transition: border-color var(--transition-fast);
}

.form-input:focus {
  outline: none;
  border-color: var(--color-primary);
}

/* 統計カード */
.stat-card {
  text-align: center;
  padding: var(--space-lg);
}

.stat-card__value {
  font-size: var(--font-size-2xl);
  font-weight: 700;
  color: var(--color-secondary);
}

.stat-card__label {
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
  margin-top: var(--space-xs);
}

/* ローディング */
.loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: var(--space-2xl);
  gap: var(--space-md);
}

.loading__spinner {
  width: 40px;
  height: 40px;
  border: 3px solid rgba(255,255,255,0.1);
  border-top-color: var(--color-primary);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

/* ファイルツリー */
.file-tree {
  font-family: 'Courier New', monospace;
  font-size: var(--font-size-sm);
  line-height: 1.8;
}

.file-tree__item {
  display: flex;
  align-items: center;
  gap: var(--space-xs);
  padding: 2px 0;
}

.file-tree__icon {
  font-size: 16px;
}

.file-tree__icon--folder { color: var(--color-secondary); }
.file-tree__icon--file { color: var(--text-muted); }
.file-tree__icon--react { color: #61dafb; }
.file-tree__icon--css { color: #264de4; }
.file-tree__icon--js { color: #f7df1e; }
.file-tree__icon--html { color: #e34c26; }
.file-tree__icon--md { color: var(--text-secondary); }

/* タブ */
.tabs {
  display: flex;
  gap: 2px;
  border-bottom: 1px solid rgba(255,255,255,0.08);
  margin-bottom: var(--space-lg);
}

.tab {
  padding: var(--space-sm) var(--space-lg);
  background: none;
  border: none;
  color: var(--text-muted);
  cursor: pointer;
  font-size: var(--font-size-sm);
  font-family: var(--font-family);
  border-bottom: 2px solid transparent;
  transition: all var(--transition-fast);
}

.tab:hover {
  color: var(--text-secondary);
}

.tab.active {
  color: var(--color-primary-light);
  border-bottom-color: var(--color-primary);
}

/* FILE: responsive.css */
/* タブレット */
@media (max-width: 1023px) {
  .sidebar {
    transform: translateX(-100%);
  }

  .sidebar.open {
    transform: translateX(0);
  }

  .main-content {
    margin-left: 0;
  }

  .map-container--fullscreen {
    left: 0;
  }

  .header__menu-toggle {
    display: block;
  }

  .header__nav {
    display: none;
  }

  .grid--3 { grid-template-columns: repeat(2, 1fr); }
  .grid--4 { grid-template-columns: repeat(2, 1fr); }
}

/* モバイル (Android) */
@media (max-width: 767px) {
  html {
    font-size: 14px;
  }

  .sidebar {
    width: 100%;
    transform: translateX(-100%);
  }

  .sidebar.open {
    transform: translateX(0);
  }

  .bottom-nav {
    display: block;
  }

  .main-content {
    margin-left: 0;
    padding: var(--space-md);
    padding-bottom: calc(var(--bottom-nav-height) + var(--space-md));
  }

  .map-container {
    height: 350px;
  }

  .map-container--fullscreen {
    left: 0;
    bottom: var(--bottom-nav-height);
  }

  .grid--2,
  .grid--3,
  .grid--4 {
    grid-template-columns: 1fr;
  }

  .page-title {
    font-size: var(--font-size-lg);
  }

  .card {
    padding: var(--space-md);
  }

  .gps-panel {
    padding: var(--space-sm);
  }

  .header__nav-btn span:not(.material-icons-round) {
    display: none;
  }

  .tabs {
    overflow-x: auto;
    white-space: nowrap;
    -webkit-overflow-scrolling: touch;
  }
}

/* 小型モバイル */
@media (max-width: 375px) {
  .bottom-nav__item {
    min-width: 48px;
    font-size: 10px;
  }

  .bottom-nav__item .material-icons-round {
    font-size: 20px;
  }
}

/* ランドスケープモード */
@media (max-height: 500px) and (orientation: landscape) {
  .header {
    height: 44px;
  }

  .main-content {
    margin-top: 44px;
  }

  .map-container {
    height: 250px;
  }
}

/* PC大画面 */
@media (min-width: 1440px) {
  .main-content {
    max-width: 1200px;
  }

  .grid--4 { grid-template-columns: repeat(4, 1fr); }
}

/* ダークモード対応（システム設定連動） */
@media (prefers-color-scheme: light) {
  /* 将来のライトモード対応用 */
}

/* タッチデバイス対応 */
@media (hover: none) {
  .card:hover {
    background: var(--bg-card);
    border-color: rgba(255,255,255,0.06);
  }

  .btn:active {
    transform: scale(0.97);
  }

  .sidebar__item:active {
    background: rgba(255,255,255,0.08);
  }
}

/* 印刷用 */
@media print {
  .header, .sidebar, .bottom-nav {
    display: none !important;
  }

  .main-content {
    margin: 0 !important;
    padding: 0 !important;
  }
}

</style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18.3.1/umd/react.production.min.js" crossorigin="anonymous" integrity="sha384-DGyLxAyjq0f9SPpVevD6IgztCFlnMF6oW/XQGmfe+IsZ8TqEiDrcHkMLKI6fiB/Z"></script>
  <script src="https://unpkg.com/react-dom@18.3.1/umd/react-dom.production.min.js" crossorigin="anonymous" integrity="sha384-gTGxhz21lVGYNMcdJOyq01Edg0jhn/c22nsx0kyqP0TxaV5WVdsSH1fSDUf5YJj1"></script>

  <script type="text/javascript">

// ============================================================
// FILE: src/utils/constants.js
// ============================================================
(function() {
// constants.js - アプリケーション定数
//
// TaxiApp 名前空間を定義。全コンポーネント・フック・コンテキストは
// この名前空間に登録される。window直接割り当ては後方互換のためのエイリアス。
window.TaxiApp = window.TaxiApp || {
  components: {},  // UIコンポーネント
  pages: {},       // ページコンポーネント
  hooks: {},       // カスタムフック
  contexts: {},    // React Context
  utils: {},       // ユーティリティ
};

// 共通ユーティリティ（各ページから参照）
window.TaxiApp.utils.getNowTime = () => {
  const now = new Date();
  return `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
};

window.TaxiApp.utils.nominatimUrl = (lat, lng, zoom = 18) => {
  const params = new URLSearchParams({ format: 'json', lat: String(lat), lon: String(lng), zoom: String(zoom), addressdetails: '1', 'accept-language': 'ja' });
  return `https://nominatim.openstreetmap.org/reverse?${params}`;
};

window.TaxiApp.utils.extractAddress = (result) => {
  const comps = result.address_components;
  let prefecture = '', city = '', ward = '', town = '', sublocality = '', chome = '', banchi = '', route = '';
  for (const c of comps) {
    if (c.types.includes('administrative_area_level_1')) prefecture = c.long_name;
    if (c.types.includes('locality')) city = c.long_name;
    if (c.types.includes('sublocality_level_1') || c.types.includes('ward')) ward = c.long_name;
    if (c.types.includes('sublocality_level_2')) town = c.long_name;
    if (c.types.includes('sublocality_level_3')) sublocality = c.long_name;
    if (c.types.includes('sublocality_level_4')) chome = c.long_name;
    if (c.types.includes('premise')) banchi = c.long_name;
    if (c.types.includes('route')) route = c.long_name;
  }
  const area = ward || city || prefecture;
  const detail = [town, sublocality, chome, banchi].filter(Boolean).join('');
  if (area && detail) return area + ' ' + detail;
  if (area && route) return area + ' ' + route;
  if (area) return area;
  return result.formatted_address
    .replace(/〒\d{3}-?\d{4}\s*/, '')
    .replace(/、日本$/, '').replace(/^日本、\s*/, '')
    .replace(/^日本\s*/, '');
};

// ローカル時間でYYYY-MM-DD形式の日付文字列を取得（UTC誤差回避）
window.getLocalDateString = (date) => {
  const d = date || new Date();
  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
};

window.APP_CONSTANTS = {
  APP_NAME: 'タクシー売上サポート',
  VERSION: '1.3.0',

  // デフォルト地図設定（東京駅）
  DEFAULT_MAP_CENTER: { lat: 35.6812, lng: 139.7671 },
  DEFAULT_MAP_ZOOM: 15,

  // GPS設定
  GPS_OPTIONS: {
    enableHighAccuracy: true,
    timeout: 15000,
    maximumAge: 0,
  },

  // ルート定義
  ROUTES: {
    DASHBOARD: 'dashboard',
    MAP: 'map',
    REVENUE: 'revenue',
    RIVAL_RIDE: 'rival-ride',
    TRANSIT_INFO: 'transit-info',
    EVENTS: 'events',
    ANALYTICS: 'analytics',
    CALENDAR: 'calendar',
    INFO: 'info',
    DATA_MANAGE: 'data-manage',
    SETTINGS: 'settings',
    DEV_TOOLS: 'dev',
    DEV_LOGS: 'dev-logs',
    DEV_STRUCTURE: 'dev-structure',
    DEV_API: 'dev-api',
  },

  // ナビゲーション項目
  NAV_ITEMS: [
    { id: 'dashboard', label: 'ダッシュボード', icon: 'dashboard' },
    { id: 'map', label: '地図', icon: 'map' },
    { id: 'revenue', label: '売上記録', icon: 'receipt_long' },
    { id: 'rival-ride', label: '他社乗車', icon: 'local_taxi' },
    { id: 'analytics', label: '分析', icon: 'analytics' },
    { id: 'calendar', label: 'カレンダー', icon: 'calendar_month' },
    { id: 'data-manage', label: 'データ管理', icon: 'edit_note' },
    { id: 'settings', label: '設定', icon: 'settings' },
  ],

  // 情報ナビゲーション項目
  INFO_NAV_ITEMS: [
    { id: 'info', label: '情報', icon: 'info' },
  ],

  // ボトムナビ項目
  BOTTOM_NAV_ITEMS: [
    { id: 'dashboard', label: 'ホーム', icon: 'home' },
    { id: 'map', label: '地図', icon: 'map' },
    { id: 'revenue', label: '売上', icon: 'receipt_long' },
    { id: 'calendar', label: 'カレンダー', icon: 'calendar_month' },
    { id: 'analytics', label: '分析', icon: 'analytics' },
    { id: 'settings', label: '設定', icon: 'more_horiz' },
  ],

  // ログレベル
  LOG_LEVELS: {
    DEBUG: 'debug',
    INFO: 'info',
    WARN: 'warn',
    ERROR: 'error',
  },

  // localStorage キー
  STORAGE_KEYS: {
    API_KEY: 'taxi_app_google_maps_api_key',
    GEMINI_API_KEY: 'taxi_app_gemini_api_key',
    LOGS: 'taxi_app_logs',
    SETTINGS: 'taxi_app_settings',
    REVENUE_DATA: 'taxi_app_revenue',
    RIVAL_RIDES: 'taxi_app_rival_rides',
    EVENTS: 'taxi_app_events',
    SYNC_SECRET: 'taxi_app_sync_secret',
    TRANSIT_INFO: 'taxi_app_transit_info',
    NOTIFICATION_ENABLED: 'taxi_app_notification_enabled',
    SHIFTS: 'taxi_app_shifts',
    DAILY_DEMAND_PLAN: 'taxi_app_daily_demand_plan',
    WORK_STATUS: 'taxi_app_work_status',
    HOTEL_PRICES: 'taxi_app_hotel_prices',
  },

  // 旭川市の主要ロケーション（駅・病院）
  KNOWN_LOCATIONS: {
    asahikawa: {
      station: { name: '旭川駅', lat: 43.7631, lng: 142.3581 },
      hospitals: [
        { name: '旭川医科大学病院', lat: 43.7306, lng: 142.3857, peakMorning: '08:00-11:00', peakAfternoon: null },
        { name: '旭川赤十字病院', lat: 43.7580, lng: 142.3720, peakMorning: '08:30-11:00', peakAfternoon: null },
        { name: '市立旭川病院', lat: 43.7710, lng: 142.3650, peakMorning: null, peakAfternoon: '13:00-15:00' },
        { name: '旭川厚生病院', lat: 43.7650, lng: 142.3490, peakMorning: null, peakAfternoon: '13:00-15:00' },
      ],
      hotels: [
        // 駅遠方（タクシー需要: 非常に高い）
        { name: 'アートホテル旭川', lat: 43.7730, lng: 142.3604, rooms: 265, distKm: 1.2, demandLevel: 'very_high' },
        { name: 'OMO7旭川', lat: 43.7703, lng: 142.3646, rooms: 237, distKm: 1.0, demandLevel: 'very_high' },
        { name: '旭川トーヨーホテル', lat: 43.7723, lng: 142.3621, rooms: 128, distKm: 1.2, demandLevel: 'very_high' },
        // 中距離（タクシー需要: 高い）
        { name: 'ドーミーイン旭川', lat: 43.7708, lng: 142.3594, rooms: 172, distKm: 0.9, demandLevel: 'high' },
        { name: 'ホテルクレッセント旭川', lat: 43.7698, lng: 142.3624, rooms: 159, distKm: 0.9, demandLevel: 'high' },
        { name: 'プレミアホテルCABIN旭川', lat: 43.7658, lng: 142.3586, rooms: 355, distKm: 0.4, demandLevel: 'high' },
        { name: 'ホテルアマネク旭川', lat: 43.7655, lng: 142.3599, rooms: 221, distKm: 0.35, demandLevel: 'high' },
        // 駅近（大型 → ボリューム需要）
        { name: 'ルートインGrand旭川駅前', lat: 43.7633, lng: 142.3588, rooms: 342, distKm: 0.2, demandLevel: 'medium' },
        { name: 'JRイン旭川', lat: 43.7639, lng: 142.3568, rooms: 198, distKm: 0.0, demandLevel: 'medium' },
        { name: '東横INN旭川駅東口', lat: 43.7625, lng: 142.3637, rooms: 185, distKm: 0.4, demandLevel: 'medium' },
        { name: 'ルートイン旭川駅前一条通', lat: 43.7663, lng: 142.3569, rooms: 187, distKm: 0.5, demandLevel: 'medium' },
        { name: 'ワイズホテル旭川駅前', lat: 43.7612, lng: 142.3585, rooms: 160, distKm: 0.2, demandLevel: 'medium' },
        { name: '東横INN旭川駅前一条通', lat: 43.7649, lng: 142.3612, rooms: 143, distKm: 0.4, demandLevel: 'medium' },
        { name: 'WBFグランデ旭川', lat: 43.7630, lng: 142.3622, rooms: 120, distKm: 0.3, demandLevel: 'low' },
        { name: 'コートホテル旭川', lat: 43.7649, lng: 142.3612, rooms: 114, distKm: 0.2, demandLevel: 'low' },
      ],
      // ホテル需要ピーク時間帯（全ホテル共通）
      hotelPeakWindows: {
        checkout: { start: '09:30', end: '11:00', label: 'チェックアウト', weight: 1.0 },
        checkin:  { start: '15:00', end: '17:00', label: 'チェックイン', weight: 0.8 },
        evening:  { start: '18:00', end: '20:00', label: '夕食・外出', weight: 0.6 },
        night:    { start: '22:00', end: '24:00', label: '帰館', weight: 0.5 },
      },
    },
  },

  // サイト構造（開発者ツール用）
  SITE_STRUCTURE: {
    name: 'taxi-sales-support/',
    type: 'folder',
    children: [
      {
        name: 'src/',
        type: 'folder',
        children: [
          { name: 'main.jsx', type: 'react', desc: 'エントリーポイント' },
          { name: 'App.jsx', type: 'react', desc: 'ルートコンポーネント・ルーティング' },
          {
            name: 'components/',
            type: 'folder',
            children: [
              {
                name: 'Layout/',
                type: 'folder',
                children: [
                  { name: 'Header.jsx', type: 'react', desc: 'ヘッダーナビゲーション' },
                  { name: 'Sidebar.jsx', type: 'react', desc: 'PC用サイドバー' },
                  { name: 'BottomNav.jsx', type: 'react', desc: 'モバイル用ボトムナビ' },
                  { name: 'Layout.jsx', type: 'react', desc: 'レイアウトラッパー' },
                ],
              },
              {
                name: 'Map/',
                type: 'folder',
                children: [
                  { name: 'GoogleMap.jsx', type: 'react', desc: 'Google Maps本体' },
                  { name: 'GpsTracker.jsx', type: 'react', desc: 'GPS追跡パネル' },
                  { name: 'MapControls.jsx', type: 'react', desc: '地図操作コントロール' },
                ],
              },
              {
                name: 'common/',
                type: 'folder',
                children: [
                  { name: 'Button.jsx', type: 'react', desc: '汎用ボタン' },
                  { name: 'Card.jsx', type: 'react', desc: '汎用カード' },
                  { name: 'Loading.jsx', type: 'react', desc: 'ローディング表示' },
                  { name: 'ErrorBoundary.jsx', type: 'react', desc: 'エラーバウンダリ' },
                ],
              },
            ],
          },
          {
            name: 'pages/',
            type: 'folder',
            children: [
              { name: 'Dashboard.jsx', type: 'react', desc: 'ダッシュボード' },
              { name: 'MapView.jsx', type: 'react', desc: '地図ページ' },
              { name: 'Revenue.jsx', type: 'react', desc: '売上記録' },
              { name: 'Analytics.jsx', type: 'react', desc: '売上分析' },
              { name: 'TransitInfo.jsx', type: 'react', desc: '公共交通機関情報' },
              { name: 'Events.jsx', type: 'react', desc: 'イベント記録' },
              { name: 'DataManage.jsx', type: 'react', desc: 'データ管理（編集・削除）' },
              { name: 'Settings.jsx', type: 'react', desc: 'アプリ設定' },
              {
                name: 'dev/',
                type: 'folder',
                children: [
                  { name: 'DevTools.jsx', type: 'react', desc: '開発者ツールハブ' },
                  { name: 'Structure.jsx', type: 'react', desc: 'サイト構造ビューア' },
                  { name: 'Logs.jsx', type: 'react', desc: 'ログビューア' },
                  { name: 'ApiStatus.jsx', type: 'react', desc: 'API接続状態' },
                ],
              },
            ],
          },
          {
            name: 'context/',
            type: 'folder',
            children: [
              { name: 'AppContext.jsx', type: 'react', desc: 'グローバル状態管理' },
              { name: 'MapContext.jsx', type: 'react', desc: '地図状態管理' },
              { name: 'LogContext.jsx', type: 'react', desc: 'ログ管理' },
            ],
          },
          {
            name: 'hooks/',
            type: 'folder',
            children: [
              { name: 'useGeolocation.js', type: 'js', desc: 'GPS位置情報フック' },
              { name: 'useGoogleMaps.js', type: 'js', desc: 'Google Maps読み込みフック' },
              { name: 'useLogger.js', type: 'js', desc: 'ロガーフック' },
            ],
          },
          {
            name: 'utils/',
            type: 'folder',
            children: [
              { name: 'constants.js', type: 'js', desc: '定数定義・TaxiApp名前空間' },
              { name: 'logger.js', type: 'js', desc: 'ロガーユーティリティ' },
              { name: 'storage.js', type: 'js', desc: 'localStorage管理' },
              { name: 'dataService.js', type: 'js', desc: '売上データ処理・分析・CSV出力' },
              { name: 'geminiService.js', type: 'js', desc: 'Gemini AI API連携' },
            ],
          },
          {
            name: 'styles/',
            type: 'folder',
            children: [
              { name: 'variables.css', type: 'css', desc: 'CSS変数' },
              { name: 'global.css', type: 'css', desc: 'グローバルスタイル' },
              { name: 'responsive.css', type: 'css', desc: 'レスポンシブ対応' },
            ],
          },
        ],
      },
      {
        name: 'docs/',
        type: 'folder',
        children: [
          { name: 'ARCHITECTURE.md', type: 'md', desc: 'アーキテクチャ設計書' },
          { name: 'CHANGELOG.md', type: 'md', desc: '変更履歴' },
          { name: 'DEV_LOG.md', type: 'md', desc: '開発ログ' },
        ],
      },
      {
        name: 'public/',
        type: 'folder',
        children: [
          { name: 'manifest.json', type: 'file', desc: 'PWAマニフェスト' },
          { name: 'sw.js', type: 'js', desc: 'Service Worker（コピー元）' },
        ],
      },
      { name: 'index.html', type: 'html', desc: 'エントリーHTML' },
      { name: 'sw.js', type: 'js', desc: 'Service Worker（ルート配置）' },
      { name: 'package.json', type: 'file', desc: 'プロジェクト情報' },
    ],
  },
};

})();

// ============================================================
// FILE: src/utils/logger.js
// ============================================================
(function() {
// logger.js - アプリケーションロガー
window.AppLogger = (() => {
  const MAX_LOGS = 500;
  let logs = [];
  let listeners = [];

  function loadLogs() {
    try {
      const saved = localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.LOGS);
      if (saved) logs = JSON.parse(saved);
    } catch (e) {
      logs = [];
    }
  }

  function saveLogs() {
    try {
      localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.LOGS, JSON.stringify(logs.slice(-MAX_LOGS)));
    } catch (e) { /* ignore */ }
  }

  function notify() {
    listeners.forEach(fn => fn([...logs]));
  }

  function addLog(level, message, data = null) {
    const entry = {
      id: Date.now() + '_' + Math.random().toString(36).substr(2, 5),
      timestamp: new Date().toISOString(),
      level,
      message,
      data,
    };
    logs.push(entry);
    if (logs.length > MAX_LOGS) logs = logs.slice(-MAX_LOGS);
    saveLogs();
    notify();

    // コンソールにも出力
    const consoleFn = level === 'error' ? console.error
      : level === 'warn' ? console.warn
      : level === 'debug' ? console.debug
      : console.log;
    consoleFn(`[${level.toUpperCase()}] ${message}`, data || '');

    return entry;
  }

  loadLogs();

  return {
    debug: (msg, data) => addLog('debug', msg, data),
    info: (msg, data) => addLog('info', msg, data),
    warn: (msg, data) => addLog('warn', msg, data),
    error: (msg, data) => addLog('error', msg, data),
    getLogs: () => [...logs],
    clearLogs: () => { logs = []; saveLogs(); notify(); },
    subscribe: (fn) => { listeners.push(fn); return () => { listeners = listeners.filter(l => l !== fn); }; },
  };
})();

})();

// ============================================================
// FILE: src/utils/storage.js
// ============================================================
(function() {
// storage.js - localStorage管理
window.AppStorage = {
  get(key, defaultValue = null) {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue;
    } catch {
      return defaultValue;
    }
  },

  set(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value));
      return true;
    } catch {
      return false;
    }
  },

  remove(key) {
    try {
      localStorage.removeItem(key);
      return true;
    } catch {
      return false;
    }
  },

  getApiKey() {
    // APIキーはユーザーが設定画面から入力したもののみ使用
    // ハードコードされたキーは使用しない（セキュリティリスク）
    return this.get(APP_CONSTANTS.STORAGE_KEYS.API_KEY, '');
  },

  setApiKey(key) {
    return this.set(APP_CONSTANTS.STORAGE_KEYS.API_KEY, key);
  },

  getGeminiApiKey() {
    return this.get(APP_CONSTANTS.STORAGE_KEYS.GEMINI_API_KEY, '');
  },

  setGeminiApiKey(key) {
    return this.set(APP_CONSTANTS.STORAGE_KEYS.GEMINI_API_KEY, key);
  },

  getSettings() {
    return this.get(APP_CONSTANTS.STORAGE_KEYS.SETTINGS, {
      gpsAutoTrack: true,
      mapType: 'roadmap',
    });
  },

  setSettings(settings) {
    return this.set(APP_CONSTANTS.STORAGE_KEYS.SETTINGS, settings);
  },
};

})();

// ============================================================
// FILE: src/utils/holidays.js
// ============================================================
(function() {
// holidays.js - 日本の祝日判定ユーティリティ
// 固定祝日・ハッピーマンデー・春分/秋分の日・振替休日・国民の休日に対応

window.JapaneseHolidays = (() => {
  // 曜日名
  const DAY_NAMES = ['日', '月', '火', '水', '木', '金', '土'];

  // 曜日を取得
  function getDayOfWeek(dateStr) {
    const d = new Date(dateStr + 'T00:00:00');
    return DAY_NAMES[d.getDay()];
  }

  // 曜日インデックスを取得 (0=日, 6=土)
  function getDayIndex(dateStr) {
    return new Date(dateStr + 'T00:00:00').getDay();
  }

  // 春分の日を計算（1900-2099年対応）
  function getVernalEquinox(year) {
    if (year < 1900 || year > 2099) return 21;
    if (year <= 1979) return Math.floor(20.8357 + 0.242194 * (year - 1980) - Math.floor((year - 1983) / 4));
    if (year <= 2099) return Math.floor(20.8431 + 0.242194 * (year - 1980) - Math.floor((year - 1980) / 4));
    return 21;
  }

  // 秋分の日を計算（1900-2099年対応）
  function getAutumnalEquinox(year) {
    if (year < 1900 || year > 2099) return 23;
    if (year <= 1979) return Math.floor(23.2588 + 0.242194 * (year - 1980) - Math.floor((year - 1983) / 4));
    if (year <= 2099) return Math.floor(23.2488 + 0.242194 * (year - 1980) - Math.floor((year - 1980) / 4));
    return 23;
  }

  // 第N月曜日の日付を取得
  function getNthMonday(year, month, n) {
    const firstDay = new Date(year, month - 1, 1);
    let dayOfWeek = firstDay.getDay();
    let firstMonday = dayOfWeek <= 1 ? (1 + (1 - dayOfWeek)) : (1 + (8 - dayOfWeek));
    return firstMonday + (n - 1) * 7;
  }

  // その年の祝日一覧を生成（日付文字列 → 祝日名のMap）
  function getHolidaysForYear(year) {
    const holidays = new Map();
    const pad = (n) => String(n).padStart(2, '0');
    const key = (m, d) => `${year}-${pad(m)}-${pad(d)}`;

    // === 固定祝日 ===
    holidays.set(key(1, 1), '元日');
    holidays.set(key(2, 11), '建国記念の日');
    if (year >= 2020) holidays.set(key(2, 23), '天皇誕生日');
    else if (year >= 1989 && year <= 2018) holidays.set(key(12, 23), '天皇誕生日');
    holidays.set(key(4, 29), year >= 2007 ? '昭和の日' : 'みどりの日');
    holidays.set(key(5, 3), '憲法記念日');
    holidays.set(key(5, 4), year >= 2007 ? 'みどりの日' : '国民の休日');
    holidays.set(key(5, 5), 'こどもの日');
    if (year >= 2016) holidays.set(key(8, 11), '山の日');
    holidays.set(key(11, 3), '文化の日');
    holidays.set(key(11, 23), '勤労感謝の日');

    // === ハッピーマンデー ===
    if (year >= 2000) {
      holidays.set(key(1, getNthMonday(year, 1, 2)), '成人の日');
    } else {
      holidays.set(key(1, 15), '成人の日');
    }

    if (year >= 2003) {
      holidays.set(key(7, getNthMonday(year, 7, 3)), '海の日');
    } else if (year >= 1996) {
      holidays.set(key(7, 20), '海の日');
    }

    if (year >= 2003) {
      holidays.set(key(9, getNthMonday(year, 9, 3)), '敬老の日');
    } else if (year >= 1966) {
      holidays.set(key(9, 15), '敬老の日');
    }

    if (year >= 2000) {
      holidays.set(key(10, getNthMonday(year, 10, 2)), 'スポーツの日');
    } else {
      holidays.set(key(10, 10), '体育の日');
    }

    // === 春分の日・秋分の日 ===
    holidays.set(key(3, getVernalEquinox(year)), '春分の日');
    holidays.set(key(9, getAutumnalEquinox(year)), '秋分の日');

    // === 特例（オリンピック等） ===
    if (year === 2020) {
      holidays.delete(key(7, getNthMonday(year, 7, 3)));
      holidays.set(key(7, 23), '海の日');
      holidays.set(key(7, 24), 'スポーツの日');
      holidays.delete(key(10, getNthMonday(year, 10, 2)));
      holidays.delete(key(8, 11));
      holidays.set(key(8, 10), '山の日');
    }
    if (year === 2021) {
      holidays.delete(key(7, getNthMonday(year, 7, 3)));
      holidays.set(key(7, 22), '海の日');
      holidays.set(key(7, 23), 'スポーツの日');
      holidays.delete(key(10, getNthMonday(year, 10, 2)));
      holidays.delete(key(8, 11));
      holidays.set(key(8, 8), '山の日');
    }

    // === 振替休日 ===
    // 祝日が日曜の場合、翌月曜が振替休日
    const baseHolidays = new Map(holidays);
    for (const [dateStr] of baseHolidays) {
      const d = new Date(dateStr + 'T00:00:00');
      if (d.getDay() === 0) { // 日曜日
        let next = new Date(d);
        next.setDate(next.getDate() + 1);
        let nextStr = getLocalDateString(next);
        // 翌日も祝日なら更に翌日へ
        while (holidays.has(nextStr)) {
          next.setDate(next.getDate() + 1);
          nextStr = getLocalDateString(next);
        }
        holidays.set(nextStr, '振替休日');
      }
    }

    // === 国民の休日（祝日に挟まれた平日） ===
    const sortedDates = Array.from(holidays.keys()).sort();
    for (let i = 0; i < sortedDates.length - 1; i++) {
      const curr = new Date(sortedDates[i] + 'T00:00:00');
      const next = new Date(sortedDates[i + 1] + 'T00:00:00');
      const diff = (next - curr) / 86400000;
      if (diff === 2) {
        const between = new Date(curr);
        between.setDate(between.getDate() + 1);
        const betweenStr = getLocalDateString(between);
        if (!holidays.has(betweenStr) && between.getDay() !== 0) {
          holidays.set(betweenStr, '国民の休日');
        }
      }
    }

    return holidays;
  }

  // キャッシュ
  const _cache = {};

  // 指定日が祝日かチェック（祝日名を返す、祝日でなければnull）
  function getHolidayName(dateStr) {
    if (!dateStr) return null;
    const year = parseInt(dateStr.split('-')[0]);
    if (!_cache[year]) {
      _cache[year] = getHolidaysForYear(year);
    }
    return _cache[year].get(dateStr) || null;
  }

  // 日付情報をまとめて取得
  function getDateInfo(dateStr) {
    if (!dateStr) return { dayOfWeek: '', holiday: null, isHoliday: false, isSunday: false, isSaturday: false };
    const dayOfWeek = getDayOfWeek(dateStr);
    const dayIndex = getDayIndex(dateStr);
    const holiday = getHolidayName(dateStr);
    return {
      dayOfWeek,
      holiday,
      isHoliday: !!holiday,
      isSunday: dayIndex === 0,
      isSaturday: dayIndex === 6,
    };
  }

  return {
    getDayOfWeek,
    getHolidayName,
    getDateInfo,
    getHolidaysForYear,
  };
})();

})();

// ============================================================
// FILE: src/utils/notificationService.js
// ============================================================
(function() {
window.NotificationService = (() => {
  function isSupported() {
    return 'Notification' in window;
  }

  function getPermission() {
    return isSupported() ? Notification.permission : 'denied';
  }

  async function requestPermission() {
    if (!isSupported()) return 'denied';
    return await Notification.requestPermission();
  }

  function isEnabled() {
    return localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.NOTIFICATION_ENABLED) === 'true';
  }

  function setEnabled(val) {
    localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.NOTIFICATION_ENABLED, val ? 'true' : 'false');
  }

  function send(title, options = {}) {
    if (!isSupported() || !isEnabled() || getPermission() !== 'granted') return;
    try {
      new Notification(title, { icon: './icons/icon-192.png', ...options });
    } catch (e) {
      AppLogger.warn('通知送信失敗: ' + e.message);
    }
  }

  function sendTroubleAlert(text) {
    if (!text || !isEnabled()) return;
    const keywords = ['遅延', '運休', '事故', '見合わせ', '運転取りやめ', '不通'];
    const hasAlert = keywords.some(kw => text.includes(kw));
    if (hasAlert) {
      send('交通情報アラート', { body: text.slice(0, 200), tag: 'trouble-alert' });
    }
  }

  return { isSupported, getPermission, requestPermission, isEnabled, setEnabled, send, sendTroubleAlert };
})();
})();

// ============================================================
// FILE: src/utils/lightgbmService.js
// ============================================================
(function() {
// LightGBM-style Gradient Boosting Decision Tree for demand prediction
// ブラウザ内で学習・推論を完結させる軽量GBDT実装。
// 特徴: histogram-style split finding, leaf-wise growth, L2 regularization
window.LightGBMService = (() => {
  const WEATHER_CODE = { '晴れ': 0, '曇り': 1, '雨': 2, '雪': 3, '': 4, '未設定': 4 };

  // ── 単一決定木の構築 ──
  // residuals を目的変数として、分散削減基準で分割
  function buildTree(X, residuals, maxDepth, minLeaf, lambda) {
    const nF = X[0].length;

    function leafVal(idx) {
      const g = idx.reduce((s, i) => s + residuals[i], 0);
      return -g / (idx.length + lambda);
    }

    function split(idx, depth) {
      if (depth >= maxDepth || idx.length < minLeaf * 2) {
        return { v: leafVal(idx) };
      }

      let bestGain = 0, bestF = -1, bestTh = 0, bestLI = null, bestRI = null;
      const pSum = idx.reduce((s, i) => s + residuals[i], 0);
      const pH = idx.length;
      const pScore = (pSum * pSum) / (pH + lambda);

      for (let f = 0; f < nF; f++) {
        const sorted = [...idx].sort((a, b) => X[a][f] - X[b][f]);
        let lSum = 0, lH = 0;
        for (let k = 0; k < sorted.length - 1; k++) {
          lSum += residuals[sorted[k]];
          lH++;
          if (lH < minLeaf || (pH - lH) < minLeaf) continue;
          if (X[sorted[k]][f] === X[sorted[k + 1]][f]) continue;

          const rSum = pSum - lSum;
          const rH = pH - lH;
          const gain = (lSum * lSum) / (lH + lambda) + (rSum * rSum) / (rH + lambda) - pScore;

          if (gain > bestGain) {
            bestGain = gain;
            bestF = f;
            bestTh = (X[sorted[k]][f] + X[sorted[k + 1]][f]) / 2;
            bestLI = sorted.slice(0, k + 1);
            bestRI = sorted.slice(k + 1);
          }
        }
      }

      if (bestF === -1) return { v: leafVal(idx) };
      return {
        f: bestF, th: bestTh,
        l: split(bestLI, depth + 1),
        r: split(bestRI, depth + 1),
      };
    }

    return split(Array.from({ length: X.length }, (_, i) => i), 0);
  }

  function predictOne(node, x) {
    if ('v' in node) return node.v;
    return x[node.f] <= node.th ? predictOne(node.l, x) : predictOne(node.r, x);
  }

  // ── 勾配ブースティング学習 ──
  function train(X, y, opts = {}) {
    const { nTrees = 50, maxDepth = 5, lr = 0.1, minLeaf = 2, lambda = 1.0 } = opts;
    const n = X.length;
    if (n < 3) return null;

    const base = y.reduce((s, v) => s + v, 0) / n;
    const preds = new Float64Array(n).fill(base);
    const trees = [];

    for (let t = 0; t < nTrees; t++) {
      const residuals = y.map((yi, i) => yi - preds[i]);
      const tree = buildTree(X, residuals, maxDepth, minLeaf, lambda);
      trees.push(tree);
      for (let i = 0; i < n; i++) {
        preds[i] += lr * predictOne(tree, X[i]);
      }
    }

    return { trees, base, lr };
  }

  function predict(model, x) {
    if (!model) return 0;
    let p = model.base;
    for (const t of model.trees) p += model.lr * predictOne(t, x);
    return Math.max(0, p);
  }

  // ── 学習データ準備 ──
  // 売上データ + 他社乗車データから特徴量を抽出
  // features: [lat, lng, hour, dayOfWeek, weatherCode]
  // target: demand weight (金額 or 固定値)
  function prepareData() {
    const entries = DataService.getEntries();
    const rivals = DataService.getRivalEntries();
    const X = [], y = [];

    entries.forEach(e => {
      const d = new Date(e.timestamp);
      const wc = WEATHER_CODE[e.weather] ?? 4;
      const hr = d.getHours();
      const dow = d.getDay();
      const w = e.amount || 1000;
      if (e.pickupCoords && e.pickupCoords.lat && e.pickupCoords.lng) {
        X.push([e.pickupCoords.lat, e.pickupCoords.lng, hr, dow, wc]);
        y.push(w);
      }
      if (e.dropoffCoords && e.dropoffCoords.lat && e.dropoffCoords.lng) {
        X.push([e.dropoffCoords.lat, e.dropoffCoords.lng, hr, dow, wc]);
        y.push(w);
      }
    });

    rivals.forEach(r => {
      if (!r.locationCoords || !r.locationCoords.lat || !r.locationCoords.lng) return;
      const hr = r.time ? parseInt(r.time.split(':')[0], 10) : 12;
      const dow = r.date ? new Date(r.date).getDay() : 0;
      const wc = WEATHER_CODE[r.weather] ?? 4;
      X.push([r.locationCoords.lat, r.locationCoords.lng, hr, dow, wc]);
      y.push(500);
    });

    if (X.length < 3) return { X, y };

    // 負例（需要ゼロのバックグラウンドサンプル）を追加
    const latMin = Math.min(...X.map(x => x[0])) - 0.015;
    const latMax = Math.max(...X.map(x => x[0])) + 0.015;
    const lngMin = Math.min(...X.map(x => x[1])) - 0.015;
    const lngMax = Math.max(...X.map(x => x[1])) + 0.015;
    const nBg = Math.max(X.length * 2, 40);
    // seeded random for reproducibility
    let seed = 42;
    const rand = () => { seed = (seed * 16807 + 0) % 2147483647; return seed / 2147483647; };
    for (let i = 0; i < nBg; i++) {
      X.push([
        latMin + rand() * (latMax - latMin),
        lngMin + rand() * (lngMax - lngMin),
        Math.floor(rand() * 24),
        Math.floor(rand() * 7),
        Math.floor(rand() * 5),
      ]);
      y.push(0);
    }

    return { X, y };
  }

  // ── モデル学習（公開API）──
  function trainModel(opts) {
    const { X, y } = prepareData();
    if (X.length < 5) return null;
    const model = train(X, y, opts);
    if (model) {
      AppLogger.info(`LightGBM学習完了: ${model.trees.length}本の木, 学習サンプル${X.length}件`);
    }
    return model;
  }

  // ── グリッド予測（ヒートマップ用）──
  // bounds: { north, south, east, west }
  // 現在の条件（hour, dow, weather）で需要スコアを予測
  function predictGrid(model, bounds, hour, dow, weather, step) {
    if (!model || !bounds) return [];
    const wc = WEATHER_CODE[weather] ?? 4;
    // ステップ幅をバウンド幅に応じて自動調整
    const latRange = bounds.north - bounds.south;
    const lngRange = bounds.east - bounds.west;
    const gridStep = step || Math.max(Math.min(latRange, lngRange) / 60, 0.001);
    const points = [];

    for (let lat = bounds.south; lat <= bounds.north; lat += gridStep) {
      for (let lng = bounds.west; lng <= bounds.east; lng += gridStep) {
        const score = predict(model, [lat, lng, hour, dow, wc]);
        if (score > 10) {
          points.push({ lat, lng, weight: score });
        }
      }
    }

    return points;
  }

  // ── モデル情報 ──
  function getModelInfo(model) {
    if (!model) return null;
    return {
      nTrees: model.trees.length,
      basePrediction: Math.round(model.base),
    };
  }

  // ── 単価予測モデル学習 ──
  // features: [lat, lng, hour, dayOfWeek, weatherCode]
  // target: 金額（¥）
  function preparePriceData() {
    const entries = DataService.getEntries();
    const X = [], y = [];

    entries.forEach(e => {
      if (!e.pickupCoords || !e.pickupCoords.lat || !e.pickupCoords.lng) return;
      if (!e.amount || e.amount <= 0) return;
      const d = new Date(e.timestamp);
      const wc = WEATHER_CODE[e.weather] ?? 4;
      const hr = e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : d.getHours();
      const dow = d.getDay();
      X.push([e.pickupCoords.lat, e.pickupCoords.lng, hr, dow, wc]);
      y.push(e.amount);
    });

    return { X, y };
  }

  function trainPriceModel(opts) {
    const { X, y } = preparePriceData();
    if (X.length < 5) return null;
    const model = train(X, y, { nTrees: 40, maxDepth: 4, lr: 0.1, minLeaf: 2, lambda: 1.0, ...opts });
    if (model) {
      AppLogger.info(`単価予測モデル学習完了: ${model.trees.length}本の木, 学習サンプル${X.length}件`);
    }
    return model;
  }

  // ── 単価予測グリッド ──
  function predictPriceGrid(model, bounds, hour, dow, weather, step) {
    if (!model || !bounds) return [];
    const wc = WEATHER_CODE[weather] ?? 4;
    const latRange = bounds.north - bounds.south;
    const lngRange = bounds.east - bounds.west;
    const gridStep = step || Math.max(Math.min(latRange, lngRange) / 40, 0.002);
    const points = [];

    for (let lat = bounds.south; lat <= bounds.north; lat += gridStep) {
      for (let lng = bounds.west; lng <= bounds.east; lng += gridStep) {
        const price = predict(model, [lat, lng, hour, dow, wc]);
        if (price > 100) {
          const tier = price <= 1000 ? 'short' : price <= 1999 ? 'mid' : 'long';
          points.push({ lat, lng, price: Math.round(price), tier });
        }
      }
    }

    return points;
  }

  return { trainModel, trainPriceModel, predict, predictGrid, predictPriceGrid, getModelInfo, WEATHER_CODE };
})();
})();

// ============================================================
// FILE: src/utils/dataService.js
// ============================================================
(function() {
// dataService.js - データ処理層（ビジネスロジック）
//
// 売上データの集計・分析・エクスポートを一元管理するサービス層。
// Dashboard, Analytics, Revenue の全ページがこのサービスを通じてデータにアクセスする。

window.DataService = (() => {
  // ============================================================
  // データ取得（キャッシュ付き）
  // ============================================================
  let _entriesCache = null;
  let _entriesCacheRaw = null;
  let _rivalCache = null;
  let _rivalCacheRaw = null;

  function getEntries() {
    try {
      const saved = localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.REVENUE_DATA);
      if (saved === _entriesCacheRaw && _entriesCache !== null) return _entriesCache;
      const entries = saved ? JSON.parse(saved) : [];
      entries.forEach(e => {
        if (e.date) {
          const info = JapaneseHolidays.getDateInfo(e.date);
          e.dayOfWeek = info.dayOfWeek;
          e.holiday = info.holiday || '';
        }
      });
      _entriesCacheRaw = saved;
      _entriesCache = _sortByDateTimeDesc(entries, 'date', 'dropoffTime');
      return _entriesCache;
    } catch {
      return [];
    }
  }

  function _sortByDateTimeDesc(entries, dateKey, timeKey) {
    return entries.sort((a, b) => {
      const dateA = a[dateKey] || '';
      const dateB = b[dateKey] || '';
      if (dateA !== dateB) return dateB.localeCompare(dateA);
      const timeA = a[timeKey] || '';
      const timeB = b[timeKey] || '';
      if (timeA !== timeB) return timeB.localeCompare(timeA);
      const tsA = a.timestamp || '';
      const tsB = b.timestamp || '';
      return tsB.localeCompare(tsA);
    });
  }

  function saveEntries(entries) {
    try {
      _sortByDateTimeDesc(entries, 'date', 'dropoffTime');
      const json = JSON.stringify(entries);
      localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.REVENUE_DATA, json);
      _entriesCacheRaw = json;
      _entriesCache = entries;
      return true;
    } catch (e) {
      AppLogger.error('売上データの保存に失敗しました', e.message);
      return false;
    }
  }

  // ============================================================
  // ファイル保存・復元（売上データフォルダ）
  // ============================================================
  let _dirHandle = null; // File System Access API用

  // ── IndexedDB でフォルダハンドルを永続化 ──
  const _DB_NAME = 'taxi_app_fs';
  const _DB_STORE = 'handles';
  const _DB_KEY = 'saveDir';

  function _openHandleDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(_DB_NAME, 1);
      req.onupgradeneeded = () => req.result.createObjectStore(_DB_STORE);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function _persistHandle(handle) {
    try {
      const db = await _openHandleDB();
      const tx = db.transaction(_DB_STORE, 'readwrite');
      tx.objectStore(_DB_STORE).put(handle, _DB_KEY);
      await new Promise((r, j) => { tx.oncomplete = r; tx.onerror = j; });
      db.close();
    } catch (e) {
      AppLogger.warn('ハンドル永続化失敗: ' + e.message);
    }
  }

  async function _restoreHandle() {
    try {
      const db = await _openHandleDB();
      const tx = db.transaction(_DB_STORE, 'readonly');
      const req = tx.objectStore(_DB_STORE).get(_DB_KEY);
      const handle = await new Promise((r, j) => { req.onsuccess = () => r(req.result); req.onerror = j; });
      db.close();
      if (handle) {
        _dirHandle = handle;
        AppLogger.info('保存先フォルダを自動復元: ' + handle.name);
      }
    } catch (e) {
      AppLogger.warn('ハンドル復元失敗: ' + e.message);
    }
  }

  // 起動時に自動復元（Promiseを保持し、保存時にawait）
  const _handleReady = _restoreHandle();

  // サブフォルダのハンドルを取得（なければ自動作成）
  async function _getSubFolder(subName) {
    if (!_dirHandle) return null;
    try {
      const perm = await _dirHandle.queryPermission({ mode: 'readwrite' });
      if (perm !== 'granted') {
        const req = await _dirHandle.requestPermission({ mode: 'readwrite' });
        if (req !== 'granted') return null;
      }
      return await _dirHandle.getDirectoryHandle(subName, { create: true });
    } catch (e) {
      AppLogger.warn(`サブフォルダ取得失敗 (${subName}): ` + e.message);
      return null;
    }
  }

  // File System Access APIでサブフォルダにJSONを直接保存
  async function _saveToSubFolder(subName, fileName, entries, version) {
    try {
      const subDir = await _getSubFolder(subName);
      if (!subDir) return false;
      const fileHandle = await subDir.getFileHandle(fileName, { create: true });
      const writable = await fileHandle.createWritable();
      const data = JSON.stringify({ version: version, exportedAt: new Date().toISOString(), count: entries.length, entries: entries }, null, 2);
      await writable.write(data);
      await writable.close();
      AppLogger.info(`ファイル保存完了: ${subName}/${fileName} (${entries.length}件)`);
      return true;
    } catch (e) {
      AppLogger.warn(`フォルダ保存失敗 (${subName}): ` + e.message);
      return false;
    }
  }

  // ダウンロード方式でJSON保存（フォールバック）
  function _downloadBackup(entries) {
    try {
      const dateStr = getLocalDateString();
      const data = JSON.stringify({ version: APP_CONSTANTS.VERSION, exportedAt: new Date().toISOString(), count: entries.length, entries: entries }, null, 2);
      const blob = new Blob([data], { type: 'application/json;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `売上記録_${dateStr}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      AppLogger.info(`バックアップダウンロード: ${entries.length}件`);
      return true;
    } catch (e) {
      AppLogger.warn('バックアップ失敗: ' + e.message);
      return false;
    }
  }

  function _downloadRivalBackup(entries) {
    try {
      const dateStr = getLocalDateString();
      const data = JSON.stringify({ version: APP_CONSTANTS.VERSION, exportedAt: new Date().toISOString(), count: entries.length, entries: entries }, null, 2);
      const blob = new Blob([data], { type: 'application/json;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `他社乗車記録_${dateStr}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      AppLogger.info(`他社乗車バックアップダウンロード: ${entries.length}件`);
      return true;
    } catch (e) {
      AppLogger.warn('他社乗車バックアップ失敗: ' + e.message);
      return false;
    }
  }

  // 売上記録の自動保存（サブフォルダ「売上記録」）
  async function autoSaveToFile() {
    await _handleReady;
    if (!_dirHandle) return;
    const entries = getEntries();
    if (entries.length === 0) return;
    const dateStr = getLocalDateString();
    await _saveToSubFolder('売上記録', `売上記録_${dateStr}.json`, entries, APP_CONSTANTS.VERSION);
  }

  // 他社乗車記録の自動保存（サブフォルダ「他社乗車」）
  async function autoSaveRivalToFile() {
    await _handleReady;
    if (!_dirHandle) return;
    const entries = getRivalEntries();
    if (entries.length === 0) return;
    const dateStr = getLocalDateString();
    await _saveToSubFolder('他社乗車', `他社乗車記録_${dateStr}.json`, entries, APP_CONSTANTS.VERSION);
  }

  // 手動JSON保存（ボタン押下時）— フォルダ未設定時はダウンロード
  async function manualSaveToFile() {
    await _handleReady;
    const entries = getEntries();
    if (entries.length === 0) return;
    if (_dirHandle) {
      const dateStr = getLocalDateString();
      const ok = await _saveToSubFolder('売上記録', `売上記録_${dateStr}.json`, entries, APP_CONSTANTS.VERSION);
      if (ok) return;
    }
    _downloadBackup(entries);
  }

  async function manualSaveRivalToFile() {
    await _handleReady;
    const entries = getRivalEntries();
    if (entries.length === 0) return;
    if (_dirHandle) {
      const dateStr = getLocalDateString();
      const ok = await _saveToSubFolder('他社乗車', `他社乗車記録_${dateStr}.json`, entries, APP_CONSTANTS.VERSION);
      if (ok) return;
    }
    _downloadRivalBackup(entries);
  }

  // 保存先フォルダを選択（File System Access API）
  async function selectSaveFolder() {
    if (!window.showDirectoryPicker) {
      return { success: false, message: 'このブラウザではフォルダ直接保存がサポートされていません。ダウンロード方式で保存します。' };
    }
    try {
      _dirHandle = await window.showDirectoryPicker({ id: 'taxi-save', mode: 'readwrite', startIn: 'documents' });
      await _persistHandle(_dirHandle);
      AppLogger.info('保存先フォルダを設定・永続化: ' + _dirHandle.name)
      return { success: true, folderName: _dirHandle.name };
    } catch (e) {
      if (e.name === 'AbortError') return { success: false, message: 'フォルダ選択がキャンセルされました' };
      return { success: false, message: 'フォルダ選択に失敗: ' + e.message };
    }
  }

  // JSONファイルから復元
  // インポートデータのサニタイズ
  const MAX_IMPORT_FILE_SIZE = 10 * 1024 * 1024; // 10MB
  const MAX_STRING_LENGTH = 500;
  function _sanitizeEntry(entry) {
    const stripHtml = (s) => typeof s === 'string' ? s.replace(/<[^>]*>/g, '').slice(0, MAX_STRING_LENGTH) : '';
    return {
      id: stripHtml(entry.id),
      amount: typeof entry.amount === 'number' && isFinite(entry.amount) ? Math.max(0, Math.min(entry.amount, 1000000)) : 0,
      date: typeof entry.date === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(entry.date) ? entry.date : '',
      dayOfWeek: stripHtml(entry.dayOfWeek),
      holiday: stripHtml(entry.holiday),
      weather: stripHtml(entry.weather),
      pickup: stripHtml(entry.pickup),
      pickupTime: stripHtml(entry.pickupTime),
      dropoff: stripHtml(entry.dropoff),
      dropoffTime: stripHtml(entry.dropoffTime),
      passengers: stripHtml(entry.passengers),
      gender: stripHtml(entry.gender),
      purpose: stripHtml(entry.purpose),
      memo: stripHtml(entry.memo),
      source: stripHtml(entry.source),
      pickupCoords: entry.pickupCoords && typeof entry.pickupCoords.lat === 'number' ? { lat: entry.pickupCoords.lat, lng: entry.pickupCoords.lng } : null,
      dropoffCoords: entry.dropoffCoords && typeof entry.dropoffCoords.lat === 'number' ? { lat: entry.dropoffCoords.lat, lng: entry.dropoffCoords.lng } : null,
      timestamp: typeof entry.timestamp === 'string' ? entry.timestamp.slice(0, 30) : new Date().toISOString(),
    };
  }

  async function importFromFile() {
    return new Promise((resolve) => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) { resolve({ success: false, message: 'ファイルが選択されませんでした' }); return; }
        if (file.size > MAX_IMPORT_FILE_SIZE) { resolve({ success: false, message: 'ファイルサイズが10MBを超えています' }); return; }
        const reader = new FileReader();
        reader.onload = (ev) => {
          try {
            const data = JSON.parse(ev.target.result);
            let entries = [];
            if (Array.isArray(data)) {
              entries = data;
            } else if (data.entries && Array.isArray(data.entries)) {
              entries = data.entries;
            } else {
              resolve({ success: false, message: 'ファイル形式が正しくありません' }); return;
            }
            // 既存データとマージ（IDで重複排除 + サニタイズ）
            const existing = getEntries();
            const existingIds = new Set(existing.map(e => e.id));
            let newCount = 0;
            entries.forEach(entry => {
              const sanitized = _sanitizeEntry(entry);
              if (!existingIds.has(sanitized.id) && sanitized.amount > 0) {
                existing.push(sanitized);
                newCount++;
              }
            });
            existing.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            saveEntries(existing);
            AppLogger.info(`ファイルから復元: ${newCount}件追加 (合計${existing.length}件)`);
            resolve({ success: true, message: `${newCount}件の新しい記録を復元しました（合計${existing.length}件）` });
          } catch (err) {
            resolve({ success: false, message: 'ファイルの読み込みに失敗: ' + err.message });
          }
        };
        reader.readAsText(file);
      };
      input.click();
    });
  }

  // 保存フォルダが設定済みかどうか
  function hasSaveFolder() {
    return !!_dirHandle;
  }

  // ============================================================
  // クラウド同期（Vercel Blob Storage）
  // ============================================================
  function _getSyncSecret() {
    return (localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.SYNC_SECRET) || '').trim();
  }

  const ALLOWED_SYNC_TYPES = ['revenue', 'rival'];

  async function _syncToCloud(type, entries) {
    if (!ALLOWED_SYNC_TYPES.includes(type)) { AppLogger.warn('不正な同期タイプ: ' + type); return; }
    try {
      const secret = _getSyncSecret();
      const params = new URLSearchParams({ type });
      const res = await fetch(`/api/data?${params}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(secret ? { 'Authorization': `Bearer ${secret}` } : {}),
        },
        body: JSON.stringify({
          version: APP_CONSTANTS.VERSION,
          syncedAt: new Date().toISOString(),
          count: entries.length,
          entries,
        }),
      });
      if (res.ok) {
        AppLogger.info(`クラウド同期完了: ${type} (${entries.length}件)`);
      } else {
        AppLogger.warn(`クラウド同期失敗: ${res.status}`);
      }
    } catch (e) {
      AppLogger.warn('クラウド同期エラー: ' + e.message);
    }
  }

  async function loadFromCloud(type) {
    if (!ALLOWED_SYNC_TYPES.includes(type)) { AppLogger.warn('不正な同期タイプ: ' + type); return null; }
    try {
      const params = new URLSearchParams({ type });
      const res = await fetch(`/api/data?${params}`);
      if (!res.ok) return null;
      const data = await res.json();
      if (!data || typeof data !== 'object') return null;
      return Array.isArray(data.entries) ? data.entries : [];
    } catch (e) {
      AppLogger.warn('クラウド読込エラー: ' + e.message);
      return null;
    }
  }

  async function syncFromCloud(type) {
    const cloudEntries = await loadFromCloud(type);
    if (!cloudEntries || cloudEntries.length === 0) return { merged: 0 };

    const local = type === 'revenue' ? getEntries() : getRivalEntries();
    const localIds = new Set(local.map(e => e.id));
    let merged = 0;
    cloudEntries.forEach(entry => {
      if (!localIds.has(entry.id)) {
        local.push(entry);
        merged++;
      }
    });
    if (merged > 0) {
      local.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      if (type === 'revenue') saveEntries(local);
      else saveRivalEntries(local);
    }
    return { merged, total: local.length };
  }

  async function autoSync() {
    try {
      const [r1, r2] = await Promise.all([
        syncFromCloud('revenue'),
        syncFromCloud('rival'),
      ]);
      const totalMerged = (r1.merged || 0) + (r2.merged || 0);
      if (totalMerged > 0) {
        AppLogger.info(`自動同期完了: 売上+${r1.merged}件, 他社+${r2.merged}件`);
      } else {
        AppLogger.debug('自動同期: 新規データなし');
      }
      return { revenue: r1, rival: r2 };
    } catch (e) {
      AppLogger.warn('自動同期エラー: ' + e.message);
      return null;
    }
  }

  // ============================================================
  // 日付ヘルパー
  // ============================================================
  function toDateStr(isoString) {
    return isoString ? isoString.split('T')[0] : '';
  }

  function toHour(isoString) {
    return isoString ? new Date(isoString).getHours() : 0;
  }

  function getDayOfWeek(isoString) {
    const days = ['日', '月', '火', '水', '木', '金', '土'];
    return days[new Date(isoString).getDay()];
  }

  function getDayOfWeekIndex(isoString) {
    return new Date(isoString).getDay();
  }

  function getWeekStart(date) {
    const d = new Date(date);
    const day = d.getDay();
    const diff = d.getDate() - day + (day === 0 ? -6 : 1);
    d.setDate(diff);
    return toDateStr(d.toISOString());
  }

  function getMonthStr(isoString) {
    const d = new Date(isoString);
    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
  }

  // ============================================================
  // 本日のサマリー（Dashboard用）
  // ============================================================
  function getTodaySummary() {
    const entries = getEntries();
    const today = toDateStr(new Date().toISOString());
    const todayEntries = entries.filter(e => toDateStr(e.timestamp) === today);

    const totalAmount = todayEntries.reduce((sum, e) => sum + (e.amount || 0), 0);
    const rideCount = todayEntries.length;
    const avgAmount = rideCount > 0 ? Math.round(totalAmount / rideCount) : 0;

    // 稼働時間の計算（最初の記録〜最後の記録）
    let workMinutes = 0;
    if (todayEntries.length >= 2) {
      const sorted = [...todayEntries].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      const first = new Date(sorted[0].timestamp);
      const last = new Date(sorted[sorted.length - 1].timestamp);
      workMinutes = Math.round((last - first) / 60000);
    }
    const workHours = Math.floor(workMinutes / 60);
    const workMins = workMinutes % 60;

    return {
      totalAmount,
      rideCount,
      avgAmount,
      workTime: `${workHours}h ${workMins}m`,
      workMinutes,
      entries: todayEntries,
    };
  }

  // ============================================================
  // 全期間サマリー
  // ============================================================
  function getOverallSummary() {
    const entries = getEntries();
    const totalAmount = entries.reduce((sum, e) => sum + (e.amount || 0), 0);
    const rideCount = entries.length;
    const avgAmount = rideCount > 0 ? Math.round(totalAmount / rideCount) : 0;

    // 日数計算
    const uniqueDays = new Set(entries.map(e => toDateStr(e.timestamp)));
    const activeDays = uniqueDays.size;
    const dailyAvg = activeDays > 0 ? Math.round(totalAmount / activeDays) : 0;

    return {
      totalAmount,
      rideCount,
      avgAmount,
      activeDays,
      dailyAvg,
    };
  }

  // ============================================================
  // 日別集計（Analytics用）
  // ============================================================
  function getDailyBreakdown(days = 30) {
    const entries = getEntries();
    const result = {};

    // 過去N日分の枠を作る
    for (let i = days - 1; i >= 0; i--) {
      const d = new Date();
      d.setDate(d.getDate() - i);
      const key = toDateStr(d.toISOString());
      result[key] = { date: key, amount: 0, count: 0 };
    }

    entries.forEach(e => {
      const key = e.date || toDateStr(e.timestamp);
      if (result[key]) {
        result[key].amount += e.amount || 0;
        result[key].count += 1;
      }
    });

    return Object.values(result);
  }

  // ============================================================
  // 曜日別集計（Analytics用）
  // ============================================================
  function getDayOfWeekBreakdown() {
    const entries = getEntries();
    const days = ['日', '月', '火', '水', '木', '金', '土'];
    const result = days.map((name, i) => ({ name, index: i, amount: 0, count: 0, avg: 0 }));

    entries.forEach(e => {
      const dateStr = e.date || toDateStr(e.timestamp);
      const idx = dateStr ? new Date(dateStr + 'T00:00:00').getDay() : getDayOfWeekIndex(e.timestamp);
      result[idx].amount += e.amount || 0;
      result[idx].count += 1;
    });

    result.forEach(d => {
      d.avg = d.count > 0 ? Math.round(d.amount / d.count) : 0;
    });

    return result;
  }

  // ============================================================
  // 時間帯別集計（Analytics用）
  // ============================================================
  function getHourlyBreakdown() {
    const entries = getEntries();
    const result = [];

    for (let h = 0; h < 24; h++) {
      result.push({ hour: h, label: `${h}時`, amount: 0, count: 0, avg: 0 });
    }

    entries.forEach(e => {
      const time = e.dropoffTime || e.pickupTime || '';
      const h = time ? parseInt(time.split(':')[0], 10) : toHour(e.timestamp);
      if (h >= 0 && h < 24) {
        result[h].amount += e.amount || 0;
        result[h].count += 1;
      }
    });

    result.forEach(d => {
      d.avg = d.count > 0 ? Math.round(d.amount / d.count) : 0;
    });

    return result;
  }

  // ============================================================
  // エリア別集計（乗車地・降車地の頻度）
  // ============================================================
  function getAreaBreakdown() {
    const entries = getEntries();
    const pickups = {};
    const dropoffs = {};

    entries.forEach(e => {
      if (e.pickup) {
        pickups[e.pickup] = (pickups[e.pickup] || { name: e.pickup, count: 0, amount: 0 });
        pickups[e.pickup].count += 1;
        pickups[e.pickup].amount += e.amount || 0;
      }
      if (e.dropoff) {
        dropoffs[e.dropoff] = (dropoffs[e.dropoff] || { name: e.dropoff, count: 0, amount: 0 });
        dropoffs[e.dropoff].count += 1;
        dropoffs[e.dropoff].amount += e.amount || 0;
      }
    });

    return {
      pickups: Object.values(pickups).sort((a, b) => b.count - a.count).slice(0, 10),
      dropoffs: Object.values(dropoffs).sort((a, b) => b.count - a.count).slice(0, 10),
    };
  }

  // ============================================================
  // 天候別集計
  // ============================================================
  function getWeatherBreakdown() {
    const entries = getEntries();
    const weathers = ['晴れ', '曇り', '雨', '雪', '未設定'];
    const result = {};
    weathers.forEach(w => { result[w] = { name: w, amount: 0, count: 0, avg: 0 }; });

    entries.forEach(e => {
      const w = e.weather && weathers.includes(e.weather) ? e.weather : '未設定';
      result[w].amount += e.amount || 0;
      result[w].count += 1;
    });

    weathers.forEach(w => {
      result[w].avg = result[w].count > 0 ? Math.round(result[w].amount / result[w].count) : 0;
    });

    return weathers.map(w => result[w]);
  }

  // ============================================================
  // 配車方法別集計
  // ============================================================
  function getSourceBreakdown() {
    const entries = getEntries();
    const sources = ['Go', 'Uber', 'DIDI', '電話', '流し', '未設定'];
    const result = {};
    sources.forEach(s => { result[s] = { name: s, amount: 0, count: 0, avg: 0 }; });

    entries.forEach(e => {
      const s = e.source && sources.includes(e.source) ? e.source : '未設定';
      result[s].amount += e.amount || 0;
      result[s].count += 1;
    });

    sources.forEach(s => {
      result[s].avg = result[s].count > 0 ? Math.round(result[s].amount / result[s].count) : 0;
    });

    return sources.map(s => result[s]);
  }

  // ============================================================
  // 用途別集計
  // ============================================================
  function getPurposeBreakdown() {
    const entries = getEntries();
    const purposes = ['通勤', '通院', '買物', '観光', '出張', '送迎', '空港', '飲食', 'パチンコ', '未設定'];
    const result = {};
    purposes.forEach(p => { result[p] = { name: p, amount: 0, count: 0, avg: 0 }; });

    entries.forEach(e => {
      const p = e.purpose && purposes.includes(e.purpose) ? e.purpose : '未設定';
      result[p].amount += e.amount || 0;
      result[p].count += 1;
    });

    purposes.forEach(p => {
      result[p].avg = result[p].count > 0 ? Math.round(result[p].amount / result[p].count) : 0;
    });

    return purposes.map(p => result[p]);
  }

  // ============================================================
  // 用途×曜日×日種別（平日/休日/大型連休）クロス分析
  // ============================================================
  function getPurposeDayAnalysis() {
    const entries = getEntries();
    const purposes = ['通勤', '通院', '買物', '観光', '出張', '送迎', '空港', '飲食', 'パチンコ'];
    const dayNames = ['日', '月', '火', '水', '木', '金', '土'];

    // 大型連休判定（3日以上連続する祝日/休日をlong holidayとする）
    function classifyDayType(dateStr) {
      const info = JapaneseHolidays.getDateInfo(dateStr);
      const dayIdx = new Date(dateStr + 'T00:00:00').getDay();
      // 祝日または土日
      const isOff = info.isHoliday || dayIdx === 0 || dayIdx === 6;
      if (!isOff) return 'weekday';
      // 大型連休判定: 前後に連続する休日を数える
      let streak = 1;
      for (let d = 1; d <= 5; d++) {
        const prev = new Date(dateStr + 'T00:00:00');
        prev.setDate(prev.getDate() - d);
        const ps = `${prev.getFullYear()}-${String(prev.getMonth()+1).padStart(2,'0')}-${String(prev.getDate()).padStart(2,'0')}`;
        const pi = JapaneseHolidays.getDateInfo(ps);
        const pd = prev.getDay();
        if (pi.isHoliday || pd === 0 || pd === 6) streak++; else break;
      }
      for (let d = 1; d <= 5; d++) {
        const next = new Date(dateStr + 'T00:00:00');
        next.setDate(next.getDate() + d);
        const ns = `${next.getFullYear()}-${String(next.getMonth()+1).padStart(2,'0')}-${String(next.getDate()).padStart(2,'0')}`;
        const ni = JapaneseHolidays.getDateInfo(ns);
        const nd = next.getDay();
        if (ni.isHoliday || nd === 0 || nd === 6) streak++; else break;
      }
      return streak >= 3 ? 'longHoliday' : 'holiday';
    }

    // 用途×曜日マトリクス
    const matrix = {};
    purposes.forEach(p => {
      matrix[p] = {};
      dayNames.forEach(d => { matrix[p][d] = { count: 0, amount: 0 }; });
    });

    // 用途×日種別マトリクス
    const typeMatrix = {};
    purposes.forEach(p => {
      typeMatrix[p] = { weekday: { count: 0, amount: 0 }, holiday: { count: 0, amount: 0 }, longHoliday: { count: 0, amount: 0 } };
    });

    // 日別集計（日種別ごとの日数カウント用）
    const dateSet = new Set();
    const dateDayTypeMap = {};

    entries.forEach(e => {
      const p = e.purpose && purposes.includes(e.purpose) ? e.purpose : null;
      if (!p) return;
      const dateStr = e.date || '';
      if (!dateStr) return;

      const dow = e.dayOfWeek || JapaneseHolidays.getDayOfWeek(dateStr);
      if (dow && matrix[p][dow]) {
        matrix[p][dow].count += 1;
        matrix[p][dow].amount += e.amount || 0;
      }

      if (!dateDayTypeMap[dateStr]) {
        dateDayTypeMap[dateStr] = classifyDayType(dateStr);
      }
      const dayType = dateDayTypeMap[dateStr];
      typeMatrix[p][dayType].count += 1;
      typeMatrix[p][dayType].amount += e.amount || 0;

      dateSet.add(dateStr);
    });

    // 日種別ごとの日数
    const dayTypeCounts = { weekday: 0, holiday: 0, longHoliday: 0 };
    const allDates = new Set();
    entries.forEach(e => { if (e.date) allDates.add(e.date); });
    allDates.forEach(d => {
      if (!dateDayTypeMap[d]) dateDayTypeMap[d] = classifyDayType(d);
      dayTypeCounts[dateDayTypeMap[d]]++;
    });

    // 月別・用途別トレンド
    const monthPurpose = {};
    entries.forEach(e => {
      const p = e.purpose && purposes.includes(e.purpose) ? e.purpose : null;
      if (!p || !e.date) return;
      const month = e.date.substring(0, 7); // YYYY-MM
      if (!monthPurpose[month]) {
        monthPurpose[month] = {};
        purposes.forEach(pp => { monthPurpose[month][pp] = 0; });
      }
      monthPurpose[month][p]++;
    });

    // 予測生成: 今後30日間で各日にどの用途が増えそうか
    const predictions = [];
    const today = new Date();
    for (let i = 0; i < 30; i++) {
      const futureDate = new Date(today);
      futureDate.setDate(futureDate.getDate() + i);
      const ds = `${futureDate.getFullYear()}-${String(futureDate.getMonth()+1).padStart(2,'0')}-${String(futureDate.getDate()).padStart(2,'0')}`;
      const dow = dayNames[futureDate.getDay()];
      const dayType = classifyDayType(ds);
      const info = JapaneseHolidays.getDateInfo(ds);

      // 各用途のスコアを計算（曜日パターン + 日種別パターン）
      const scores = purposes.map(p => {
        const dowData = matrix[p][dow] || { count: 0 };
        const typeData = typeMatrix[p][dayType] || { count: 0 };
        // 曜日スコアと日種別スコアの加重平均
        const dowScore = dowData.count;
        const typeScore = typeData.count;
        return { purpose: p, score: dowScore * 0.6 + typeScore * 0.4, dowCount: dowData.count, typeCount: typeData.count };
      }).filter(s => s.score > 0).sort((a, b) => b.score - a.score);

      if (scores.length > 0) {
        predictions.push({
          date: ds,
          dayOfWeek: dow,
          dayType,
          holiday: info.holiday || null,
          topPurposes: scores.slice(0, 3),
        });
      }
    }

    return {
      matrix,        // 用途×曜日
      typeMatrix,    // 用途×日種別
      dayTypeCounts, // 日種別ごとの日数
      monthPurpose,  // 月別×用途
      predictions,   // 今後30日の予測
      purposes,
      dayNames,
    };
  }

  // ============================================================
  // エリア×時間帯クロス集計
  // ============================================================
  function getAreaTimeBreakdown() {
    const entries = getEntries();
    const areaMap = {};

    entries.forEach(e => {
      const area = e.pickup || '';
      if (!area) return;
      const hour = e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : toHour(e.timestamp);

      if (!areaMap[area]) {
        areaMap[area] = { area, hours: {}, totalCount: 0, totalAmount: 0 };
      }
      areaMap[area].totalCount += 1;
      areaMap[area].totalAmount += e.amount || 0;

      if (!areaMap[area].hours[hour]) {
        areaMap[area].hours[hour] = { hour, count: 0, amount: 0 };
      }
      areaMap[area].hours[hour].count += 1;
      areaMap[area].hours[hour].amount += e.amount || 0;
    });

    return Object.values(areaMap)
      .sort((a, b) => b.totalCount - a.totalCount)
      .slice(0, 10)
      .map(a => ({
        area: a.area,
        totalCount: a.totalCount,
        totalAmount: a.totalAmount,
        hours: Array.from({ length: 24 }, (_, h) => a.hours[h] || { hour: h, count: 0, amount: 0 }),
      }));
  }

  // ============================================================
  // 客単価分析
  // ============================================================
  function getUnitPriceAnalysis() {
    const entries = getEntries();
    const dayNames = ['日', '月', '火', '水', '木', '金', '土'];

    const byDow = {};
    dayNames.forEach(d => { byDow[d] = { name: d, total: 0, count: 0, avg: 0 }; });

    const byHour = {};
    for (let h = 0; h < 24; h++) { byHour[h] = { name: h + '時', hour: h, total: 0, count: 0, avg: 0 }; }

    const weathers = ['晴れ', '曇り', '雨', '雪', '未設定'];
    const byWeather = {};
    weathers.forEach(w => { byWeather[w] = { name: w, total: 0, count: 0, avg: 0 }; });

    const purposes = ['通勤', '通院', '買物', '観光', '出張', '送迎', '空港', '飲食', 'パチンコ', '未設定'];
    const byPurpose = {};
    purposes.forEach(p => { byPurpose[p] = { name: p, total: 0, count: 0, avg: 0 }; });

    const passengerLabels = ['1人', '2人', '3人以上'];
    const byPassengers = {};
    passengerLabels.forEach(p => { byPassengers[p] = { name: p, total: 0, count: 0, avg: 0 }; });

    entries.forEach(e => {
      const amt = e.amount || 0;

      const dow = getDayOfWeek(e.timestamp);
      byDow[dow].total += amt;
      byDow[dow].count += 1;

      const hr = e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : toHour(e.timestamp);
      byHour[hr].total += amt;
      byHour[hr].count += 1;

      const w = e.weather && weathers.includes(e.weather) ? e.weather : '未設定';
      byWeather[w].total += amt;
      byWeather[w].count += 1;

      const p = e.purpose && purposes.includes(e.purpose) ? e.purpose : '未設定';
      byPurpose[p].total += amt;
      byPurpose[p].count += 1;

      const pNum = parseInt(e.passengers, 10) || 0;
      const pKey = pNum <= 1 ? '1人' : pNum === 2 ? '2人' : '3人以上';
      byPassengers[pKey].total += amt;
      byPassengers[pKey].count += 1;
    });

    const calcAvg = obj => { Object.values(obj).forEach(v => { v.avg = v.count > 0 ? Math.round(v.total / v.count) : 0; }); };
    calcAvg(byDow); calcAvg(byHour); calcAvg(byWeather); calcAvg(byPurpose); calcAvg(byPassengers);

    return {
      byDayOfWeek: dayNames.map(d => byDow[d]),
      byHour: Array.from({ length: 24 }, (_, h) => byHour[h]),
      byWeather: weathers.map(w => byWeather[w]),
      byPurpose: purposes.map(p => byPurpose[p]),
      byPassengers: passengerLabels.map(p => byPassengers[p]),
    };
  }

  // ============================================================
  // 今日のおすすめ（業務推奨）
  // ============================================================
  function getBusinessRecommendation() {
    const now = new Date();
    const currentHour = now.getHours();
    const currentDow = getDayOfWeek(now.toISOString());
    const currentDowIndex = now.getDay();

    const entries = getEntries();

    // 現在の時間帯で売上が高いエリアTOP3
    const areaByHour = {};
    entries.forEach(e => {
      const hr = e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : toHour(e.timestamp);
      if (hr === currentHour && e.pickup) {
        if (!areaByHour[e.pickup]) areaByHour[e.pickup] = { name: e.pickup, amount: 0, count: 0 };
        areaByHour[e.pickup].amount += e.amount || 0;
        areaByHour[e.pickup].count += 1;
      }
    });
    const topAreas = Object.values(areaByHour).sort((a, b) => b.amount - a.amount).slice(0, 3);

    // 今日の曜日で平均単価が高い時間帯TOP3
    const hourByDow = {};
    for (let h = 0; h < 24; h++) hourByDow[h] = { hour: h, name: h + '時', total: 0, count: 0, avg: 0 };
    entries.forEach(e => {
      const dow = getDayOfWeekIndex(e.timestamp);
      if (dow === currentDowIndex) {
        const hr = e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : toHour(e.timestamp);
        hourByDow[hr].total += e.amount || 0;
        hourByDow[hr].count += 1;
      }
    });
    Object.values(hourByDow).forEach(v => { v.avg = v.count > 0 ? Math.round(v.total / v.count) : 0; });
    const topHours = Object.values(hourByDow).filter(v => v.count > 0).sort((a, b) => b.avg - a.avg).slice(0, 3);

    // 推定客単価（曜日+時間帯の平均）
    let estTotal = 0, estCount = 0;
    entries.forEach(e => {
      const dow = getDayOfWeekIndex(e.timestamp);
      const hr = e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : toHour(e.timestamp);
      if (dow === currentDowIndex && hr === currentHour) {
        estTotal += e.amount || 0;
        estCount += 1;
      }
    });
    const estimatedUnitPrice = estCount > 0 ? Math.round(estTotal / estCount) : 0;

    return {
      topAreas,
      topHours,
      estimatedUnitPrice,
      currentCondition: { dayOfWeek: currentDow, hour: currentHour },
    };
  }

  // ============================================================
  // 配車方法×エリア×単価ランク クロス分析
  // ============================================================
  function getSourceAreaPriceBreakdown() {
    const entries = getEntries();
    const sources = ['Go', 'Uber', 'DIDI', '電話', '流し'];
    const priceTiers = [
      { key: 'short', label: '¥1,000以下', min: 0, max: 1000 },
      { key: 'mid', label: '¥1,001〜1,999', min: 1001, max: 1999 },
      { key: 'long', label: '¥2,000以上', min: 2000, max: Infinity },
    ];

    // 配車方法×エリアごとの集計
    const sourceAreaMap = {};
    // 配車方法×単価ランクの集計
    const sourceTierMap = {};
    sources.forEach(s => {
      sourceTierMap[s] = {};
      priceTiers.forEach(t => { sourceTierMap[s][t.key] = { count: 0, amount: 0 }; });
    });
    // エリア×単価ランクの集計
    const areaTierMap = {};

    entries.forEach(e => {
      const src = e.source && sources.includes(e.source) ? e.source : null;
      const area = e.pickup || '';
      const amt = e.amount || 0;
      const tier = amt <= 1000 ? 'short' : amt <= 1999 ? 'mid' : 'long';

      // 配車方法×エリア
      if (src && area) {
        const key = src + '::' + area;
        if (!sourceAreaMap[key]) sourceAreaMap[key] = { source: src, area, count: 0, amount: 0, avg: 0, tiers: { short: 0, mid: 0, long: 0 } };
        sourceAreaMap[key].count += 1;
        sourceAreaMap[key].amount += amt;
        sourceAreaMap[key].tiers[tier] += 1;
      }

      // 配車方法×単価ランク
      if (src) {
        sourceTierMap[src][tier].count += 1;
        sourceTierMap[src][tier].amount += amt;
      }

      // エリア×単価ランク
      if (area) {
        if (!areaTierMap[area]) {
          areaTierMap[area] = { area, total: 0, tiers: {} };
          priceTiers.forEach(t => { areaTierMap[area].tiers[t.key] = { count: 0, amount: 0 }; });
        }
        areaTierMap[area].total += 1;
        areaTierMap[area].tiers[tier].count += 1;
        areaTierMap[area].tiers[tier].amount += amt;
      }
    });

    // 平均算出
    Object.values(sourceAreaMap).forEach(v => { v.avg = v.count > 0 ? Math.round(v.amount / v.count) : 0; });

    // 配車方法×エリア: 上位をソート
    const sourceAreaList = Object.values(sourceAreaMap).sort((a, b) => b.count - a.count).slice(0, 30);

    // 配車方法×単価ランク: 構造化
    const sourceTierList = sources.map(s => ({
      source: s,
      tiers: priceTiers.map(t => ({
        ...t,
        count: sourceTierMap[s][t.key].count,
        amount: sourceTierMap[s][t.key].amount,
        avg: sourceTierMap[s][t.key].count > 0 ? Math.round(sourceTierMap[s][t.key].amount / sourceTierMap[s][t.key].count) : 0,
      })),
      totalCount: priceTiers.reduce((sum, t) => sum + sourceTierMap[s][t.key].count, 0),
    }));

    // エリア×単価ランク: 上位エリア
    const areaTierList = Object.values(areaTierMap)
      .sort((a, b) => b.total - a.total)
      .slice(0, 10)
      .map(a => ({
        area: a.area,
        total: a.total,
        tiers: priceTiers.map(t => ({
          ...t,
          count: a.tiers[t.key].count,
          amount: a.tiers[t.key].amount,
          pct: a.total > 0 ? Math.round((a.tiers[t.key].count / a.total) * 100) : 0,
        })),
      }));

    // エリア×配車方法マトリクス（平均単価）: 上位エリア×全配車方法
    const topAreas = areaTierList.map(a => a.area);
    const matrixData = topAreas.map(area => {
      const row = { area };
      sources.forEach(src => {
        const key = src + '::' + area;
        const d = sourceAreaMap[key];
        row[src] = d ? { count: d.count, avg: d.avg, tiers: d.tiers } : { count: 0, avg: 0, tiers: { short: 0, mid: 0, long: 0 } };
      });
      return row;
    });

    return { priceTiers, sources, sourceAreaList, sourceTierList, areaTierList, matrixData };
  }

  // ============================================================
  // 単価ランク別ヒートマップデータ（地図用）
  // ============================================================
  function getPriceTierHeatmapData(filterSource) {
    const entries = getEntries();
    const points = [];

    entries.forEach(e => {
      if (!e.pickupCoords || !e.pickupCoords.lat || !e.pickupCoords.lng) return;
      if (filterSource && e.source !== filterSource) return;
      const amt = e.amount || 0;
      const tier = amt <= 1000 ? 'short' : amt <= 1999 ? 'mid' : 'long';
      points.push({
        lat: e.pickupCoords.lat,
        lng: e.pickupCoords.lng,
        amount: amt,
        tier,
        source: e.source || '未設定',
        area: e.pickup || '',
        hour: e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : toHour(e.timestamp),
      });
    });

    return points;
  }

  // ============================================================
  // 現在地周辺の推定単価（地図パネル用）
  // ============================================================
  function getNearbyEstimate(lat, lng, radiusKm) {
    radiusKm = (radiusKm != null) ? radiusKm : 2;
    const entries = getEntries();
    const nearby = [];

    entries.forEach(e => {
      if (!e.pickupCoords || !e.pickupCoords.lat || !e.pickupCoords.lng) return;
      const dLat = e.pickupCoords.lat - lat;
      const dLng = e.pickupCoords.lng - lng;
      const dist = Math.sqrt(dLat * dLat + dLng * dLng) * 111; // 粗い距離(km)
      if (dist <= radiusKm) {
        nearby.push(e);
      }
    });

    if (nearby.length === 0) return { count: 0, avgPrice: 0, tierCounts: { short: 0, mid: 0, long: 0 }, sources: {}, topArea: '' };

    let total = 0;
    const tierCounts = { short: 0, mid: 0, long: 0 };
    const sources = {};
    const areaCounts = {};

    nearby.forEach(e => {
      const amt = e.amount || 0;
      total += amt;
      const tier = amt <= 1000 ? 'short' : amt <= 1999 ? 'mid' : 'long';
      tierCounts[tier] += 1;
      const src = e.source || '未設定';
      sources[src] = (sources[src] || 0) + 1;
      if (e.pickup) areaCounts[e.pickup] = (areaCounts[e.pickup] || 0) + 1;
    });

    const topArea = Object.entries(areaCounts).sort((a, b) => b[1] - a[1])[0];

    return {
      count: nearby.length,
      avgPrice: Math.round(total / nearby.length),
      tierCounts,
      sources,
      topArea: topArea ? topArea[0] : '',
    };
  }

  // ============================================================
  // ヒートマップデータ（半径2kmオーバーラップ方式）
  // 各乗車地点から半径2km圏内に仮想ポイントを配置し、
  // 複数の乗車地点の2km圏が重なるエリアほど高密度になる
  // ============================================================
  function getHeatmapData() {
    const entries = getEntries();
    const rivals = getRivalEntries();
    // 元の乗車ポイントを収集
    const origins = [];

    entries.forEach(e => {
      if (e.pickupCoords && e.pickupCoords.lat && e.pickupCoords.lng) {
        origins.push({ lat: e.pickupCoords.lat, lng: e.pickupCoords.lng });
      }
    });

    rivals.forEach(r => {
      if (r.locationCoords && r.locationCoords.lat && r.locationCoords.lng) {
        origins.push({ lat: r.locationCoords.lat, lng: r.locationCoords.lng });
      }
    });

    if (origins.length === 0) return [];

    // グリッドセルサイズ（度）: 約200m間隔
    const CELL_SIZE = 0.002;
    // 半径2km ≒ 約0.018度（緯度）
    const RADIUS_DEG = 0.018;
    const RADIUS_KM = 2.0;

    // グリッドに重ね合わせカウント
    const grid = {};

    origins.forEach(origin => {
      // 半径2km圏のグリッドセルを列挙
      const latSteps = Math.ceil(RADIUS_DEG / CELL_SIZE);
      for (let di = -latSteps; di <= latSteps; di++) {
        for (let dj = -latSteps; dj <= latSteps; dj++) {
          const cellLat = origin.lat + di * CELL_SIZE;
          const cellLng = origin.lng + dj * CELL_SIZE;
          // 実距離で2km以内かチェック
          const dlat = cellLat - origin.lat;
          const dlng = (cellLng - origin.lng) * Math.cos(origin.lat * Math.PI / 180);
          const distKm = Math.sqrt(dlat * dlat + dlng * dlng) * 111.32;
          if (distKm > RADIUS_KM) continue;

          // グリッドキーを丸めて集約
          const key = `${(Math.round(cellLat / CELL_SIZE) * CELL_SIZE).toFixed(4)},${(Math.round(cellLng / CELL_SIZE) * CELL_SIZE).toFixed(4)}`;
          if (!grid[key]) {
            grid[key] = { lat: Math.round(cellLat / CELL_SIZE) * CELL_SIZE, lng: Math.round(cellLng / CELL_SIZE) * CELL_SIZE, count: 0 };
          }
          // 中心に近いほど高いweight（ガウシアン減衰）
          const falloff = Math.exp(-(distKm * distKm) / (2 * 0.8 * 0.8));
          grid[key].count += falloff;
        }
      }
    });

    // グリッドからポイント配列に変換
    const points = Object.values(grid).map(g => ({
      lat: g.lat,
      lng: g.lng,
      weight: g.count,
    }));

    return points;
  }

  // ============================================================
  // 週別集計
  // ============================================================
  function getWeeklyBreakdown(weeks = 12) {
    const entries = getEntries();
    const result = {};

    for (let i = weeks - 1; i >= 0; i--) {
      const d = new Date();
      d.setDate(d.getDate() - (i * 7));
      const key = getWeekStart(d);
      result[key] = { week: key, amount: 0, count: 0 };
    }

    entries.forEach(e => {
      const key = getWeekStart(new Date(e.timestamp));
      if (result[key]) {
        result[key].amount += e.amount || 0;
        result[key].count += 1;
      }
    });

    return Object.values(result);
  }

  // ============================================================
  // 月別集計
  // ============================================================
  function getMonthlyBreakdown() {
    const entries = getEntries();
    const result = {};

    entries.forEach(e => {
      const key = getMonthStr(e.timestamp);
      if (!result[key]) {
        result[key] = { month: key, amount: 0, count: 0 };
      }
      result[key].amount += e.amount || 0;
      result[key].count += 1;
    });

    return Object.values(result).sort((a, b) => a.month.localeCompare(b.month));
  }

  // ============================================================
  // CSVエクスポート
  // ============================================================
  function exportCSV() {
    const entries = getEntries();
    if (entries.length === 0) return null;

    const header = 'ID,日付,曜日,祝日,日時,天候,金額,支払方法,割引額,割引種別,乗車地,乗車時間,降車地,降車時間,人数,性別,用途,配車方法,メモ';
    const rows = entries.map(e => {
      const entryDate = e.date || toDateStr(e.timestamp);
      const dateInfo = JapaneseHolidays.getDateInfo(entryDate);
      const dayOfWeek = e.dayOfWeek || dateInfo.dayOfWeek;
      const holiday = e.holiday || dateInfo.holiday || '';
      const dateTime = new Date(e.timestamp).toLocaleString('ja-JP');
      const weather = (e.weather || '').replace(/,/g, '、');
      const paymentMethod = e.paymentMethod === 'uncollected' ? '未収' : '現金';
      const discountAmount = e.discountAmount || 0;
      const discountTypeMap = { disability: '障害者割引', coupon: 'クーポン', ticket: 'タクシーチケット' };
      const discountType = discountTypeMap[e.discountType] || (e.discountType || '');
      const pickup = (e.pickup || '').replace(/,/g, '、');
      const pickupTime = e.pickupTime || '';
      const dropoff = (e.dropoff || '').replace(/,/g, '、');
      const dropoffTime = e.dropoffTime || '';
      const passengers = e.passengers || '';
      const gender = e.gender || '';
      const purpose = (e.purpose || '').replace(/,/g, '、');
      const source = e.source || '';
      const memo = (e.memo || '').replace(/,/g, '、');
      return `${e.id},${entryDate},${dayOfWeek},${holiday},${dateTime},${weather},${e.amount},${paymentMethod},${discountAmount},${discountType},${pickup},${pickupTime},${dropoff},${dropoffTime},${passengers},${gender},${purpose},${source},${memo}`;
    });

    const csv = '\uFEFF' + header + '\n' + rows.join('\n'); // BOM付きUTF-8
    return csv;
  }

  function downloadCSV() {
    const csv = exportCSV();
    if (!csv) {
      AppLogger.warn('エクスポート対象のデータがありません');
      return false;
    }

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    const dateStr = getLocalDateString();
    link.href = url;
    link.download = `taxi_revenue_${dateStr}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    AppLogger.info(`CSVエクスポート完了: ${getEntries().length}件`);
    return true;
  }

  // ============================================================
  // データバリデーション
  // ============================================================
  function validateEntry(form) {
    const errors = [];
    const amount = parseInt(form.amount);

    if (form.noPassenger) {
      // 乗客なしの場合は金額バリデーションをスキップ
      return { valid: true, errors: [] };
    }

    if (!form.amount || isNaN(amount)) {
      errors.push('金額を入力してください');
    } else if (amount <= 0) {
      errors.push('金額は1円以上を入力してください');
    } else if (amount > 1000000) {
      errors.push('金額が大きすぎます（100万円以下にしてください）');
    }

    return { valid: errors.length === 0, errors };
  }

  // ============================================================
  // データ変更通知ヘルパー
  // ============================================================
  function _notifyDataChanged(type) {
    window.dispatchEvent(new CustomEvent('taxi-data-changed', { detail: { type } }));
  }

  // ============================================================
  // CRUD操作
  // ============================================================
  function addEntry(form) {
    const validation = validateEntry(form);
    if (!validation.valid) return { success: false, errors: validation.errors };

    const entries = getEntries();
    const entryDate = form.date || getLocalDateString();
    const dateInfo = JapaneseHolidays.getDateInfo(entryDate);
    const entry = {
      id: Date.now() + '_' + Math.random().toString(36).substr(2, 5),
      amount: parseInt(form.amount),
      date: entryDate,
      dayOfWeek: dateInfo.dayOfWeek,
      holiday: dateInfo.holiday || '',
      weather: form.weather || '',
      pickup: form.pickup || '',
      pickupTime: form.pickupTime || '',
      dropoff: form.dropoff || '',
      dropoffTime: form.dropoffTime || '',
      passengers: form.passengers || '',
      gender: form.gender || '',
      purpose: form.purpose || '',
      memo: form.memo || '',
      source: form.source || '',
      pickupCoords: form.pickupCoords || null,
      dropoffCoords: form.dropoffCoords || null,
      noPassenger: form.noPassenger || false,
      paymentMethod: form.paymentMethod || 'cash',
      discountAmount: form.discountAmount ? parseInt(form.discountAmount) : 0,
      discountType: form.discountType || '',
      timestamp: new Date().toISOString(),
    };

    entries.unshift(entry);
    saveEntries(entries);
    const holidayStr = dateInfo.holiday ? ` [${dateInfo.holiday}]` : '';
    const paymentStr = entry.paymentMethod === 'uncollected' ? ' [未収]' : '';
    const discountStr = entry.discountAmount > 0 ? ` [割引¥${entry.discountAmount}]` : '';
    AppLogger.info(`売上記録追加: ¥${entry.amount}${paymentStr}${discountStr} (${entry.date} ${dateInfo.dayOfWeek}${holidayStr}, ${entry.weather || '天候未設定'})`);
    // 自動ファイル保存
    autoSaveToFile();
    _syncToCloud('revenue', entries);
    _notifyDataChanged('revenue');
    return { success: true, entry };
  }

  function deleteEntry(id) {
    const entries = getEntries();
    const filtered = entries.filter(e => e.id !== id);
    saveEntries(filtered);
    AppLogger.info('売上記録を削除しました');
    autoSaveToFile();
    _syncToCloud('revenue', filtered);
    _notifyDataChanged('revenue');
    return true;
  }

  function updateEntry(id, updates) {
    const entries = getEntries();
    const idx = entries.findIndex(e => e.id === id);
    if (idx === -1) return { success: false, errors: ['記録が見つかりません'] };
    if (updates.amount != null) {
      const amt = parseInt(updates.amount);
      const isNoPassenger = entries[idx].noPassenger || updates.noPassenger;
      if (isNoPassenger) {
        updates.amount = 0;
      } else {
        if (isNaN(amt) || amt < 1 || amt > 1000000) return { success: false, errors: ['金額は1〜1,000,000の範囲で入力してください'] };
        updates.amount = amt;
      }
    }
    entries[idx] = { ...entries[idx], ...updates };
    saveEntries(entries);
    AppLogger.info('売上記録を更新しました');
    autoSaveToFile();
    _syncToCloud('revenue', entries);
    _notifyDataChanged('revenue');
    return { success: true, entry: entries[idx] };
  }

  function clearAllEntries() {
    saveEntries([]);
    _syncToCloud('revenue', []);
    AppLogger.info('全売上データを削除しました');
    _notifyDataChanged('revenue');
    return true;
  }

  // ============================================================
  // 他社乗車データ CRUD
  // ============================================================
  function getRivalEntries() {
    try {
      const saved = localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.RIVAL_RIDES);
      if (saved === _rivalCacheRaw && _rivalCache !== null) return _rivalCache;
      const entries = saved ? JSON.parse(saved) : [];
      entries.forEach(e => {
        if (e.date) {
          const info = JapaneseHolidays.getDateInfo(e.date);
          e.dayOfWeek = info.dayOfWeek;
          e.holiday = info.holiday || '';
        }
      });
      _rivalCacheRaw = saved;
      _rivalCache = _sortByDateTimeDesc(entries, 'date', 'time');
      return _rivalCache;
    } catch {
      return [];
    }
  }

  function saveRivalEntries(entries) {
    try {
      _sortByDateTimeDesc(entries, 'date', 'time');
      const json = JSON.stringify(entries);
      localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.RIVAL_RIDES, json);
      _rivalCacheRaw = json;
      _rivalCache = entries;
      return true;
    } catch (e) {
      AppLogger.error('他社乗車データの保存に失敗しました', e.message);
      return false;
    }
  }

  function addRivalEntry(form) {
    if (!form.location || !form.location.trim()) {
      return { success: false, errors: ['乗車場所を入力してください'] };
    }
    const entries = getRivalEntries();
    const entryDate = form.date || getLocalDateString();
    const dateInfo = JapaneseHolidays.getDateInfo(entryDate);
    const entry = {
      id: Date.now() + '_' + Math.random().toString(36).substr(2, 5),
      date: entryDate,
      dayOfWeek: dateInfo.dayOfWeek,
      holiday: dateInfo.holiday || '',
      time: form.time || '',
      weather: form.weather || '',
      location: form.location.trim(),
      locationCoords: form.locationCoords || null,
      memo: form.memo || '',
      timestamp: new Date().toISOString(),
    };
    entries.unshift(entry);
    saveRivalEntries(entries);
    const holidayStr = dateInfo.holiday ? ` [${dateInfo.holiday}]` : '';
    AppLogger.info(`他社乗車記録追加: ${entry.location} (${entry.date} ${dateInfo.dayOfWeek}${holidayStr})`);
    autoSaveRivalToFile();
    _syncToCloud('rival', entries);
    _notifyDataChanged('rival');
    return { success: true, entry };
  }

  function deleteRivalEntry(id) {
    const entries = getRivalEntries();
    const filtered = entries.filter(e => e.id !== id);
    saveRivalEntries(filtered);
    AppLogger.info('他社乗車記録を削除しました');
    autoSaveRivalToFile();
    _syncToCloud('rival', filtered);
    _notifyDataChanged('rival');
    return true;
  }

  function updateRivalEntry(id, updates) {
    const entries = getRivalEntries();
    const idx = entries.findIndex(e => e.id === id);
    if (idx === -1) return { success: false, errors: ['記録が見つかりません'] };
    if (updates.location != null && !updates.location.trim()) return { success: false, errors: ['乗車場所を入力してください'] };
    entries[idx] = { ...entries[idx], ...updates };
    saveRivalEntries(entries);
    AppLogger.info('他社乗車記録を更新しました');
    autoSaveRivalToFile();
    _syncToCloud('rival', entries);
    _notifyDataChanged('rival');
    return { success: true, entry: entries[idx] };
  }

  function clearAllRivalEntries() {
    saveRivalEntries([]);
    _syncToCloud('rival', []);
    AppLogger.info('全他社乗車データを削除しました');
    _notifyDataChanged('rival');
    return true;
  }

  // ============================================================
  // 他社乗車分析
  // ============================================================
  function getRivalHourlyBreakdown() {
    const entries = getRivalEntries();
    const result = [];
    for (let h = 0; h < 24; h++) {
      result.push({ hour: h, label: `${h}時`, count: 0 });
    }
    entries.forEach(e => {
      if (e.time) {
        const hour = parseInt(e.time.split(':')[0], 10);
        if (hour >= 0 && hour < 24) result[hour].count += 1;
      }
    });
    return result;
  }

  function getRivalDayOfWeekBreakdown() {
    const days = ['日', '月', '火', '水', '木', '金', '土'];
    const result = days.map((name, i) => ({ name, index: i, count: 0 }));
    const entries = getRivalEntries();
    entries.forEach(e => {
      if (e.date) {
        const idx = new Date(e.date).getDay();
        if (idx >= 0 && idx < 7) result[idx].count += 1;
      }
    });
    return result;
  }

  function getRivalLocationBreakdown() {
    const entries = getRivalEntries();
    const locs = {};
    entries.forEach(e => {
      if (e.location) {
        if (!locs[e.location]) locs[e.location] = { name: e.location, count: 0 };
        locs[e.location].count += 1;
      }
    });
    return Object.values(locs).sort((a, b) => b.count - a.count).slice(0, 10);
  }

  function getRivalWeatherBreakdown() {
    const weathers = ['晴れ', '曇り', '雨', '雪', '未設定'];
    const result = {};
    weathers.forEach(w => { result[w] = { name: w, count: 0 }; });
    const entries = getRivalEntries();
    entries.forEach(e => {
      const w = e.weather && weathers.includes(e.weather) ? e.weather : '未設定';
      result[w].count += 1;
    });
    return weathers.map(w => result[w]);
  }

  function downloadRivalCSV() {
    const entries = getRivalEntries();
    if (entries.length === 0) {
      AppLogger.warn('エクスポート対象の他社乗車データがありません');
      return false;
    }
    const header = 'ID,日付,曜日,祝日,時間,天候,乗車場所,メモ';
    const rows = entries.map(e => {
      const weather = (e.weather || '').replace(/,/g, '、');
      const location = (e.location || '').replace(/,/g, '、');
      const memo = (e.memo || '').replace(/,/g, '、');
      return `${e.id},${e.date},${e.dayOfWeek},${e.holiday},${e.time},${weather},${location},${memo}`;
    });
    const csv = '\uFEFF' + header + '\n' + rows.join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    const dateStr = getLocalDateString();
    link.href = url;
    link.download = `rival_rides_${dateStr}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    AppLogger.info(`他社乗車CSVエクスポート完了: ${entries.length}件`);
    return true;
  }

  // ============================================================
  // イベントデータ CRUD
  // ============================================================
  function getEvents() {
    try {
      const saved = localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.EVENTS);
      return saved ? JSON.parse(saved) : [];
    } catch {
      return [];
    }
  }

  function saveEvents(entries) {
    try {
      localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.EVENTS, JSON.stringify(entries));
      return true;
    } catch (e) {
      AppLogger.error('イベントデータの保存に失敗しました', e.message);
      return false;
    }
  }

  function addEvent(form) {
    if (!form.name || !form.name.trim()) {
      return { success: false, errors: ['イベント名を入力してください'] };
    }
    const entries = getEvents();
    const entryDate = form.date || getLocalDateString();
    const dateInfo = JapaneseHolidays.getDateInfo(entryDate);
    const entry = {
      id: Date.now() + '_' + Math.random().toString(36).substr(2, 5),
      name: form.name.trim(),
      date: entryDate,
      dayOfWeek: dateInfo.dayOfWeek,
      holiday: dateInfo.holiday || '',
      startTime: form.startTime || '',
      endTime: form.endTime || '',
      location: form.location || '',
      locationCoords: form.locationCoords || null,
      scale: form.scale || '',
      impact: form.impact || '',
      memo: form.memo || '',
      timestamp: new Date().toISOString(),
    };
    entries.unshift(entry);
    saveEvents(entries);
    const holidayStr = dateInfo.holiday ? ` [${dateInfo.holiday}]` : '';
    AppLogger.info(`イベント記録追加: ${entry.name} (${entry.date} ${dateInfo.dayOfWeek}${holidayStr})`);
    return { success: true, entry };
  }

  function deleteEvent(id) {
    const entries = getEvents();
    const filtered = entries.filter(e => e.id !== id);
    saveEvents(filtered);
    AppLogger.info('イベント記録を削除しました');
    return true;
  }

  function clearAllEvents() {
    saveEvents([]);
    AppLogger.info('全イベントデータを削除しました');
    return true;
  }

  // 公共交通機関情報の自動保存（サブフォルダ「公共交通機関情報」）
  async function autoSaveTransitToFile(transitData) {
    await _handleReady;
    if (!_dirHandle) return;
    if (!transitData || Object.keys(transitData).length === 0) return;
    const now = new Date();
    const dateTimeStr = now.getFullYear()
      + '-' + String(now.getMonth() + 1).padStart(2, '0')
      + '-' + String(now.getDate()).padStart(2, '0')
      + '_' + String(now.getHours()).padStart(2, '0')
      + String(now.getMinutes()).padStart(2, '0');
    await _saveToSubFolder('公共交通機関情報', `交通情報_${dateTimeStr}.json`, [transitData], '0.6.0');
  }

  // ============================================================
  // 売上向上機能
  // ============================================================

  function _timeToMinutes(t) {
    if (!t || !t.includes(':')) return null;
    const [h, m] = t.split(':').map(Number);
    return h * 60 + m;
  }

  function getUtilizationRate() {
    const entries = getEntries();
    const today = toDateStr(new Date().toISOString());
    const todayEntries = entries
      .filter(e => toDateStr(e.timestamp) === today && e.pickupTime && e.dropoffTime)
      .sort((a, b) => (a.pickupTime || '').localeCompare(b.pickupTime || ''));
    let occupied = 0, vacant = 0;
    todayEntries.forEach((e, i) => {
      const p = _timeToMinutes(e.pickupTime);
      const d = _timeToMinutes(e.dropoffTime);
      if (p !== null && d !== null && d > p) occupied += d - p;
      if (i < todayEntries.length - 1) {
        const nextP = _timeToMinutes(todayEntries[i + 1].pickupTime);
        if (d !== null && nextP !== null && nextP > d) vacant += nextP - d;
      }
    });
    const total = occupied + vacant;
    return {
      occupiedMin: occupied,
      vacantMin: vacant,
      rate: total > 0 ? Math.round((occupied / total) * 100) : 0,
      rideCount: todayEntries.length,
    };
  }

  function getTopPickupAreasForNow() {
    const entries = getEntries();
    const now = new Date();
    const currentHour = now.getHours();
    const currentDow = ['日','月','火','水','木','金','土'][now.getDay()];
    const areas = {};
    entries.forEach(e => {
      if (!e.pickup || !e.amount) return;
      const hr = e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : null;
      if (hr === null) return;
      if (Math.abs(hr - currentHour) > 1 && Math.abs(hr - currentHour) < 23) return;
      if (e.dayOfWeek !== currentDow) return;
      if (!areas[e.pickup]) areas[e.pickup] = { name: e.pickup, total: 0, count: 0 };
      areas[e.pickup].total += e.amount;
      areas[e.pickup].count += 1;
    });
    return Object.values(areas)
      .filter(a => a.count >= 2)
      .map(a => ({ ...a, avg: Math.round(a.total / a.count) }))
      .sort((a, b) => b.avg - a.avg)
      .slice(0, 3);
  }

  function getGoalProgress() {
    const settings = JSON.parse(localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.SETTINGS) || '{}');
    const dailyGoal = Number(settings.dailyGoal) || 0;
    if (!dailyGoal) return null;
    const todayAmount = getTodaySummary().totalAmount;
    const entries = getEntries();
    const now = new Date();
    const monthKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
    const monthAmount = entries
      .filter(e => (e.date || toDateStr(e.timestamp)).startsWith(monthKey))
      .reduce((s, e) => s + (e.amount || 0), 0);
    const monthDays = new Set(
      entries
        .filter(e => (e.date || toDateStr(e.timestamp)).startsWith(monthKey))
        .map(e => e.date || toDateStr(e.timestamp))
    ).size;
    const monthlyGoalCalc = dailyGoal * monthDays;
    return {
      dailyGoal,
      todayAmount,
      dailyRate: Math.round((todayAmount / dailyGoal) * 100),
      monthAmount,
      monthDays,
      monthlyGoal: monthlyGoalCalc,
      monthlyRate: monthlyGoalCalc > 0 ? Math.round((monthAmount / monthlyGoalCalc) * 100) : 0,
    };
  }

  function getUpcomingEventAlerts() {
    const events = getEvents();
    const today = toDateStr(new Date().toISOString());
    const nowMin = new Date().getHours() * 60 + new Date().getMinutes();
    return events
      .filter(e => {
        if (e.date !== today || !e.endTime) return false;
        const endMin = _timeToMinutes(e.endTime);
        if (endMin === null) return false;
        return nowMin >= endMin - 30 && nowMin <= endMin;
      })
      .map(e => ({
        name: e.name,
        endTime: e.endTime,
        location: e.location,
        scale: e.scale,
        minutesLeft: _timeToMinutes(e.endTime) - nowMin,
      }));
  }

  // 時間帯・曜日対応ヒートマップデータ
  // mode: 'all' | 'timeAware' | 'transit' | 'combined'
  function getSmartHeatmapData(mode) {
    mode = mode || 'all';

    // transit: 交通需要ポイントのみ
    if (mode === 'transit') {
      const transitPoints = getTransitHeatmapData();
      return {
        points: transitPoints,
        stats: { totalRides: 0, timeFiltered: transitPoints.length, mode: 'transit' },
      };
    }

    const entries = getEntries();
    const rivals = getRivalEntries();
    const now = new Date();
    const currentHour = now.getHours();
    const currentDow = now.getDay();
    const nowMs = now.getTime();
    const DAY_MS = 86400000;

    const origins = [];

    entries.forEach(e => {
      if (!e.pickupCoords || !e.pickupCoords.lat || !e.pickupCoords.lng) return;
      let weight = 1;
      if (mode === 'timeAware') {
        // 時間帯マッチ: ±2時間以内なら高weight
        const hr = e.pickupTime ? parseInt(e.pickupTime.split(':')[0], 10) : null;
        const hourDiff = hr !== null ? Math.min(Math.abs(hr - currentHour), 24 - Math.abs(hr - currentHour)) : 12;
        const hourFactor = hourDiff <= 2 ? (1 - hourDiff * 0.2) : 0.2;

        // 曜日マッチ: 同じ曜日なら高weight
        const entryDate = new Date(e.timestamp || e.date);
        const entryDow = entryDate.getDay();
        const dowFactor = entryDow === currentDow ? 1.5 : 1.0;

        // 鮮度: 直近30日以内は高weight、古いデータは減衰
        const ageDays = (nowMs - entryDate.getTime()) / DAY_MS;
        const recencyFactor = ageDays <= 7 ? 1.5 : ageDays <= 30 ? 1.0 : ageDays <= 90 ? 0.6 : 0.3;

        weight = hourFactor * dowFactor * recencyFactor;
      }
      origins.push({ lat: e.pickupCoords.lat, lng: e.pickupCoords.lng, weight: weight, amount: e.amount || 0 });
    });

    rivals.forEach(r => {
      if (!r.locationCoords || !r.locationCoords.lat || !r.locationCoords.lng) return;
      let weight = 0.8;
      if (mode === 'timeAware') {
        const hr = r.time ? parseInt(r.time.split(':')[0], 10) : null;
        const hourDiff = hr !== null ? Math.min(Math.abs(hr - currentHour), 24 - Math.abs(hr - currentHour)) : 12;
        weight = (hourDiff <= 2 ? (1 - hourDiff * 0.2) : 0.2) * 0.8;
        const entryDate = new Date(r.timestamp || r.date);
        const ageDays = (nowMs - entryDate.getTime()) / DAY_MS;
        weight *= ageDays <= 7 ? 1.5 : ageDays <= 30 ? 1.0 : ageDays <= 90 ? 0.6 : 0.3;
      }
      origins.push({ lat: r.locationCoords.lat, lng: r.locationCoords.lng, weight: weight, amount: 0 });
    });

    if (origins.length === 0) return { points: [], stats: { totalRides: 0, timeFiltered: 0 } };

    const CELL_SIZE = 0.002;
    const RADIUS_DEG = 0.018;
    const RADIUS_KM = 2.0;
    const grid = {};

    origins.forEach(origin => {
      const latSteps = Math.ceil(RADIUS_DEG / CELL_SIZE);
      for (let di = -latSteps; di <= latSteps; di++) {
        for (let dj = -latSteps; dj <= latSteps; dj++) {
          const cellLat = origin.lat + di * CELL_SIZE;
          const cellLng = origin.lng + dj * CELL_SIZE;
          const dlat = cellLat - origin.lat;
          const dlng = (cellLng - origin.lng) * Math.cos(origin.lat * Math.PI / 180);
          const distKm = Math.sqrt(dlat * dlat + dlng * dlng) * 111.32;
          if (distKm > RADIUS_KM) continue;
          const key = `${(Math.round(cellLat / CELL_SIZE) * CELL_SIZE).toFixed(4)},${(Math.round(cellLng / CELL_SIZE) * CELL_SIZE).toFixed(4)}`;
          if (!grid[key]) {
            grid[key] = { lat: Math.round(cellLat / CELL_SIZE) * CELL_SIZE, lng: Math.round(cellLng / CELL_SIZE) * CELL_SIZE, count: 0 };
          }
          const falloff = Math.exp(-(distKm * distKm) / (2 * 0.8 * 0.8));
          grid[key].count += falloff * origin.weight;
        }
      }
    });

    let points = Object.values(grid).map(g => ({ lat: g.lat, lng: g.lng, weight: g.count }));
    const timeFilteredCount = mode === 'timeAware'
      ? entries.filter(e => {
          if (!e.pickupCoords || !e.pickupTime) return false;
          const hr = parseInt(e.pickupTime.split(':')[0], 10);
          return Math.min(Math.abs(hr - currentHour), 24 - Math.abs(hr - currentHour)) <= 2;
        }).length
      : origins.length;

    // combined: 乗車データ + 交通需要を統合
    if (mode === 'combined') {
      const transitPoints = getTransitHeatmapData();
      points = points.concat(transitPoints);
    }

    return {
      points: points,
      stats: {
        totalRides: entries.filter(e => e.pickupCoords && e.pickupCoords.lat).length,
        timeFiltered: timeFilteredCount,
        mode: mode,
      },
    };
  }

  // 場所名→座標の変換ヘルパー
  function _resolveLocationCoords(locationName) {
    const locs = APP_CONSTANTS.KNOWN_LOCATIONS.asahikawa;
    if (!locationName) return null;
    const name = locationName.toLowerCase();
    if (name.includes('旭川駅') || name.includes('駅前') || name.includes('駅')) {
      return { lat: locs.station.lat, lng: locs.station.lng };
    }
    for (const h of locs.hospitals) {
      if (name.includes(h.name) || h.name.includes(locationName)) {
        return { lat: h.lat, lng: h.lng };
      }
    }
    // ホテル名での座標解決
    for (const hotel of (locs.hotels || [])) {
      if (name.includes(hotel.name) || hotel.name.includes(locationName)) {
        return { lat: hotel.lat, lng: hotel.lng };
      }
    }
    // ホテル部分一致フォールバック
    if (name.includes('アートホテル')) return { lat: locs.hotels[0].lat, lng: locs.hotels[0].lng };
    if (name.includes('omo7') || name.includes('omo')) return { lat: locs.hotels[1].lat, lng: locs.hotels[1].lng };
    if (name.includes('トーヨー')) return { lat: locs.hotels[2].lat, lng: locs.hotels[2].lng };
    if (name.includes('ドーミーイン')) return { lat: locs.hotels[3].lat, lng: locs.hotels[3].lng };
    if (name.includes('クレッセント')) return { lat: locs.hotels[4].lat, lng: locs.hotels[4].lng };
    if (name.includes('cabin') || name.includes('プレミアホテル')) return { lat: locs.hotels[5].lat, lng: locs.hotels[5].lng };
    if (name.includes('アマネク')) return { lat: locs.hotels[6].lat, lng: locs.hotels[6].lng };
    if (name.includes('ルートイングランド') || name.includes('ルートインgrand')) return { lat: locs.hotels[7].lat, lng: locs.hotels[7].lng };
    if (name.includes('jrイン')) return { lat: locs.hotels[8].lat, lng: locs.hotels[8].lng };
    // 部分一致でフォールバック（病院）
    if (name.includes('医大') || name.includes('医科大')) return { lat: locs.hospitals[0].lat, lng: locs.hospitals[0].lng };
    if (name.includes('赤十字')) return { lat: locs.hospitals[1].lat, lng: locs.hospitals[1].lng };
    if (name.includes('市立')) return { lat: locs.hospitals[2].lat, lng: locs.hospitals[2].lng };
    if (name.includes('厚生')) return { lat: locs.hospitals[3].lat, lng: locs.hospitals[3].lng };
    return null;
  }

  // 旭川駅前バスターミナル到着便の構造化データ（実時刻表ベース）
  function getBusArrivalsData() {
    const now = new Date();
    const isWeekend = [0, 6].includes(now.getDay());
    function addMin(hhmm, min) {
      const [h, m] = hhmm.split(':').map(Number);
      const t = h * 60 + m + min;
      return String(Math.floor(t / 60)).padStart(2,'0') + ':' + String(t % 60).padStart(2,'0');
    }

    const arrivals = [];

    // 高速あさひかわ号（札幌→旭川 冬ダイヤ2時間25分）
    const sapporoDep = [
      '07:00','08:00','08:30','09:00','09:50','10:30','11:00','11:30',
      '12:00','12:30','13:00','13:30','14:00','14:30','15:00','15:30',
      '16:00','16:30','17:00','17:30','18:00','18:30','19:00','19:40','20:20','20:50','21:30',
    ];
    const sappWeekend = ['13:45','19:20'];
    let allSap = [...sapporoDep];
    if (isWeekend) allSap = allSap.concat(sappWeekend);
    allSap.forEach(dep => {
      arrivals.push({ type: '高速バス', line: '高速あさひかわ号', arrivalTime: addMin(dep, 145), origin: '札幌', demandDelay: 5, peakWeight: 0.8 });
    });

    // 特急オホーツク号（紋別→旭川）
    arrivals.push({ type: '都市間バス', line: '特急オホーツク号', arrivalTime: '09:45', origin: '紋別', demandDelay: 5, peakWeight: 0.6 });
    arrivals.push({ type: '都市間バス', line: '特急オホーツク号', arrivalTime: '14:45', origin: '紋別', demandDelay: 5, peakWeight: 0.6 });

    // ノースライナー号（帯広→旭川）
    ['12:00','13:30','15:10','19:55','21:10'].forEach(t => {
      arrivals.push({ type: '都市間バス', line: 'ノースライナー号', arrivalTime: t, origin: '帯広', demandDelay: 5, peakWeight: 0.7 });
    });

    // サンライズ号（北見→旭川）
    arrivals.push({ type: '都市間バス', line: 'サンライズ号', arrivalTime: '15:15', origin: '北見', demandDelay: 5, peakWeight: 0.6 });
    arrivals.push({ type: '都市間バス', line: 'サンライズ号', arrivalTime: '20:30', origin: '北見', demandDelay: 5, peakWeight: 0.6 });

    // 名寄線（名寄→旭川）
    ['09:07','11:59','13:14','14:49','17:34','20:09'].forEach(t => {
      arrivals.push({ type: '路線バス', line: '名寄線', arrivalTime: t, origin: '名寄', demandDelay: 3, peakWeight: 0.4 });
    });

    // 特急天北号（鬼志別→旭川）
    arrivals.push({ type: '都市間バス', line: '特急天北号', arrivalTime: '11:10', origin: '鬼志別', demandDelay: 5, peakWeight: 0.5 });

    // 旭川空港連絡バス（空港→旭川駅）
    ['09:19','10:09','13:49','14:49','15:09','16:39','19:49','19:59'].forEach(t => {
      arrivals.push({ type: '空港バス', line: '空港連絡バス', arrivalTime: t, origin: '旭川空港', demandDelay: 3, peakWeight: 0.9 });
    });

    // 旭山動物園線（動物園→旭川駅）
    ['11:40','12:10','13:10','14:10','15:40','16:10'].forEach(t => {
      arrivals.push({ type: '路線バス', line: '旭山動物園線', arrivalTime: t, origin: '旭山動物園', demandDelay: 3, peakWeight: 0.5 });
    });

    // 時刻順ソート
    arrivals.sort((a, b) => a.arrivalTime.localeCompare(b.arrivalTime));
    return arrivals;
  }

  // 当日の需要プランを取得（バス実データ + Geminiプラン + イベントデータをマージ）
  function getDailyDemandSchedule() {
    const stored = AppStorage.get(APP_CONSTANTS.STORAGE_KEYS.DAILY_DEMAND_PLAN, null);
    const today = new Date().toISOString().slice(0, 10);

    // バス到着データは常に利用可能（ハードコード）
    const busArrivals = getBusArrivalsData();

    // Geminiデータがなくてもバスデータだけで「available」にする
    const hasGemini = stored && stored.date === today && stored.data;
    const geminiData = hasGemini ? stored.data : {};

    // transitArrivals: バス実データ + Gemini（JR特急等）をマージ、重複排除
    const geminiArrivals = geminiData.transitArrivals || [];
    const mergedArrivals = [...busArrivals];
    geminiArrivals.forEach(ga => {
      // バスデータと同時刻・同路線名の重複を排除
      const isDup = mergedArrivals.some(ba =>
        ba.arrivalTime === ga.arrivalTime && ba.line === ga.line
      );
      if (!isDup) mergedArrivals.push(ga);
    });
    mergedArrivals.sort((a, b) => (a.arrivalTime || '').localeCompare(b.arrivalTime || ''));

    // イベントアラートをマージ
    const eventAlerts = getUpcomingEventAlerts();
    const mergedPlan = [...(geminiData.dailyPlan || [])];

    eventAlerts.forEach(evt => {
      mergedPlan.push({
        startTime: evt.endTime ? evt.endTime.replace(/^(\d{1,2}):(\d{2})$/, (m, h, min) => {
          const hh = parseInt(h, 10);
          return `${String(hh).padStart(2,'0')}:${min}`;
        }) : '18:00',
        endTime: evt.endTime || '19:00',
        location: evt.location || 'イベント会場周辺',
        action: `${evt.name} 終了 → 周辺で需要増`,
        demandLevel: 'high',
      });
    });

    // ホテルピーク時間帯をdailyPlanに自動挿入
    const hotelLocs = APP_CONSTANTS.KNOWN_LOCATIONS.asahikawa;
    const hotelPeaks = hotelLocs.hotelPeakWindows || {};
    const hotels = hotelLocs.hotels || [];
    const veryHighHotels = hotels.filter(h => h.demandLevel === 'very_high').map(h => h.name);
    const highHotels = hotels.filter(h => h.demandLevel === 'high').map(h => h.name);

    // 各ピーク時間帯をプランに追加（重複回避）
    Object.entries(hotelPeaks).forEach(([key, win]) => {
      const isDup = mergedPlan.some(p =>
        p.startTime === win.start && p.location && p.location.includes('ホテル')
      );
      if (isDup) return;
      const topHotels = key === 'checkout' || key === 'checkin'
        ? veryHighHotels.slice(0, 2).join('・')
        : highHotels.slice(0, 2).join('・');
      mergedPlan.push({
        startTime: win.start,
        endTime: win.end,
        location: `${topHotels}周辺`,
        action: `ホテル${win.label} → 周辺で需要増`,
        demandLevel: key === 'checkout' ? 'high' : 'medium',
        source: 'hotel',
      });
    });

    // ホテルの現在のピーク状態を算出
    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    function _timeToMin(hhmm) { const [h, m] = hhmm.split(':').map(Number); return h * 60 + m; }
    const hotelWindows = [];
    Object.entries(hotelPeaks).forEach(([key, win]) => {
      const startMin = _timeToMin(win.start);
      const endMin = _timeToMin(win.end);
      const isActive = currentMinutes >= startMin - 15 && currentMinutes <= endMin + 15;
      const isCurrent = currentMinutes >= startMin && currentMinutes <= endMin;
      if (isActive) {
        const activeHotels = hotels
          .filter(h => h.demandLevel === 'very_high' || h.demandLevel === 'high')
          .map(h => ({ name: h.name, rooms: h.rooms, distKm: h.distKm, demandLevel: h.demandLevel }));
        hotelWindows.push({
          key: key,
          label: win.label,
          start: win.start,
          end: win.end,
          isCurrent: isCurrent,
          hotels: activeHotels,
        });
      }
    });

    // 時間順ソート
    mergedPlan.sort((a, b) => (a.startTime || '').localeCompare(b.startTime || ''));

    return {
      available: true,  // バスデータは常にあるのでtrue
      date: today,
      transitArrivals: mergedArrivals,
      hospitalWindows: geminiData.hospitalWindows || [],
      demandWindows: geminiData.demandWindows || [],
      hotelWindows: hotelWindows,
      dailyPlan: mergedPlan,
      hasGeminiPlan: hasGemini,
    };
  }

  // ホテル需要データを算出（時間帯×客室数×駅距離からウェイト計算）
  function getHotelDemandData() {
    const locs = APP_CONSTANTS.KNOWN_LOCATIONS.asahikawa;
    const hotels = locs.hotels || [];
    const peaks = locs.hotelPeakWindows || {};
    if (hotels.length === 0) return [];

    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const origins = [];

    function timeToMin(hhmm) {
      const [h, m] = hhmm.split(':').map(Number);
      return h * 60 + m;
    }

    const maxRooms = 355; // プレミアホテルCABIN旭川を基準に正規化

    hotels.forEach(hotel => {
      Object.values(peaks).forEach(window => {
        const startMin = timeToMin(window.start);
        const endMin = timeToMin(window.end);

        // ウィンドウ内 → フルweight、ウィンドウ外30分以内 → 線形減衰
        let timeWeight = 0;
        if (currentMinutes >= startMin && currentMinutes <= endMin) {
          timeWeight = 1.0;
        } else if (currentMinutes >= startMin - 30 && currentMinutes < startMin) {
          timeWeight = (currentMinutes - (startMin - 30)) / 30;
        } else if (currentMinutes > endMin && currentMinutes <= endMin + 30) {
          timeWeight = 1.0 - (currentMinutes - endMin) / 30;
        }
        if (timeWeight <= 0) return;

        // 駅距離ファクター: 遠いほどタクシー需要が高い
        const distanceFactor = hotel.distKm >= 0.8 ? 1.0 : hotel.distKm >= 0.4 ? 0.6 : 0.3;
        // 客室数ファクター: 多いほど需要ボリュームが大きい
        const roomFactor = hotel.rooms / maxRooms;

        const weight = window.weight * timeWeight * distanceFactor * roomFactor;
        if (weight > 0.01) {
          origins.push({ lat: hotel.lat, lng: hotel.lng, weight: weight });
        }
      });
    });

    return origins;
  }

  // 交通到着データ + 病院ピークからヒートマップポイントを生成
  function getTransitHeatmapData() {
    const schedule = getDailyDemandSchedule();
    if (!schedule.available) return [];

    const now = new Date();
    const currentMinutes = now.getHours() * 60 + now.getMinutes();
    const locs = APP_CONSTANTS.KNOWN_LOCATIONS.asahikawa;
    const origins = [];

    // 交通到着データからポイント生成
    (schedule.transitArrivals || []).forEach(arr => {
      if (!arr.arrivalTime) return;
      const parts = arr.arrivalTime.split(':');
      const arrMin = parseInt(parts[0], 10) * 60 + parseInt(parts[1], 10);
      const delayMin = arr.demandDelay || 5;
      const peakMin = arrMin + delayMin;
      const diff = Math.abs(currentMinutes - peakMin);
      // 15分以内=1.0、60分で0に線形減衰
      if (diff > 60) return;
      const weight = diff <= 15 ? 1.0 : Math.max(0, 1.0 - (diff - 15) / 45);
      origins.push({
        lat: locs.station.lat,
        lng: locs.station.lng,
        weight: weight * (arr.peakWeight || 0.8),
      });
    });

    // 病院ピーク時間帯からポイント生成
    locs.hospitals.forEach(hosp => {
      const peaks = [hosp.peakMorning, hosp.peakAfternoon].filter(Boolean);
      peaks.forEach(peakStr => {
        const [start, end] = peakStr.split('-');
        const startParts = start.split(':');
        const endParts = end.split(':');
        const startMin = parseInt(startParts[0], 10) * 60 + parseInt(startParts[1], 10);
        const endMin = parseInt(endParts[0], 10) * 60 + parseInt(endParts[1], 10);

        if (currentMinutes < startMin - 30 || currentMinutes > endMin + 30) return;
        let weight = 0.6;
        if (currentMinutes >= startMin && currentMinutes <= endMin) {
          weight = 1.0;
        } else {
          const dist = currentMinutes < startMin ? startMin - currentMinutes : currentMinutes - endMin;
          weight = Math.max(0.2, 1.0 - dist / 30);
        }
        origins.push({ lat: hosp.lat, lng: hosp.lng, weight: weight * 0.7 });
      });
    });

    // 需要ウィンドウからもポイント生成
    (schedule.demandWindows || []).forEach(dw => {
      if (!dw.startTime || !dw.endTime) return;
      const sp = dw.startTime.split(':');
      const ep = dw.endTime.split(':');
      const startMin = parseInt(sp[0], 10) * 60 + parseInt(sp[1], 10);
      const endMin = parseInt(ep[0], 10) * 60 + parseInt(ep[1], 10);
      if (currentMinutes < startMin - 15 || currentMinutes > endMin + 15) return;

      const coords = _resolveLocationCoords(dw.location);
      if (!coords) return;
      const levelWeight = dw.level === 'high' ? 1.0 : dw.level === 'medium' ? 0.7 : 0.4;
      origins.push({ lat: coords.lat, lng: coords.lng, weight: levelWeight });
    });

    // ホテル需要ポイントをマージ（静的データのためAPIキー不要）
    const hotelOrigins = getHotelDemandData();
    hotelOrigins.forEach(hp => origins.push(hp));

    if (origins.length === 0) return [];

    // 500m半径の細かいグリッド
    const CELL_SIZE = 0.001;
    const RADIUS_KM = 0.5;
    const RADIUS_DEG = RADIUS_KM / 111.32;
    const grid = {};

    origins.forEach(origin => {
      const latSteps = Math.ceil(RADIUS_DEG / CELL_SIZE);
      for (let di = -latSteps; di <= latSteps; di++) {
        for (let dj = -latSteps; dj <= latSteps; dj++) {
          const cellLat = origin.lat + di * CELL_SIZE;
          const cellLng = origin.lng + dj * CELL_SIZE;
          const dlat = cellLat - origin.lat;
          const dlng = (cellLng - origin.lng) * Math.cos(origin.lat * Math.PI / 180);
          const distKm = Math.sqrt(dlat * dlat + dlng * dlng) * 111.32;
          if (distKm > RADIUS_KM) continue;
          const key = `${cellLat.toFixed(4)},${cellLng.toFixed(4)}`;
          if (!grid[key]) {
            grid[key] = { lat: cellLat, lng: cellLng, count: 0 };
          }
          const falloff = Math.exp(-(distKm * distKm) / (2 * 0.2 * 0.2));
          grid[key].count += falloff * origin.weight;
        }
      }
    });

    return Object.values(grid).map(g => ({ lat: g.lat, lng: g.lng, weight: g.count }));
  }

  // ============================================================
  // ホテル価格蓄積・分析
  // ============================================================
  function getHotelPriceHistory() {
    const raw = localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.HOTEL_PRICES);
    return raw ? JSON.parse(raw) : [];
  }

  function saveHotelPrices(pricesArray) {
    // pricesArray: [{ name, price, estimated, fetchedAt }]
    const history = getHotelPriceHistory();
    const now = new Date().toISOString();
    const record = { fetchedAt: now, prices: pricesArray };
    history.push(record);
    // 最大90日分（1日2回想定で180レコード）
    const maxRecords = 180;
    const trimmed = history.length > maxRecords ? history.slice(-maxRecords) : history;
    localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.HOTEL_PRICES, JSON.stringify(trimmed));
    return trimmed;
  }

  function analyzeHotelPrices() {
    const history = getHotelPriceHistory();
    if (history.length === 0) return { hotels: [], hasData: false, recordCount: 0 };

    // ホテル名ごとに価格履歴を集約
    const byHotel = {};
    history.forEach(record => {
      (record.prices || []).forEach(p => {
        if (!byHotel[p.name]) byHotel[p.name] = [];
        byHotel[p.name].push({ price: p.price, date: record.fetchedAt, estimated: p.estimated });
      });
    });

    const results = Object.entries(byHotel).map(([name, entries]) => {
      const prices = entries.map(e => e.price).filter(p => p > 0);
      if (prices.length === 0) return { name, avg: 0, min: 0, max: 0, latest: 0, trend: 'stable', occupancyEstimate: 'unknown', priceCount: 0 };

      const avg = Math.round(prices.reduce((s, p) => s + p, 0) / prices.length);
      const min = Math.min(...prices);
      const max = Math.max(...prices);
      const latest = prices[prices.length - 1];

      // 最新価格と平均の比較でトレンド判定
      const ratio = latest / avg;
      let trend = 'stable';
      if (ratio >= 1.15) trend = 'high';      // 15%以上高い → 高い
      else if (ratio >= 1.05) trend = 'rising'; // 5%以上高い → やや高い
      else if (ratio <= 0.85) trend = 'low';    // 15%以上安い → 安い
      else if (ratio <= 0.95) trend = 'falling'; // 5%以上安い → やや安い

      // 稼働率推定（価格高騰=高稼働率）
      let occupancyEstimate = 'normal';
      if (ratio >= 1.2) occupancyEstimate = 'very_high';
      else if (ratio >= 1.1) occupancyEstimate = 'high';
      else if (ratio <= 0.9) occupancyEstimate = 'low';

      return { name, avg, min, max, latest, trend, occupancyEstimate, priceCount: prices.length, ratio };
    });

    return {
      hotels: results.sort((a, b) => (b.ratio || 0) - (a.ratio || 0)),
      hasData: true,
      recordCount: history.length,
      latestFetch: history[history.length - 1]?.fetchedAt || null,
    };
  }

  // ============================================================
  // 公開API
  // ============================================================
  return {
    // データ取得
    getEntries,
    saveEntries,

    // サマリー
    getTodaySummary,
    getOverallSummary,

    // 分析
    getDailyBreakdown,
    getDayOfWeekBreakdown,
    getHourlyBreakdown,
    getAreaBreakdown,
    getWeeklyBreakdown,
    getMonthlyBreakdown,
    getWeatherBreakdown,
    getSourceBreakdown,
    getPurposeBreakdown,
    getPurposeDayAnalysis,
    getAreaTimeBreakdown,
    getUnitPriceAnalysis,
    getBusinessRecommendation,
    getSourceAreaPriceBreakdown,
    getPriceTierHeatmapData,
    getNearbyEstimate,
    getHeatmapData,

    // CRUD
    addEntry,
    updateEntry,
    deleteEntry,
    clearAllEntries,
    validateEntry,

    // エクスポート
    exportCSV,
    downloadCSV,

    // ファイル保存・復元
    autoSaveToFile,
    manualSaveToFile,
    selectSaveFolder,
    importFromFile,
    hasSaveFolder,

    // 他社乗車
    getRivalEntries,
    saveRivalEntries,
    addRivalEntry,
    updateRivalEntry,
    deleteRivalEntry,
    clearAllRivalEntries,
    downloadRivalCSV,
    autoSaveRivalToFile,
    manualSaveRivalToFile,
    getRivalHourlyBreakdown,
    getRivalDayOfWeekBreakdown,
    getRivalLocationBreakdown,
    getRivalWeatherBreakdown,

    // クラウド同期
    loadFromCloud,
    syncFromCloud,
    autoSync,

    // イベント
    getEvents,
    saveEvents,
    addEvent,
    deleteEvent,
    clearAllEvents,

    // 公共交通機関情報
    autoSaveTransitToFile,

    // 売上向上機能
    getUtilizationRate,
    getTopPickupAreasForNow,
    getGoalProgress,
    getUpcomingEventAlerts,
    getSmartHeatmapData,

    // 交通需要連動
    getDailyDemandSchedule,
    getTransitHeatmapData,
    getHotelDemandData,
    getBusArrivalsData,

    // ホテル価格
    getHotelPriceHistory,
    saveHotelPrices,
    analyzeHotelPrices,
  };
})();

})();

// ============================================================
// FILE: src/utils/demandNotificationService.js
// ============================================================
(function() {
window.DemandNotificationService = (() => {
  let _intervalId = null;

  function start() {
    if (_intervalId) return;
    _check(); // 初回即時実行
    _intervalId = setInterval(_check, 5 * 60 * 1000); // 5分間隔（交通到着通知対応）
  }

  function stop() {
    if (_intervalId) { clearInterval(_intervalId); _intervalId = null; }
  }

  function _check() {
    if (!NotificationService.isEnabled()) return;
    // 高需要時間帯チェック
    const hourly = DataService.getHourlyBreakdown();
    const now = new Date();
    const nextHour = (now.getHours() + 1) % 24;
    const nextSlot = hourly.find(h => h.hour === nextHour);
    if (nextSlot && nextSlot.avg > 0) {
      const allAvg = hourly.reduce((s, h) => s + h.avg, 0) / Math.max(hourly.filter(h => h.avg > 0).length, 1);
      if (nextSlot.avg >= allAvg * 1.3) {
        NotificationService.send('需要予測', {
          body: `${nextHour}時台は平均¥${nextSlot.avg.toLocaleString()}/回の高需要時間帯です`,
          tag: 'demand-alert',
        });
      }
    }
    // イベント終了アラート
    const alerts = DataService.getUpcomingEventAlerts();
    alerts.forEach(a => {
      NotificationService.send('イベント終了間近', {
        body: `${a.name}（${a.location || ''}）があと${a.minutesLeft}分で終了 — 周辺で需要増の可能性`,
        tag: 'event-alert-' + a.name,
      });
    });
    // 交通到着10分前通知（偶数日のみ — 奇数日は駅前待ち不可）
    const isEvenDay = now.getDate() % 2 === 0;
    if (isEvenDay) {
      const schedule = DataService.getDailyDemandSchedule();
      if (schedule.available && schedule.transitArrivals) {
        const nowMin = now.getHours() * 60 + now.getMinutes();
        schedule.transitArrivals.forEach(arr => {
          if (!arr.arrivalTime) return;
          const p = arr.arrivalTime.split(':');
          const arrMin = parseInt(p[0], 10) * 60 + parseInt(p[1], 10);
          const diff = arrMin - nowMin;
          if (diff > 0 && diff <= 10) {
            NotificationService.send('交通到着まもなく', {
              body: `${arr.type || ''} ${arr.line || ''}が${arr.arrivalTime}に到着 → 駅前で需要増`,
              tag: 'transit-arrival-' + arr.arrivalTime,
            });
          }
        });
      }
    }
  }

  return { start, stop };
})();
})();

// ============================================================
// FILE: src/utils/geminiService.js
// ============================================================
(function() {
// geminiService.js - Gemini AI API連携サービス
//
// Google Gemini 2.0 Flash を使用してAI検索を行うサービス層。
// 公共交通機関情報やイベント情報の検索に使用する。

window.GeminiService = (() => {
  const API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent';

  // API応答のバリデーション共通処理
  const MAX_RESPONSE_SIZE = 100000;
  function _parseGeminiResponse(raw) {
    if (raw.length > MAX_RESPONSE_SIZE) {
      return { success: false, error: 'API応答が大きすぎます' };
    }
    const data = JSON.parse(raw);
    if (!data || typeof data !== 'object' || !Array.isArray(data.candidates)) {
      return { success: false, error: 'API応答形式が不正です' };
    }
    const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!text || typeof text !== 'string') {
      return { success: false, error: '応答が空でした' };
    }
    return { success: true, text: text.slice(0, 50000) };
  }

  // Gemini APIにリクエストを送信
  async function callGemini(apiKey, prompt) {
    if (!apiKey) {
      return { success: false, error: 'Gemini APIキーが設定されていません' };
    }

    try {
      const response = await fetch(API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-goog-api-key': apiKey,
        },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
          generationConfig: {
            temperature: 0.3,
            maxOutputTokens: 2048,
          },
        }),
      });

      if (!response.ok) {
        const errData = await response.json().catch(() => ({}));
        const errMsg = errData.error?.message || `HTTPエラー: ${response.status}`;
        if (response.status === 400) return { success: false, error: 'APIキーが無効です。正しいキーを設定してください。' };
        if (response.status === 429) return { success: false, error: 'API利用制限に達しました。しばらく待ってから再試行してください。' };
        return { success: false, error: errMsg };
      }

      return _parseGeminiResponse(await response.text());
    } catch (e) {
      AppLogger.error('Gemini API呼び出しエラー', e.message);
      return { success: false, error: `通信エラー: ${e.message}` };
    }
  }

  // 公共交通機関の運行情報を検索
  async function searchTransitInfo(apiKey, query) {
    const today = new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
    const prompt = `あなたはタクシードライバー向けの交通情報アシスタントです。
今日は${today}です。

以下の質問に対して、タクシー営業に役立つ公共交通機関の情報を簡潔に回答してください。
- 鉄道の運行状況、遅延、運休の情報
- バス路線の状況
- 終電・始発の時刻
- タクシー需要が増える可能性のあるポイント

回答は箇条書きで分かりやすくお願いします。推測や不確実な情報には「※推定」と明記してください。

質問: ${query}`;

    const result = await callGemini(apiKey, prompt);
    if (result.success) {
      AppLogger.info(`Gemini交通情報検索: ${query}`);
    }
    return result;
  }

  // 周辺イベント情報を検索
  async function searchEvents(apiKey, query, area) {
    const today = new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
    const areaStr = area ? `エリア: ${area}\n` : '';
    const prompt = `あなたはタクシードライバー向けのイベント情報アシスタントです。
今日は${today}です。
${areaStr}
以下の質問に対して、タクシー需要に影響する可能性のあるイベント情報を回答してください。
各イベントについて以下の形式で回答してください:
- イベント名
- 日時（分かれば）
- 場所
- 規模の目安（小/中/大/特大）
- タクシー需要への影響予測（需要増/需要減/不明）

推測や不確実な情報には「※推定」と明記してください。

質問: ${query}`;

    const result = await callGemini(apiKey, prompt);
    if (result.success) {
      AppLogger.info(`Geminiイベント検索: ${query}`);
    }
    return result;
  }

  // 大容量レスポンス用のGemini API呼び出し
  async function callGeminiLarge(apiKey, prompt) {
    if (!apiKey) {
      return { success: false, error: 'Gemini APIキーが設定されていません' };
    }

    try {
      const response = await fetch(API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-goog-api-key': apiKey,
        },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
          generationConfig: {
            temperature: 0.2,
            maxOutputTokens: 8192,
          },
        }),
      });

      if (!response.ok) {
        const errData = await response.json().catch(() => ({}));
        const errMsg = errData.error?.message || `HTTPエラー: ${response.status}`;
        if (response.status === 400) return { success: false, error: 'APIキーが無効です。正しいキーを設定してください。' };
        if (response.status === 429) return { success: false, error: 'API利用制限に達しました。しばらく待ってから再試行してください。' };
        return { success: false, error: errMsg };
      }

      return _parseGeminiResponse(await response.text());
    } catch (e) {
      AppLogger.error('Gemini API呼び出しエラー', e.message);
      return { success: false, error: `通信エラー: ${e.message}` };
    }
  }

  // 電車の運行時刻・運行情報を取得
  async function fetchTrainInfo(apiKey, region) {
    const today = new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
    const area = region || '東京都内および近郊';
    const prompt = `あなたは公共交通機関の情報提供アシスタントです。
今日は${today}です。
ユーザーの現在地: ${area}

「${area}」およびその近郊で利用される主要鉄道路線について、本日の運行情報を網羅的に提供してください。

以下を含めてください:
- この地域を走るJR線の主要路線
- この地域を走る私鉄の主要路線
- この地域を走る地下鉄・モノレール等の路線

各路線について以下を記載してください:
- 始発時刻と終電時刻（主要駅基準）
- 本日の運行ダイヤ（平日/休日ダイヤ）
- ピーク時の運行間隔
- 現在の運行状況（通常運行/遅延/運休など）

見やすい表形式や箇条書きで整理してください。
※情報が確認できない場合は「※一般的な時刻」と明記してください。`;

    const result = await callGeminiLarge(apiKey, prompt);
    if (result.success) {
      AppLogger.info(`Gemini: 電車運行情報を取得 (${area})`);
    }
    return result;
  }

  // バスの運行時刻（旭川駅前バスターミナル実データ）
  // ※2025年12月改正冬ダイヤ準拠。空港バスは月ごとにフライト連動で変わるため目安。
  async function fetchBusInfo(_apiKey, _region) {
    const now = new Date();
    const isWeekend = [0, 6].includes(now.getDay());
    const dayType = isWeekend ? '土日祝日ダイヤ' : '平日ダイヤ';
    const dateStr = now.toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });

    // --- 高速あさひかわ号（札幌⇔旭川）全便 ---
    const asahikawaDepAll = [
      '06:00','07:00','07:30','08:00','08:30','09:00','09:30','10:00',
      '11:00','11:40','12:20','13:00','13:30','14:00','14:40','15:20',
      '15:50','16:30','17:00','17:30','18:00','18:40','19:00','19:30','20:30','21:30',
    ];
    const asahikawaDepWeekend = ['08:45','10:30','14:20']; // 土日祝のみ
    const asahikawaDepOp = {
      '06:00':'中央バス','07:00':'道北バス','07:30':'中央バス','08:00':'道北バス',
      '08:30':'中央バス','08:45':'中央バス','09:00':'中央バス','09:30':'道北バス',
      '10:00':'道北バス','10:30':'中央バス','11:00':'中央バス','11:40':'中央バス',
      '12:20':'JR北海道バス','13:00':'道北バス','13:30':'中央バス','14:00':'中央バス',
      '14:20':'中央バス','14:40':'道北バス','15:20':'中央バス','15:50':'中央バス',
      '16:30':'道北バス','17:00':'中央バス','17:30':'中央バス','18:00':'JR北海道バス',
      '18:40':'中央バス','19:00':'中央バス','19:30':'JR北海道バス','20:30':'中央バス','21:30':'中央バス',
    };
    // 札幌発→旭川着（冬ダイヤ: 所要2時間25分）
    const sapporoDepAll = [
      '07:00','08:00','08:30','09:00','09:50','10:30','11:00','11:30',
      '12:00','12:30','13:00','13:30','14:00','14:30','15:00','15:30',
      '16:00','16:30','17:00','17:30','18:00','18:30','19:00','19:40','20:20','20:50','21:30',
    ];
    const sapporoDepWeekend = ['13:45','19:20'];
    const sapporoDepOp = {
      '07:00':'中央バス','08:00':'JR北海道バス','08:30':'中央バス','09:00':'中央バス',
      '09:50':'中央バス','10:30':'中央バス','11:00':'JR北海道バス','11:30':'道北バス',
      '12:00':'中央バス','12:30':'道北バス','13:00':'中央バス','13:30':'中央バス',
      '13:45':'中央バス','14:00':'道北バス','14:30':'JR北海道バス','15:00':'道北バス',
      '15:30':'中央バス','16:00':'中央バス','16:30':'中央バス','17:00':'中央バス',
      '17:30':'中央バス','18:00':'道北バス','18:30':'中央バス','19:00':'中央バス',
      '19:20':'中央バス','19:40':'道北バス','20:20':'中央バス','20:50':'道北バス','21:30':'中央バス',
    };
    function addMin(hhmm, min) {
      const [h, m] = hhmm.split(':').map(Number);
      const t = h * 60 + m + min;
      return String(Math.floor(t / 60)).padStart(2,'0') + ':' + String(t % 60).padStart(2,'0');
    }

    // --- 都市間バス ---
    // 特急オホーツク号（紋別方面）
    const monbetsuDep = [{t:'12:45',arr:'紋別',dur:'3時間',op:'道北バス/北紋バス'},{t:'17:15',arr:'紋別',dur:'3時間',op:'道北バス/北紋バス'}];
    const monbetsuArr = [{t:'09:45',from:'紋別',op:'道北バス/北紋バス'},{t:'14:45',from:'紋別',op:'道北バス/北紋バス'}];
    // ノースライナー号（帯広方面）
    const obihiroDep = [
      {t:'07:55',arr:'帯広',dur:'4時間10分',op:'拓殖バス/道北バス/十勝バス'},
      {t:'09:30',arr:'帯広',dur:'4時間10分',op:'拓殖バス/道北バス/十勝バス'},
      {t:'14:10',arr:'帯広',dur:'4時間10分',op:'拓殖バス/道北バス/十勝バス'},
      {t:'15:35',arr:'帯広',dur:'4時間10分',op:'拓殖バス/道北バス/十勝バス'},
      {t:'17:10',arr:'帯広',dur:'4時間10分',op:'拓殖バス/道北バス/十勝バス'},
    ];
    const obihiroArr = [
      {t:'12:00',from:'帯広',op:'拓殖バス/道北バス/十勝バス'},
      {t:'13:30',from:'帯広',op:'拓殖バス/道北バス/十勝バス'},
      {t:'15:10',from:'帯広',op:'拓殖バス/道北バス/十勝バス'},
      {t:'19:55',from:'帯広',op:'拓殖バス/道北バス/十勝バス'},
      {t:'21:10',from:'帯広',op:'拓殖バス/道北バス/十勝バス'},
    ];
    // サンライズ旭川・釧路号（北見方面）
    const kitamiDep = [
      {t:'07:50',arr:'北見',dur:'3時間25分',op:'道北バス/北見バス/阿寒バス'},
      {t:'13:05',arr:'北見',dur:'3時間25分',op:'道北バス/北見バス/阿寒バス'},
    ];
    const kitamiArr = [
      {t:'15:15',from:'北見',op:'道北バス/北見バス/阿寒バス'},
      {t:'20:30',from:'北見',op:'道北バス/北見バス/阿寒バス'},
    ];
    // 名寄線（道北バス路線バス）
    const nayoroDep = [
      {t:'06:35',arr:'名寄',dur:'2時間32分',op:'道北バス'},
      {t:'09:10',arr:'名寄',dur:'2時間49分',op:'道北バス'},
      {t:'10:25',arr:'名寄',dur:'2時間49分',op:'道北バス'},
      {t:'12:00',arr:'名寄',dur:'2時間49分',op:'道北バス'},
      {t:'14:45',arr:'名寄',dur:'2時間49分',op:'道北バス'},
      {t:'17:20',arr:'名寄',dur:'2時間49分',op:'道北バス'},
    ];
    const nayoroArr = [
      {t:'09:07',from:'名寄',op:'道北バス'},{t:'11:59',from:'名寄',op:'道北バス'},
      {t:'13:14',from:'名寄',op:'道北バス'},{t:'14:49',from:'名寄',op:'道北バス'},
      {t:'17:34',from:'名寄',op:'道北バス'},{t:'20:09',from:'名寄',op:'道北バス'},
    ];
    // 特急天北号（鬼志別方面）
    const tenpokuDep = [{t:'14:30',arr:'鬼志別',dur:'約5時間',op:'宗谷バス/道北バス'}];
    const tenpokuArr = [{t:'11:10',from:'鬼志別',op:'宗谷バス/道北バス'}];

    // --- 空港連絡バス（2月ダイヤ目安） ---
    const airportDep = [
      {t:'06:56',arr:'旭川空港',op:'旭川電気軌道'},{t:'07:51',arr:'旭川空港',op:'旭川電気軌道'},
      {t:'11:36',arr:'旭川空港',op:'旭川電気軌道'},{t:'12:11',arr:'旭川空港',op:'旭川電気軌道'},
      {t:'12:46',arr:'旭川空港',op:'旭川電気軌道'},{t:'14:11',arr:'旭川空港',op:'旭川電気軌道'},
      {t:'17:36',arr:'旭川空港',op:'旭川電気軌道'},{t:'17:41',arr:'旭川空港',op:'旭川電気軌道'},
    ];
    const airportArr = [
      {t:'09:19',from:'旭川空港',op:'旭川電気軌道'},{t:'10:09',from:'旭川空港',op:'旭川電気軌道'},
      {t:'13:49',from:'旭川空港',op:'旭川電気軌道'},{t:'14:49',from:'旭川空港',op:'旭川電気軌道'},
      {t:'15:09',from:'旭川空港',op:'旭川電気軌道'},{t:'16:39',from:'旭川空港',op:'旭川電気軌道'},
      {t:'19:49',from:'旭川空港',op:'旭川電気軌道'},{t:'19:59',from:'旭川空港',op:'旭川電気軌道'},
    ];

    // --- 旭山動物園線（冬期） ---
    const zooDep = [
      {t:'08:40',arr:'旭山動物園',op:'旭川電気軌道'},{t:'09:40',arr:'旭山動物園',op:'旭川電気軌道'},
      {t:'11:10',arr:'旭山動物園',op:'旭川電気軌道'},{t:'12:10',arr:'旭山動物園',op:'旭川電気軌道'},
      {t:'13:10',arr:'旭山動物園',op:'旭川電気軌道'},{t:'14:40',arr:'旭山動物園',op:'旭川電気軌道'},
    ];
    const zooArr = [
      {t:'11:40',from:'旭山動物園',op:'旭川電気軌道'},{t:'12:10',from:'旭山動物園',op:'旭川電気軌道'},
      {t:'13:10',from:'旭山動物園',op:'旭川電気軌道'},{t:'14:10',from:'旭山動物園',op:'旭川電気軌道'},
      {t:'15:40',from:'旭山動物園',op:'旭川電気軌道'},{t:'16:10',from:'旭山動物園',op:'旭川電気軌道'},
    ];

    // --- テキスト生成 ---
    const nowHH = String(now.getHours()).padStart(2,'0') + ':' + String(now.getMinutes()).padStart(2,'0');
    let text = `## 旭川駅前バスターミナル 時刻表\n📅 ${dateStr}（${dayType}）\n⏰ ${nowHH} 現在\n\n`;
    text += `※2025年12月改正冬ダイヤ準拠　空港バスはフライト連動のため月ごとに変動あり\n\n`;

    // ---- 到着便 ----
    text += `### 🚌 旭川駅前 到着便\n\n`;

    // 高速あさひかわ号 到着
    text += `**■ 高速あさひかわ号 到着（札幌→旭川 所要: 冬2時間25分/夏2時間5分）**\n`;
    text += `| 時刻 | 札幌発 | バス会社 | 備考 |\n|------|--------|----------|------|\n`;
    let sapAll = [...sapporoDepAll];
    if (isWeekend) sapAll = sapAll.concat(sapporoDepWeekend);
    sapAll.sort();
    sapAll.forEach(dep => {
      const arr = addMin(dep, 145); // 冬: 2h25m
      const mark = arr >= nowHH && arr <= addMin(nowHH, 30) ? ' 🚕需要高' : (arr < nowHH ? ' ✅到着済' : '');
      const wknd = sapporoDepWeekend.includes(dep) ? '土日祝のみ' : '';
      text += `| **${arr}** | ${dep}発 | ${sapporoDepOp[dep] || ''} | ${wknd}${mark} |\n`;
    });

    // 都市間バス到着
    text += `\n**■ 都市間バス 到着**\n`;
    text += `| 時刻 | 路線名 | 出発地 | バス会社 | 備考 |\n|------|--------|--------|----------|------|\n`;
    const interArr = [
      ...monbetsuArr.map(a => ({t:a.t,name:'特急オホーツク号',from:a.from,op:a.op})),
      ...obihiroArr.map(a => ({t:a.t,name:'ノースライナー号',from:a.from,op:a.op})),
      ...kitamiArr.map(a => ({t:a.t,name:'サンライズ号',from:a.from,op:a.op})),
      ...nayoroArr.map(a => ({t:a.t,name:'名寄線',from:a.from,op:a.op})),
      ...tenpokuArr.map(a => ({t:a.t,name:'特急天北号',from:a.from,op:a.op})),
    ].sort((a,b) => a.t.localeCompare(b.t));
    interArr.forEach(a => {
      const mark = a.t >= nowHH && a.t <= addMin(nowHH, 30) ? ' 🚕需要高' : (a.t < nowHH ? ' ✅到着済' : '');
      text += `| **${a.t}** | ${a.name} | ${a.from} | ${a.op} | ${mark} |\n`;
    });

    // 空港バス到着
    text += `\n**■ 空港連絡バス 到着（旭川空港→旭川駅 所要: 約39分）**\n`;
    text += `| 時刻 | バス会社 | 備考 |\n|------|----------|------|\n`;
    airportArr.forEach(a => {
      const mark = a.t >= nowHH && a.t <= addMin(nowHH, 30) ? ' 🚕需要高' : (a.t < nowHH ? ' ✅到着済' : '');
      text += `| **${a.t}** | ${a.op} | ${mark} |\n`;
    });

    // 動物園線到着
    text += `\n**■ 旭山動物園線 到着（動物園→旭川駅 所要: 約40-50分）**\n`;
    text += `| 時刻 | バス会社 | 備考 |\n|------|----------|------|\n`;
    zooArr.forEach(a => {
      const mark = a.t < nowHH ? ' ✅到着済' : '';
      text += `| **${a.t}** | ${a.op} | ${mark} |\n`;
    });

    // ---- 出発便 ----
    text += `\n---\n\n### 🚌 旭川駅前 出発便\n\n`;

    // 高速あさひかわ号 出発
    text += `**■ 高速あさひかわ号 出発（旭川→札幌 所要: 冬2時間25分/夏2時間5分）**\n`;
    text += `| 時刻 | バス会社 | 備考 |\n|------|----------|------|\n`;
    let depAll = [...asahikawaDepAll];
    if (isWeekend) depAll = depAll.concat(asahikawaDepWeekend);
    depAll.sort();
    depAll.forEach(dep => {
      const mark = dep < nowHH ? ' ✅出発済' : '';
      const wknd = asahikawaDepWeekend.includes(dep) ? '土日祝のみ' : '';
      text += `| **${dep}** | ${asahikawaDepOp[dep] || ''} | ${wknd}${mark} |\n`;
    });

    // 都市間バス出発
    text += `\n**■ 都市間バス 出発**\n`;
    text += `| 時刻 | 路線名 | 行先 | バス会社 | 備考 |\n|------|--------|------|----------|------|\n`;
    const interDep = [
      ...monbetsuDep.map(d => ({t:d.t,name:'特急オホーツク号',to:d.arr,dur:d.dur,op:d.op})),
      ...obihiroDep.map(d => ({t:d.t,name:'ノースライナー号',to:d.arr,dur:d.dur,op:d.op})),
      ...kitamiDep.map(d => ({t:d.t,name:'サンライズ号',to:d.arr,dur:d.dur,op:d.op})),
      ...nayoroDep.map(d => ({t:d.t,name:'名寄線',to:d.arr,dur:d.dur,op:d.op})),
      ...tenpokuDep.map(d => ({t:d.t,name:'特急天北号',to:d.arr,dur:d.dur,op:d.op})),
    ].sort((a,b) => a.t.localeCompare(b.t));
    interDep.forEach(d => {
      const mark = d.t < nowHH ? ' ✅出発済' : '';
      text += `| **${d.t}** | ${d.name} | ${d.to}（${d.dur}） | ${d.op} | ${mark} |\n`;
    });

    // 空港バス出発
    text += `\n**■ 空港連絡バス 出発（旭川駅→旭川空港 所要: 約44分）**\n`;
    text += `| 時刻 | バス会社 | 備考 |\n|------|----------|------|\n`;
    airportDep.forEach(d => {
      const mark = d.t < nowHH ? ' ✅出発済' : '';
      text += `| **${d.t}** | ${d.op} | ${mark} |\n`;
    });

    // 動物園線出発
    text += `\n**■ 旭山動物園線 出発（旭川駅→動物園 所要: 約40-50分）**\n`;
    text += `| 時刻 | バス会社 | 備考 |\n|------|----------|------|\n`;
    zooDep.forEach(d => {
      const mark = d.t < nowHH ? ' ✅出発済' : '';
      text += `| **${d.t}** | ${d.op} | ${mark} |\n`;
    });

    text += `\n---\n※ 高速あさひかわ号は予約不要（自由席）。都市間バス（紋別・帯広・北見・天北）は要予約。\n`;
    text += `※ 空港連絡バスはフライトスケジュール連動のため毎月変更あり。最新は旭川電気軌道HPでご確認ください。\n`;
    text += `※ 高速えんがる号は旭川駅に停車しません。特急北大雪号（旭川⇔遠軽）は現在運休中です。\n`;
    text += `※ 高速なよろ号（札幌⇔名寄直行）は旭川駅に停車しません。上記は道北バス名寄線（路線バス）です。\n`;

    AppLogger.info('バス時刻表: 旭川駅前ハードコードデータを生成');
    return { success: true, text: text };
  }

  // 飛行機の運航時刻・運航情報を取得
  async function fetchFlightInfo(apiKey, region) {
    const today = new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
    const area = region || '東京都';
    const prompt = `あなたは公共交通機関の情報提供アシスタントです。
今日は${today}です。
ユーザーの現在地: ${area}

「${area}」から最も近い主要空港について、本日のフライト情報を網羅的に提供してください。

まず「${area}」の最寄りの主要空港を特定し、各空港について以下を提供してください:
- 国内線: 主要路線の出発・到着便
- 国際線: 主要路線の出発・到着便（該当する場合）
- 各ターミナルの利用航空会社

以下の情報も含めてください:
- 早朝便（始発〜7時）と深夜便（21時以降）の一覧（タクシー需要が高い時間帯）
- ピーク時間帯（到着便が集中する時間）
- 現在の運航状況（通常運航/遅延/欠航など）
- 天候による影響（ある場合）

見やすい表形式や箇条書きで整理してください。
※情報が確認できない場合は「※一般的なスケジュール」と明記してください。`;

    const result = await callGeminiLarge(apiKey, prompt);
    if (result.success) {
      AppLogger.info(`Gemini: 飛行機運航情報を取得 (${area})`);
    }
    return result;
  }

  // 遅延・トラブル情報を取得
  async function fetchTroubleInfo(apiKey, region) {
    const today = new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
    const now = new Date().toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
    const area = region || '東京都内';
    const prompt = `あなたは公共交通機関の情報提供アシスタントです。
今日は${today}、現在時刻は${now}です。
ユーザーの現在地: ${area}

「${area}」およびその近郊で現在発生している公共交通機関の遅延・トラブル・運休情報をすべて提供してください。

【確認対象】
1. 鉄道（この地域のJR・私鉄・地下鉄すべて）
2. バス（公営バス・民営バス・高速バス）
3. 航空（最寄り空港の発着便）
4. その他（モノレール・新交通システム等）

【各トラブルについて以下を記載】
- 路線名・区間
- トラブルの種類（遅延/運休/運転見合わせ/徐行運転/振替輸送等）
- 原因（人身事故/車両故障/天候/信号故障等）
- 発生時刻（分かれば）
- 復旧見込み（分かれば）
- 影響度（小/中/大）
- タクシー需要への影響（需要増のエリア・駅を具体的に）

【追加情報】
- 本日予定されている計画運休・工事運休
- 天候による今後の影響予測
- 振替輸送の実施状況

タクシードライバーの営業に役立つ観点でまとめてください。
トラブルがない場合は「現在、大きなトラブルは報告されていません」と回答してください。
※リアルタイム情報が不明な場合は「※最新情報は各社公式サイトで確認してください」と明記してください。`;

    const result = await callGeminiLarge(apiKey, prompt);
    if (result.success) {
      AppLogger.info(`Gemini: 遅延・トラブル情報を取得 (${area})`);
    }
    return result;
  }

  // 需要予測JSONパーサー: コードブロック抽出 → 生JSON → ブレース抽出 → 空フォールバック
  function _parseDemandPlanJson(text) {
    const empty = { transitArrivals: [], hospitalWindows: [], demandWindows: [], dailyPlan: [] };
    if (!text || typeof text !== 'string') return empty;
    // 1. コードブロック内のJSON抽出
    const codeBlockMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/);
    if (codeBlockMatch) {
      try { return { ...empty, ...JSON.parse(codeBlockMatch[1].trim()) }; } catch(e) {}
    }
    // 2. そのままJSON
    try { return { ...empty, ...JSON.parse(text.trim()) }; } catch(e) {}
    // 3. ブレース抽出
    const braceMatch = text.match(/\{[\s\S]*\}/);
    if (braceMatch) {
      try { return { ...empty, ...JSON.parse(braceMatch[0]) }; } catch(e) {}
    }
    return empty;
  }

  // 交通需要プラン取得（構造化JSON）
  async function fetchDailyDemandPlan(apiKey, area) {
    area = area || '旭川';
    const today = new Date();
    const dow = ['日','月','火','水','木','金','土'][today.getDay()];
    const dateStr = `${today.getFullYear()}年${today.getMonth()+1}月${today.getDate()}日(${dow})`;

    const dayOfMonth = today.getDate();
    const isEvenDay = dayOfMonth % 2 === 0;
    const stationRule = isEvenDay
      ? `本日は${dayOfMonth}日（偶数日）のため旭川駅前でタクシー待ち営業が可能です。駅前待機を積極的に組み込んでください。`
      : `本日は${dayOfMonth}日（奇数日）のため旭川駅前でのタクシー待ち営業はできません。駅前待機は除外し、病院・商業施設周辺での流し営業を中心にプランを作成してください。`;

    const prompt = `あなたは北海道${area}のタクシー需要予測AIです。
本日は${dateStr}です。

【重要ルール】${stationRule}

以下のJSON形式で、本日の交通需要予測データを返してください。
JSONのみを返し、他のテキストは不要です。

{
  "transitArrivals": [
    { "type": "JR特急", "line": "ライラック", "arrivalTime": "09:30", "origin": "札幌", "demandDelay": 5, "peakWeight": 0.8 }
  ],
  "hospitalWindows": [
    { "name": "旭川医科大学病院", "peakStart": "08:00", "peakEnd": "11:00", "type": "morning", "weight": 0.7 }
  ],
  "demandWindows": [
    { "startTime": "09:25", "endTime": "10:00", "location": "旭川駅", "level": "high", "overlappingArrivals": ["ライラック"], "reason": "JR特急到着+通勤" }
  ],
  "dailyPlan": [
    { "startTime": "06:00", "endTime": "08:00", "location": "旭川駅", "action": "早朝の通勤需要を狙う", "demandLevel": "medium" }
  ]
}

要件:
- transitArrivals: ${area}駅に到着するJR特急・高速バスの本日の時刻表（主要便）。demandDelayは到着後の需要ピークまでの分数。peakWeightは0-1の需要強度。
- hospitalWindows: ${area}市内の主要病院の外来受付ピーク。typeはmorning/afternoon。weightは0-1。
- demandWindows: 上記を組み合わせた需要ピーク時間帯。levelはhigh/medium/low。
- dailyPlan: タクシードライバーの1日の推奨営業プラン（6時〜22時、1-2時間ごとのブロック）。

実際の${area}の時刻表・病院情報に基づいてできるだけ正確に回答してください。`;

    const result = await callGeminiLarge(apiKey, prompt);
    if (result.success) {
      const parsed = _parseDemandPlanJson(result.text);
      AppLogger.info(`Gemini: 需要予測プラン取得 - 到着便${parsed.transitArrivals.length}件, プラン${parsed.dailyPlan.length}ブロック`);
      return { success: true, data: parsed, raw: result.text };
    }
    return { success: false, error: result.error, data: null };
  }

  // APIキーの接続テスト
  async function testConnection(apiKey) {
    const result = await callGemini(apiKey, 'こんにちは。接続テストです。「接続成功」と一言だけ返答してください。');
    return result;
  }

  // レシート画像から金額を読み取る（Vision API）
  async function analyzeReceiptImage(apiKey, base64Image, mimeType) {
    const url = `${API_URL}?key=${apiKey}`;
    const body = {
      contents: [{
        parts: [
          { text: 'このレシート画像から合計金額（税込）を読み取ってください。数値のみを返してください（単位や記号は不要）。合計金額が見つからない場合は「0」を返してください。' },
          { inlineData: { mimeType, data: base64Image } }
        ]
      }]
    };
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });
    if (!res.ok) {
      const errText = await res.text();
      throw new Error(`Gemini API エラー (${res.status}): ${errText}`);
    }
    const parsed = _parseGeminiResponse(await res.text());
    if (!parsed.success) throw new Error(parsed.error);
    const text = parsed.data.candidates[0]?.content?.parts?.[0]?.text || '';
    const match = text.replace(/[,，\s]/g, '').match(/\d+/);
    return match ? parseInt(match[0], 10) : 0;
  }

  // ホテル価格一括取得
  async function fetchHotelPrices(apiKey, hotels) {
    const today = new Date();
    const dateStr = today.toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
    const hotelList = hotels.map((h, i) => `${i + 1}. ${h.name}`).join('\n');

    const prompt = `あなたは北海道旭川市のホテル価格調査アシスタントです。
今日は${dateStr}です。

以下の旭川市内ホテルについて、本日のスタンダードシングル（またはダブル）1泊の標準的な宿泊料金（税込）を調査してください。

${hotelList}

以下のJSON配列のみを返してください。他のテキストは不要です。
各ホテルの料金が不明な場合は、同クラスのホテルの相場から推定し、estimatedをtrueにしてください。

[
  { "name": "ホテル名", "price": 8000, "estimated": false },
  ...
]

注意:
- priceは数値（円単位、税込）
- 繁忙期や週末は通常より高くなる場合があります
- 料金が分からない場合でも必ず推定値を返してください`;

    const result = await callGemini(apiKey, prompt);
    if (!result.success) return result;

    try {
      const jsonText = result.text.replace(/```json?\s*/g, '').replace(/```/g, '').trim();
      const prices = JSON.parse(jsonText);
      if (!Array.isArray(prices)) return { success: false, error: '応答形式が不正です' };
      AppLogger.info(`Gemini: ホテル価格${prices.length}件取得`);
      return { success: true, prices };
    } catch (e) {
      AppLogger.error('ホテル価格パースエラー', e.message);
      return { success: false, error: '価格データの解析に失敗しました' };
    }
  }

  return {
    callGemini,
    searchTransitInfo,
    searchEvents,
    callGeminiLarge,
    fetchTrainInfo,
    fetchBusInfo,
    fetchFlightInfo,
    fetchTroubleInfo,
    fetchDailyDemandPlan,
    testConnection,
    analyzeReceiptImage,
    fetchHotelPrices,
  };
})();
})();

// ============================================================
// FILE: src/context/LogContext.jsx
// ============================================================
(function() {
// LogContext.jsx - ログ状態管理
const { createContext, useState, useEffect, useContext } = React;

window.LogContext = createContext(null);

window.LogProvider = ({ children }) => {
  const [logs, setLogs] = useState(AppLogger.getLogs());

  useEffect(() => {
    const unsub = AppLogger.subscribe(setLogs);
    return unsub;
  }, []);

  const value = {
    logs,
    addLog: AppLogger.info,
    addDebug: AppLogger.debug,
    addWarn: AppLogger.warn,
    addError: AppLogger.error,
    clearLogs: AppLogger.clearLogs,
  };

  return React.createElement(LogContext.Provider, { value }, children);
};

window.useLogContext = () => useContext(LogContext);

})();

// ============================================================
// FILE: src/context/MapContext.jsx
// ============================================================
(function() {
// MapContext.jsx - 地図・GPS状態管理
const { createContext, useState, useCallback, useContext } = React;

window.MapContext = createContext(null);

window.MapProvider = ({ children }) => {
  const [currentPosition, setCurrentPosition] = useState(null);
  const [mapCenter, setMapCenter] = useState(APP_CONSTANTS.DEFAULT_MAP_CENTER);
  const [zoom, setZoom] = useState(APP_CONSTANTS.DEFAULT_MAP_ZOOM);
  const [isTracking, setIsTracking] = useState(false);
  const [gpsError, setGpsError] = useState(null);
  const [accuracy, setAccuracy] = useState(null);
  const [speed, setSpeed] = useState(null);
  const [heading, setHeading] = useState(null);

  const updatePosition = useCallback((position) => {
    const pos = {
      lat: position.coords.latitude,
      lng: position.coords.longitude,
    };
    setCurrentPosition(pos);
    setAccuracy(position.coords.accuracy);
    setSpeed(position.coords.speed);
    setHeading(position.coords.heading);
    setGpsError(null);
  }, []);

  const value = {
    currentPosition,
    setCurrentPosition,
    mapCenter,
    setMapCenter,
    zoom,
    setZoom,
    isTracking,
    setIsTracking,
    gpsError,
    setGpsError,
    accuracy,
    speed,
    heading,
    updatePosition,
  };

  return React.createElement(MapContext.Provider, { value }, children);
};

window.useMapContext = () => useContext(MapContext);

})();

// ============================================================
// FILE: src/context/AppContext.jsx
// ============================================================
(function() {
// AppContext.jsx - アプリ全体の状態管理（ハッシュルーティング対応）
const { createContext, useState, useEffect, useCallback, useContext } = React;

window.AppContext = createContext(null);

// ハッシュからページ名を取得するヘルパー
function getPageFromHash() {
  const hash = window.location.hash.replace('#/', '').replace('#', '');
  const validRoutes = Object.values(APP_CONSTANTS.ROUTES);
  return validRoutes.includes(hash) ? hash : APP_CONSTANTS.ROUTES.DASHBOARD;
}

window.AppProvider = ({ children }) => {
  const [currentPage, setCurrentPage] = useState(getPageFromHash);
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [apiKey, setApiKeyState] = useState(AppStorage.getApiKey());
  const [geminiApiKey, setGeminiApiKeyState] = useState(AppStorage.getGeminiApiKey());

  const setApiKey = useCallback((key) => {
    AppStorage.setApiKey(key);
    setApiKeyState(key);
    AppLogger.info('Google Maps APIキーが更新されました');
  }, []);

  const setGeminiApiKey = useCallback((key) => {
    AppStorage.setGeminiApiKey(key);
    setGeminiApiKeyState(key);
    AppLogger.info('Gemini APIキーが更新されました');
  }, []);

  // ページ遷移（ハッシュを更新 → hashchangeで状態も更新）
  const navigate = useCallback((page) => {
    window.location.hash = `#/${page}`;
    setSidebarOpen(false);
    AppLogger.debug(`ページ遷移: ${page}`);
  }, []);

  // ブラウザの戻る/進むボタン対応
  useEffect(() => {
    const handleHashChange = () => {
      const page = getPageFromHash();
      setCurrentPage(page);
    };
    window.addEventListener('hashchange', handleHashChange);
    return () => window.removeEventListener('hashchange', handleHashChange);
  }, []);

  // 初期ハッシュが空の場合にセット
  useEffect(() => {
    if (!window.location.hash) {
      window.location.hash = `#/${APP_CONSTANTS.ROUTES.DASHBOARD}`;
    }
  }, []);

  // ── 自動同期（SYNC_SECRET設定時のみ） ──
  useEffect(() => {
    const secret = (localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.SYNC_SECRET) || '').trim();
    if (!secret) return;

    // A. アプリ起動時に自動同期
    DataService.autoSync();

    // B. ページ復帰時（タブ切替から戻った時）に自動同期
    const handleVisibility = () => {
      if (document.visibilityState === 'visible') {
        DataService.autoSync();
      }
    };
    document.addEventListener('visibilitychange', handleVisibility);

    // C. 5分間隔の定期同期
    const intervalId = setInterval(() => {
      DataService.autoSync();
    }, 5 * 60 * 1000);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibility);
      clearInterval(intervalId);
    };
  }, []);

  // ── 需要通知サービス ──
  useEffect(() => {
    DemandNotificationService.start();
    return () => DemandNotificationService.stop();
  }, []);

  const value = {
    currentPage,
    navigate,
    sidebarOpen,
    setSidebarOpen,
    apiKey,
    setApiKey,
    geminiApiKey,
    setGeminiApiKey,
  };

  return React.createElement(AppContext.Provider, { value }, children);
};

window.useAppContext = () => useContext(AppContext);

})();

// ============================================================
// FILE: src/hooks/useGeolocation.js
// ============================================================
(function() {
// useGeolocation.js - GPS位置情報カスタムフック
window.useGeolocation = () => {
  const { useState, useEffect, useRef, useCallback } = React;
  const mapCtx = useMapContext();
  const [watchId, setWatchId] = useState(null);
  const watchIdRef = useRef(null);

  const isSupported = 'geolocation' in navigator;

  const getCurrentPosition = useCallback(() => {
    if (!isSupported) {
      mapCtx.setGpsError('このブラウザはGPSに対応していません');
      AppLogger.error('Geolocation API 非対応');
      return;
    }

    AppLogger.info('現在地を取得中（高精度モード）...');

    // getAccuratePositionを使い、複数回のGPS測位から最良の結果を取得
    getAccuratePosition({ accuracyThreshold: 100, timeout: 15000, maxWaitAfterFix: 5000 })
      .then((position) => {
        mapCtx.updatePosition(position);
        const pos = { lat: position.coords.latitude, lng: position.coords.longitude };
        mapCtx.setMapCenter(pos);
        AppLogger.info(`現在地取得成功: ${pos.lat.toFixed(6)}, ${pos.lng.toFixed(6)} 精度: ${Math.round(position.coords.accuracy)}m`);
      })
      .catch((error) => {
        const msg = error.message || getErrorMessage(error);
        mapCtx.setGpsError(msg);
        AppLogger.error(`GPS取得エラー: ${msg}`);
      });
  }, [isSupported, mapCtx]);

  const startTracking = useCallback(() => {
    if (!isSupported) return;

    AppLogger.info('GPS追跡を開始');
    mapCtx.setIsTracking(true);

    const id = navigator.geolocation.watchPosition(
      (position) => {
        mapCtx.updatePosition(position);
      },
      (error) => {
        const msg = getErrorMessage(error);
        mapCtx.setGpsError(msg);
        AppLogger.warn(`GPS追跡エラー: ${msg}`);
      },
      APP_CONSTANTS.GPS_OPTIONS
    );

    watchIdRef.current = id;
    setWatchId(id);
  }, [isSupported, mapCtx]);

  const stopTracking = useCallback(() => {
    if (watchIdRef.current !== null) {
      navigator.geolocation.clearWatch(watchIdRef.current);
      watchIdRef.current = null;
      setWatchId(null);
    }
    mapCtx.setIsTracking(false);
    AppLogger.info('GPS追跡を停止');
  }, [mapCtx]);

  useEffect(() => {
    return () => {
      if (watchIdRef.current !== null) {
        navigator.geolocation.clearWatch(watchIdRef.current);
      }
    };
  }, []);

  return {
    isSupported,
    getCurrentPosition,
    startTracking,
    stopTracking,
    isTracking: mapCtx.isTracking,
  };
};

function getErrorMessage(error) {
  switch (error.code) {
    case error.PERMISSION_DENIED:
      return '位置情報の権限が拒否されました';
    case error.POSITION_UNAVAILABLE:
      return '位置情報を取得できません';
    case error.TIMEOUT:
      return '位置情報の取得がタイムアウトしました';
    default:
      return '位置情報の取得中にエラーが発生しました';
  }
}

// 高精度GPS取得ユーティリティ
window.getAccuratePosition = (options = {}) => {
  const {
    accuracyThreshold = 50,
    timeout = 20000,
    maxWaitAfterFix = 8000,
  } = options;

  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject({ code: 0, message: 'このブラウザではGPS機能が使えません' });
      return;
    }

    let bestPosition = null;
    let watchId = null;
    let overallTimer = null;
    let waitTimer = null;
    let settled = false;

    const cleanup = () => {
      if (watchId !== null) navigator.geolocation.clearWatch(watchId);
      if (overallTimer) clearTimeout(overallTimer);
      if (waitTimer) clearTimeout(waitTimer);
      watchId = null;
      overallTimer = null;
      waitTimer = null;
    };

    const doResolve = (pos) => {
      if (settled) return;
      settled = true;
      cleanup();
      AppLogger.info(`GPS確定: 精度${pos.coords.accuracy.toFixed(0)}m (${pos.coords.latitude.toFixed(6)}, ${pos.coords.longitude.toFixed(6)})`);
      resolve(pos);
    };

    const doReject = (err) => {
      if (settled) return;
      settled = true;
      cleanup();
      reject(err);
    };

    const finish = () => {
      if (bestPosition) {
        doResolve(bestPosition);
      } else {
        doReject({ code: 2, message: '現在地を取得できませんでした。' });
      }
    };

    overallTimer = setTimeout(finish, timeout);

    watchId = navigator.geolocation.watchPosition(
      (position) => {
        if (settled) return;
        const acc = position.coords.accuracy;
        AppLogger.info(`GPS受信: 精度${acc.toFixed(0)}m lat=${position.coords.latitude.toFixed(6)} lng=${position.coords.longitude.toFixed(6)}`);

        if (!bestPosition || acc < bestPosition.coords.accuracy) {
          bestPosition = position;
        }

        if (acc <= accuracyThreshold) {
          doResolve(position);
          return;
        }

        if (!waitTimer) {
          waitTimer = setTimeout(finish, maxWaitAfterFix);
        }
      },
      (error) => {
        // Permission denied は即座にreject（リトライしても無駄）
        if (error.code === 1) {
          doReject(error);
          return;
        }
        // その他のエラー（TIMEOUT/POSITION_UNAVAILABLE）は一時的な場合があるので
        // bestPositionがあればそれを使い、なければ全体タイムアウトに任せる
        AppLogger.warn(`GPS一時エラー: code=${error.code} ${error.message || ''}`);
        if (bestPosition) {
          doResolve(bestPosition);
        }
        // bestPositionがなければoverallTimerのfinish()でrejectされる
      },
      { enableHighAccuracy: true, timeout: Math.min(timeout, 15000), maximumAge: 0 }
    );
  });
};

})();

// ============================================================
// FILE: src/hooks/useGoogleMaps.js
// ============================================================
(function() {
// useGoogleMaps.js - Google Maps API管理フック
//
// GoogleMap.jsx内のローダーロジックをフックとして公開し、
// 複数コンポーネントからGoogle Maps APIの状態を参照可能にする。

window.useGoogleMaps = () => {
  const { useState, useEffect, useCallback } = React;
  const { apiKey } = useAppContext();
  const [isLoaded, setIsLoaded] = useState(!!(window.google && window.google.maps));
  const [error, setError] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  // Google Maps API をロード
  const loadApi = useCallback(() => {
    if (!apiKey) {
      setError(null);
      setIsLoaded(false);
      return;
    }

    if (window.google && window.google.maps) {
      setIsLoaded(true);
      setError(null);
      return;
    }

    setIsLoading(true);

    // 既存のスクリプトがあるかチェック
    const existingScript = document.querySelector('script[src*="maps.googleapis.com"]');
    if (existingScript) {
      // ロード完了を待つ
      const check = setInterval(() => {
        if (window.google && window.google.maps) {
          clearInterval(check);
          setIsLoaded(true);
          setIsLoading(false);
          setError(null);
        }
      }, 100);
      return;
    }

    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&language=ja&region=JP`;
    script.async = true;
    script.onload = () => {
      setIsLoaded(true);
      setIsLoading(false);
      setError(null);
      AppLogger.info('Google Maps API ロード完了 (useGoogleMaps)');
    };
    script.onerror = () => {
      setError('Google Maps API の読み込みに失敗しました。APIキーを確認してください。');
      setIsLoading(false);
      AppLogger.error('Google Maps API ロード失敗 (useGoogleMaps)');
    };
    document.head.appendChild(script);
  }, [apiKey]);

  useEffect(() => {
    loadApi();
  }, [loadApi]);

  return {
    isLoaded,
    isLoading,
    error,
    apiKey,
    reload: loadApi,
  };
};

})();

// ============================================================
// FILE: src/hooks/useLogger.js
// ============================================================
(function() {
// useLogger.js - ロギング用カスタムフック
//
// AppLogger をReactコンポーネントから便利に使うためのフック。
// コンポーネント名を自動的にプレフィックスとして付加する。

window.useLogger = (componentName = '') => {
  const { useCallback, useMemo } = React;

  const prefix = componentName ? `[${componentName}] ` : '';

  const logger = useMemo(() => ({
    debug: (msg, data) => AppLogger.debug(`${prefix}${msg}`, data),
    info: (msg, data) => AppLogger.info(`${prefix}${msg}`, data),
    warn: (msg, data) => AppLogger.warn(`${prefix}${msg}`, data),
    error: (msg, data) => AppLogger.error(`${prefix}${msg}`, data),
  }), [prefix]);

  // コンポーネントのマウント/アンマウントをログ
  const logMount = useCallback(() => {
    if (componentName) {
      AppLogger.debug(`${prefix}マウント`);
    }
  }, [prefix, componentName]);

  const logUnmount = useCallback(() => {
    if (componentName) {
      AppLogger.debug(`${prefix}アンマウント`);
    }
  }, [prefix, componentName]);

  return {
    ...logger,
    logMount,
    logUnmount,
    getLogs: AppLogger.getLogs,
    clearLogs: AppLogger.clearLogs,
    subscribe: AppLogger.subscribe,
  };
};

})();

// ============================================================
// FILE: src/components/common/Loading.jsx
// ============================================================
(function() {
// Loading.jsx - ローディング表示
window.Loading = ({ message = '読み込み中...' }) => {
  return React.createElement('div', { className: 'loading' },
    React.createElement('div', { className: 'loading__spinner' }),
    React.createElement('span', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)' } }, message)
  );
};

})();

// ============================================================
// FILE: src/components/common/Card.jsx
// ============================================================
(function() {
// Card.jsx - 汎用カード
window.Card = ({ title, subtitle, children, className = '', onClick, style }) => {
  return React.createElement('div', {
    className: `card ${className}`,
    onClick,
    style: { ...style, cursor: onClick ? 'pointer' : 'default' },
  },
    title && React.createElement('div', { className: 'card__title' }, title),
    subtitle && React.createElement('div', { className: 'card__subtitle' }, subtitle),
    children
  );
};

})();

// ============================================================
// FILE: src/components/common/Button.jsx
// ============================================================
(function() {
// Button.jsx - 汎用ボタン
window.Button = ({ children, variant = 'primary', icon, onClick, disabled, className = '', style }) => {
  return React.createElement('button', {
    className: `btn btn--${variant} ${className}`,
    onClick,
    disabled,
    style,
  },
    icon && React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, icon),
    children
  );
};

})();

// ============================================================
// FILE: src/components/common/ErrorBoundary.jsx
// ============================================================
(function() {
// ErrorBoundary.jsx - エラーバウンダリ（白画面クラッシュ防止）
// React Error Boundary はクラスコンポーネントが必要
window.ErrorBoundary = class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({ errorInfo });
    // ログに記録
    if (window.AppLogger) {
      AppLogger.error(`ErrorBoundary: ${error.message}`);
    }
    console.error('[ErrorBoundary]', error, errorInfo);
  }

  handleReset() {
    this.setState({ hasError: false, error: null, errorInfo: null });
  }

  handleReload() {
    window.location.reload();
  }

  render() {
    if (this.state.hasError) {
      return React.createElement('div', {
        style: {
          display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
          minHeight: '60vh', padding: '24px', textAlign: 'center',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '64px', color: 'var(--color-danger)', marginBottom: '16px' },
        }, 'error_outline'),

        React.createElement('h2', {
          style: { color: 'var(--text-primary)', marginBottom: '8px', fontSize: 'var(--font-size-xl)' },
        }, 'エラーが発生しました'),

        React.createElement('p', {
          style: { color: 'var(--text-secondary)', marginBottom: '24px', maxWidth: '400px', fontSize: 'var(--font-size-sm)' },
        }, 'アプリケーションで予期しないエラーが発生しました。再試行するか、ページを再読み込みしてください。'),

        // エラー詳細（開発時のみ表示を想定）
        this.state.error && React.createElement('details', {
          style: {
            marginBottom: '24px', textAlign: 'left', maxWidth: '500px', width: '100%',
            background: 'rgba(229,57,53,0.08)', borderRadius: '8px', padding: '12px',
            fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)',
          },
        },
          React.createElement('summary', {
            style: { cursor: 'pointer', color: 'var(--text-secondary)', marginBottom: '8px' },
          }, 'エラー詳細を表示'),
          React.createElement('pre', {
            style: { whiteSpace: 'pre-wrap', wordBreak: 'break-all', margin: 0 },
          }, String(this.state.error)),
          this.state.errorInfo && React.createElement('pre', {
            style: { whiteSpace: 'pre-wrap', wordBreak: 'break-all', margin: '8px 0 0', fontSize: '11px' },
          }, this.state.errorInfo.componentStack)
        ),

        // アクションボタン
        React.createElement('div', { style: { display: 'flex', gap: '12px' } },
          React.createElement('button', {
            onClick: () => this.handleReset(),
            style: {
              padding: '10px 24px', borderRadius: '8px', border: 'none', cursor: 'pointer',
              background: 'var(--color-primary)', color: '#fff', fontWeight: 500,
              fontSize: 'var(--font-size-sm)',
            },
          }, '再試行'),
          React.createElement('button', {
            onClick: () => this.handleReload(),
            style: {
              padding: '10px 24px', borderRadius: '8px', border: '1px solid rgba(255,255,255,0.15)',
              cursor: 'pointer', background: 'transparent', color: 'var(--text-secondary)',
              fontWeight: 500, fontSize: 'var(--font-size-sm)',
            },
          }, 'ページ再読み込み')
        )
      );
    }

    return this.props.children;
  }
};

})();

// ============================================================
// FILE: src/components/Map/GoogleMap.jsx
// ============================================================
(function() {
// GoogleMap.jsx - Google Maps 本体コンポーネント（TrafficLayer対応・高速ロード版）
const { useState, useEffect, useRef, useCallback } = React;

// ============================================================
// Google Maps スクリプトローダー（シングルトン）
// ============================================================
window._gmapLoader = {
  status: 'idle',
  loadedKey: null,
  callbacks: [],

  reset() {
    this.status = 'idle';
    this.loadedKey = null;
    this.callbacks = [];
    const s = document.querySelector('script[src*="maps.googleapis.com"]');
    if (s) s.remove();
    if (window.google) {
      try { delete window.google; } catch (e) { window.google = undefined; }
    }
  },

  load(apiKey) {
    return new Promise((resolve, reject) => {
      if (this.loadedKey && this.loadedKey !== apiKey) {
        this.reset();
      }
      if (window.google && window.google.maps && this.status === 'loaded' && this.loadedKey === apiKey) {
        resolve();
        return;
      }
      this.callbacks.push({ resolve, reject });
      if (this.status === 'loading') return;
      if (this.status === 'error') {
        const s = document.querySelector('script[src*="maps.googleapis.com"]');
        if (s) s.remove();
        if (window.google) {
          try { delete window.google; } catch (e) { window.google = undefined; }
        }
      }
      this.status = 'loading';
      const script = document.createElement('script');
      script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&language=ja&region=JP&v=weekly&libraries=visualization`;
      script.async = true;
      script.onload = () => {
        this.status = 'loaded';
        this.loadedKey = apiKey;
        this.callbacks.forEach(cb => cb.resolve());
        this.callbacks = [];
      };
      script.onerror = () => {
        this.status = 'error';
        this.loadedKey = null;
        script.remove();
        this.callbacks.forEach(cb => cb.reject(new Error('SCRIPT_LOAD_ERROR')));
        this.callbacks = [];
      };
      document.head.appendChild(script);
    });
  }
};

// Google Maps API エラー検出（console.errorからエラータイプを捕捉）
let _gmapErrorType = '';
const _origConsoleError = console.error;
console.error = function() {
  const msg = Array.from(arguments).join(' ');
  if (msg.includes('Google Maps JavaScript API error:')) {
    _gmapErrorType = msg.replace(/.*Google Maps JavaScript API error:\s*/, '').trim();
    if (typeof AppLogger !== 'undefined') {
      AppLogger.error('Google Maps APIエラー検出: ' + _gmapErrorType);
    }
  }
  _origConsoleError.apply(console, arguments);
};

window.gm_authFailure = () => {
  window._gmapLoader.status = 'error';
  window._gmapLoader.loadedKey = null;
  if (typeof AppLogger !== 'undefined') {
    AppLogger.error('Google Maps API 認証失敗 (gm_authFailure): エラータイプ=' + (_gmapErrorType || '不明'));
  }
  window.dispatchEvent(new CustomEvent('gmaps_auth_error', { detail: _gmapErrorType }));
};

// ============================================================
// メインコンポーネント
// ============================================================
window.GoogleMapView = ({ fullscreen = false }) => {
  const { apiKey } = useAppContext();
  const { mapCenter, zoom, currentPosition, accuracy, setMapCenter, setZoom } = useMapContext();
  const mapRef = useRef(null);
  const mapInstanceRef = useRef(null);
  const markerRef = useRef(null);
  const accuracyCircleRef = useRef(null);
  const trafficLayerRef = useRef(null);
  const heatmapLayerRef = useRef(null);
  const aiHeatmapLayerRef = useRef(null);
  const aiModelRef = useRef(null);
  const [mapLoaded, setMapLoaded] = useState(false);
  const [mapError, setMapError] = useState(null);
  const [showTraffic, setShowTraffic] = useState(true);
  const [showHeatmap, setShowHeatmap] = useState(true);
  const [heatmapMode, setHeatmapMode] = useState('timeAware');
  const [heatmapStats, setHeatmapStats] = useState(null);
  const [showAiHeatmap, setShowAiHeatmap] = useState(false);
  const [aiTraining, setAiTraining] = useState(false);
  const [showPriceTier, setShowPriceTier] = useState(false);
  const [priceTierSource, setPriceTierSource] = useState('all');
  const priceTierMarkersRef = useRef([]);
  const [nearbyEstimate, setNearbyEstimate] = useState(null);
  const [showPricePredict, setShowPricePredict] = useState(false);
  const [priceTraining, setPriceTraining] = useState(false);
  const priceModelRef = useRef(null);
  const pricePredictMarkersRef = useRef([]);
  const [simHour, setSimHour] = useState(new Date().getHours());
  const [simMode, setSimMode] = useState(false);
  const initDone = useRef(false);
  const firstGpsDone = useRef(false);

  const [errorDetail, setErrorDetail] = useState(null);

  // Google Maps API 認証エラーを検知
  useEffect(() => {
    const handler = (e) => {
      const errorType = e.detail || _gmapErrorType || '';
      setErrorDetail(errorType);
      let msg = '';
      if (errorType.includes('ApiNotActivatedMapError')) {
        msg = '【Maps JavaScript API が無効です】\nGoogle Cloud Console → APIとサービス → ライブラリ\n→「Maps JavaScript API」を検索して「有効にする」を押してください。';
      } else if (errorType.includes('InvalidKeyMapError')) {
        msg = '【APIキーが無効です】\n設定画面でAPIキーが正しくコピーされているか確認してください。';
      } else if (errorType.includes('MissingKeyMapError')) {
        msg = '【APIキーがありません】\n設定画面からGoogle Maps APIキーを入力してください。';
      } else if (errorType.includes('RefererNotAllowedMapError')) {
        msg = '【HTTPリファラー制限エラー】\nGoogle Cloud Console → 認証情報 → APIキー → アプリケーションの制限\n→ リファラーに以下を追加してください:\n' + window.location.origin + '/*';
      } else if (errorType.includes('BillingNotEnabledMapError') || errorType.includes('OverQueryLimitMapError')) {
        msg = '【課金が有効になっていません】\nGoogle Cloud Console → お支払い → 請求先アカウントを設定してください。\n（月$200の無料枠あり）';
      } else if (errorType.includes('ExpiredKeyMapError')) {
        msg = '【APIキーの有効期限切れ】\nGoogle Cloud Console で新しいAPIキーを作成してください。';
      } else {
        msg = 'Google Maps API の認証に失敗しました。\n\n確認事項:\n1. APIキーが正しいか\n2. Maps JavaScript API が有効か\n3. Billing（課金）が設定されているか\n4. APIキーの制限設定';
        if (errorType) msg += '\n\nエラータイプ: ' + errorType;
      }
      setMapError(msg);
      setMapLoaded(false);
    };
    window.addEventListener('gmaps_auth_error', handler);
    return () => window.removeEventListener('gmaps_auth_error', handler);
  }, []);

  // Google Maps API をロード
  useEffect(() => {
    if (!apiKey) {
      setMapError(null);
      setMapLoaded(false);
      return;
    }

    // APIキー変更時にマップ状態をリセット
    initDone.current = false;
    mapInstanceRef.current = null;
    markerRef.current = null;
    accuracyCircleRef.current = null;
    trafficLayerRef.current = null;
    firstGpsDone.current = false;
    setMapLoaded(false);
    setMapError(null);

    let cancelled = false;
    window._gmapLoader.load(apiKey)
      .then(() => {
        if (!cancelled) {
          setMapLoaded(true);
          setMapError(null);
          AppLogger.info('Google Maps API ロード完了');
        }
      })
      .catch(() => {
        if (!cancelled) {
          setMapError('Google Maps API の読み込みに失敗しました。\nAPIキーとネットワーク接続を確認してください。');
          AppLogger.error('Google Maps API ロード失敗');
        }
      });
    return () => { cancelled = true; };
  }, [apiKey]);

  // マップ初期化
  useEffect(() => {
    if (!mapLoaded || !mapRef.current || !window.google || !window.google.maps || initDone.current) return;
    initDone.current = true;

    try {
      // GPS位置があればそこを初期中心に、なければデフォルト
      const initCenter = currentPosition || mapCenter;
      const initZoom = currentPosition ? 15 : zoom;

      const map = new google.maps.Map(mapRef.current, {
        center: initCenter,
        zoom: initZoom,
        mapTypeId: 'roadmap',
        disableDefaultUI: false,
        zoomControl: true,
        mapTypeControl: true,
        mapTypeControlOptions: {
          style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
          position: google.maps.ControlPosition.TOP_LEFT,
        },
        streetViewControl: false,
        fullscreenControl: false,
        scaleControl: true,
        gestureHandling: 'greedy',
      });
      mapInstanceRef.current = map;

      // 交通情報レイヤーを即座に追加
      const trafficLayer = new google.maps.TrafficLayer();
      trafficLayer.setMap(map);
      trafficLayerRef.current = trafficLayer;

      // GPS位置があれば初回マーカーも配置
      if (currentPosition) {
        firstGpsDone.current = true;
        _placeMarker(map, currentPosition);
      }

      // イベントリスナー（スロットリング付き）
      let centerTimer = null;
      map.addListener('center_changed', () => {
        clearTimeout(centerTimer);
        centerTimer = setTimeout(() => {
          const c = map.getCenter();
          setMapCenter({ lat: c.lat(), lng: c.lng() });
        }, 300);
      });
      map.addListener('zoom_changed', () => {
        setZoom(map.getZoom());
      });

      AppLogger.info('Google Maps 初期化完了（TrafficLayer有効）');
    } catch (e) {
      setMapError('Google Maps の初期化に失敗しました: ' + e.message);
      AppLogger.error('Google Maps 初期化エラー: ' + e.message);
    }
  }, [mapLoaded]);

  // 精度に応じた色を決定
  function _getAccuracyColor(acc) {
    if (!acc || acc <= 100) return '#4285F4';   // 青: 高精度
    if (acc <= 500) return '#F9A825';           // 黄: 中精度
    return '#E53935';                           // 赤: 低精度
  }

  // マーカー配置用のヘルパー
  function _placeMarker(map, pos) {
    const color = _getAccuracyColor(accuracy);
    if (!markerRef.current) {
      markerRef.current = new google.maps.Marker({
        position: pos,
        map: map,
        title: '現在地',
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 10,
          fillColor: color,
          fillOpacity: 1,
          strokeColor: '#ffffff',
          strokeWeight: 3,
        },
        zIndex: 999,
      });
      accuracyCircleRef.current = new google.maps.Circle({
        map: map,
        center: pos,
        radius: accuracy || 50,
        fillColor: color,
        fillOpacity: accuracy && accuracy > 500 ? 0.12 : 0.08,
        strokeColor: color,
        strokeOpacity: 0.3,
        strokeWeight: 1,
        clickable: false,
      });
    }
  }

  // 交通レイヤーの表示/非表示
  useEffect(() => {
    if (!trafficLayerRef.current || !mapInstanceRef.current) return;
    trafficLayerRef.current.setMap(showTraffic ? mapInstanceRef.current : null);
  }, [showTraffic]);

  // ヒートマップレイヤーの表示/非表示（時間帯対応スマートヒートマップ）
  useEffect(() => {
    if (!mapInstanceRef.current || !window.google || !window.google.maps.visualization) return;
    const map = mapInstanceRef.current;

    if (showHeatmap) {
      const result = DataService.getSmartHeatmapData(heatmapMode);
      const points = result.points;
      setHeatmapStats(result.stats);
      if (points.length === 0) {
        // データなしでもフォールバック：従来のgetHeatmapDataを試行
        const fallback = DataService.getHeatmapData();
        if (fallback.length === 0) return;
        const heatData = fallback.map(p => ({
          location: new google.maps.LatLng(p.lat, p.lng),
          weight: p.weight,
        }));
        if (heatmapLayerRef.current) heatmapLayerRef.current.setMap(null);
        const calcRadius = () => {
          const z = map.getZoom() || 13;
          const metersPerPx = 156543.03 * Math.cos((map.getCenter().lat() || 43.77) * Math.PI / 180) / Math.pow(2, z);
          return Math.max(10, Math.round(350 / metersPerPx));
        };
        heatmapLayerRef.current = new google.maps.visualization.HeatmapLayer({
          data: heatData, map: map, radius: calcRadius(), opacity: 0.85, dissipating: true, maxIntensity: 8,
          gradient: [
            'rgba(0,0,0,0)', 'rgba(0,100,255,0.15)', 'rgba(0,180,255,0.4)', 'rgba(0,210,120,0.55)',
            'rgba(180,230,50,0.7)', 'rgba(255,220,30,0.8)', 'rgba(255,160,0,0.88)', 'rgba(255,80,20,0.94)', 'rgba(220,30,30,1)',
          ],
        });
        const zoomListener = map.addListener('zoom_changed', () => {
          if (heatmapLayerRef.current) heatmapLayerRef.current.setOptions({ radius: calcRadius() });
        });
        return () => {
          google.maps.event.removeListener(zoomListener);
          if (heatmapLayerRef.current) { heatmapLayerRef.current.setMap(null); heatmapLayerRef.current = null; }
        };
      }

      const heatData = points.map(p => ({
        location: new google.maps.LatLng(p.lat, p.lng),
        weight: p.weight,
      }));
      if (heatmapLayerRef.current) heatmapLayerRef.current.setMap(null);

      const calcRadius = () => {
        const z = map.getZoom() || 13;
        const metersPerPx = 156543.03 * Math.cos((map.getCenter().lat() || 43.77) * Math.PI / 180) / Math.pow(2, z);
        return Math.max(10, Math.round(350 / metersPerPx));
      };

      // モード別グラデーション（より多い色ステップで滑らかに）
      const gradients = {
        timeAware: [
          'rgba(0,0,0,0)', 'rgba(30,100,230,0.15)', 'rgba(30,160,255,0.35)', 'rgba(0,200,150,0.5)',
          'rgba(140,230,60,0.65)', 'rgba(255,220,30,0.78)', 'rgba(255,150,0,0.88)', 'rgba(240,60,40,0.95)', 'rgba(180,20,20,1)',
        ],
        all: [
          'rgba(0,0,0,0)', 'rgba(0,100,255,0.15)', 'rgba(0,180,255,0.4)', 'rgba(0,210,120,0.55)',
          'rgba(180,230,50,0.7)', 'rgba(255,220,30,0.8)', 'rgba(255,160,0,0.88)', 'rgba(255,80,20,0.94)', 'rgba(220,30,30,1)',
        ],
        transit: [
          'rgba(0,0,0,0)', 'rgba(200,50,150,0.12)', 'rgba(236,72,153,0.3)', 'rgba(255,100,180,0.5)',
          'rgba(255,140,200,0.65)', 'rgba(255,180,220,0.78)', 'rgba(255,100,150,0.88)', 'rgba(220,40,100,0.95)', 'rgba(180,20,60,1)',
        ],
        combined: [
          'rgba(0,0,0,0)', 'rgba(80,40,180,0.12)', 'rgba(124,58,237,0.3)', 'rgba(140,80,255,0.5)',
          'rgba(180,120,255,0.65)', 'rgba(220,180,255,0.75)', 'rgba(255,150,100,0.85)', 'rgba(255,80,40,0.93)', 'rgba(200,30,30,1)',
        ],
      };
      const gradient = gradients[heatmapMode] || gradients.all;

      heatmapLayerRef.current = new google.maps.visualization.HeatmapLayer({
        data: heatData,
        map: map,
        radius: calcRadius(),
        opacity: 0.85,
        dissipating: true,
        maxIntensity: 8,
        gradient: gradient,
      });

      const zoomListener = map.addListener('zoom_changed', () => {
        if (heatmapLayerRef.current) heatmapLayerRef.current.setOptions({ radius: calcRadius() });
      });

      return () => {
        google.maps.event.removeListener(zoomListener);
        if (heatmapLayerRef.current) { heatmapLayerRef.current.setMap(null); heatmapLayerRef.current = null; }
      };
    } else {
      if (heatmapLayerRef.current) { heatmapLayerRef.current.setMap(null); heatmapLayerRef.current = null; }
      setHeatmapStats(null);
    }

    return () => {
      if (heatmapLayerRef.current) { heatmapLayerRef.current.setMap(null); heatmapLayerRef.current = null; }
    };
  }, [showHeatmap, heatmapMode]);

  // AI予測ヒートマップの表示/非表示
  useEffect(() => {
    if (!mapInstanceRef.current || !window.google || !window.google.maps.visualization) return;
    const map = mapInstanceRef.current;

    if (!showAiHeatmap) {
      if (aiHeatmapLayerRef.current) {
        aiHeatmapLayerRef.current.setMap(null);
        aiHeatmapLayerRef.current = null;
      }
      return;
    }

    setAiTraining(true);
    // 非同期で学習・予測（UIブロック回避）
    setTimeout(() => {
      try {
        // モデルをキャッシュ、データ変更時はnullリセット
        if (!aiModelRef.current) {
          aiModelRef.current = LightGBMService.trainModel();
        }

        if (!aiModelRef.current) {
          setAiTraining(false);
          AppLogger.warn('AI予測: GPS付きデータが不足しています（5件以上必要）');
          setShowAiHeatmap(false);
          return;
        }

        // 現在の条件を取得（シミュレーションモード対応）
        const now = new Date();
        const hour = simMode ? simHour : now.getHours();
        const dow = now.getDay();
        const entries = DataService.getEntries();
        const latestWeather = entries.length > 0 ? (entries[0].weather || '') : '';

        // マップの表示範囲を取得
        const bounds = map.getBounds();
        if (!bounds) { setAiTraining(false); return; }
        const ne = bounds.getNorthEast();
        const sw = bounds.getSouthWest();
        const mapBounds = { north: ne.lat(), south: sw.lat(), east: ne.lng(), west: sw.lng() };

        const points = LightGBMService.predictGrid(aiModelRef.current, mapBounds, hour, dow, latestWeather);

        if (aiHeatmapLayerRef.current) {
          aiHeatmapLayerRef.current.setMap(null);
        }

        if (points.length > 0) {
          const heatData = points.map(p => ({
            location: new google.maps.LatLng(p.lat, p.lng),
            weight: p.weight,
          }));
          aiHeatmapLayerRef.current = new google.maps.visualization.HeatmapLayer({
            data: heatData,
            map: map,
            radius: 25,
            opacity: 0.6,
            gradient: [
              'rgba(0, 0, 0, 0)',
              'rgba(66, 133, 244, 0.3)',
              'rgba(0, 200, 255, 0.5)',
              'rgba(0, 230, 118, 0.6)',
              'rgba(255, 235, 59, 0.7)',
              'rgba(255, 152, 0, 0.85)',
              'rgba(244, 67, 54, 1)',
            ],
          });
          const info = LightGBMService.getModelInfo(aiModelRef.current);
          AppLogger.info(`AI需要予測: ${points.length}グリッド表示, ${info.nTrees}本の木, 基準値¥${info.basePrediction}`);
        } else {
          AppLogger.info('AI需要予測: 現在の条件では需要予測なし');
        }
      } catch (e) {
        AppLogger.error('AI予測エラー: ' + e.message);
      }
      setAiTraining(false);
    }, 50);

    return () => {
      if (aiHeatmapLayerRef.current) {
        aiHeatmapLayerRef.current.setMap(null);
        aiHeatmapLayerRef.current = null;
      }
    };
  }, [showAiHeatmap, simHour, simMode]);

  // 単価ランクマーカーレイヤーの表示/非表示
  useEffect(() => {
    // 既存マーカーをクリア
    priceTierMarkersRef.current.forEach(m => m.setMap(null));
    priceTierMarkersRef.current = [];
    setNearbyEstimate(null);

    if (!showPriceTier || !mapInstanceRef.current || !window.google) return;
    const map = mapInstanceRef.current;
    const src = priceTierSource === 'all' ? null : priceTierSource;
    const points = DataService.getPriceTierHeatmapData(src);

    if (points.length === 0) return;

    const tierColors = { short: '#4CAF50', mid: '#FFC107', long: '#F44336' };
    const tierLabels = { short: '短', mid: '中', long: '長' };

    points.forEach(p => {
      const marker = new google.maps.Marker({
        position: { lat: p.lat, lng: p.lng },
        map: map,
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          fillColor: tierColors[p.tier],
          fillOpacity: 0.7,
          strokeColor: '#fff',
          strokeWeight: 1,
          scale: p.tier === 'long' ? 10 : p.tier === 'mid' ? 8 : 6,
        },
        title: `¥${p.amount.toLocaleString()} (${p.source}) ${p.area}`,
        zIndex: p.tier === 'long' ? 3 : p.tier === 'mid' ? 2 : 1,
      });
      priceTierMarkersRef.current.push(marker);
    });

    // 現在位置の周辺推定
    const pos = currentPosition || mapCenter;
    if (pos && pos.lat && pos.lng) {
      setNearbyEstimate(DataService.getNearbyEstimate(pos.lat, pos.lng, 2));
    }

    return () => {
      priceTierMarkersRef.current.forEach(m => m.setMap(null));
      priceTierMarkersRef.current = [];
    };
  }, [showPriceTier, priceTierSource]);

  // AI単価予測レイヤーの表示/非表示
  useEffect(() => {
    pricePredictMarkersRef.current.forEach(m => m.setMap(null));
    pricePredictMarkersRef.current = [];

    if (!showPricePredict || !mapInstanceRef.current || !window.google) return;
    const map = mapInstanceRef.current;

    setPriceTraining(true);
    setTimeout(() => {
      try {
        if (!priceModelRef.current) {
          priceModelRef.current = LightGBMService.trainPriceModel();
        }
        if (!priceModelRef.current) {
          setPriceTraining(false);
          AppLogger.warn('単価予測: GPS+金額付きデータが不足しています（5件以上必要）');
          setShowPricePredict(false);
          return;
        }

        const bounds = map.getBounds();
        if (!bounds) { setPriceTraining(false); return; }
        const ne = bounds.getNorthEast();
        const sw = bounds.getSouthWest();
        const mapBounds = { north: ne.lat(), south: sw.lat(), east: ne.lng(), west: sw.lng() };

        const hour = simMode ? simHour : new Date().getHours();
        const dow = new Date().getDay();
        const entries = DataService.getEntries();
        const weather = entries.length > 0 ? (entries[0].weather || '') : '';

        const points = LightGBMService.predictPriceGrid(priceModelRef.current, mapBounds, hour, dow, weather);

        const tierColors = { short: '#4CAF50', mid: '#FFC107', long: '#F44336' };

        points.forEach(p => {
          const marker = new google.maps.Marker({
            position: { lat: p.lat, lng: p.lng },
            map: map,
            icon: {
              path: google.maps.SymbolPath.CIRCLE,
              fillColor: tierColors[p.tier],
              fillOpacity: 0.45,
              strokeColor: tierColors[p.tier],
              strokeWeight: 0.5,
              scale: p.tier === 'long' ? 14 : p.tier === 'mid' ? 11 : 8,
            },
            title: '予測単価: ¥' + p.price.toLocaleString(),
            clickable: false,
            zIndex: p.tier === 'long' ? 3 : p.tier === 'mid' ? 2 : 1,
          });
          pricePredictMarkersRef.current.push(marker);
        });

        const info = LightGBMService.getModelInfo(priceModelRef.current);
        AppLogger.info('AI単価予測: ' + points.length + 'グリッド表示, ' + info.nTrees + '本の木');
      } catch (e) {
        AppLogger.error('単価予測エラー: ' + e.message);
      }
      setPriceTraining(false);
    }, 50);

    return () => {
      pricePredictMarkersRef.current.forEach(m => m.setMap(null));
      pricePredictMarkersRef.current = [];
    };
  }, [showPricePredict, simHour, simMode]);

  // データ変更時にアクティブなレイヤーを自動更新
  useEffect(() => {
    const handler = () => {
      if (!mapInstanceRef.current || !window.google) return;
      const map = mapInstanceRef.current;

      // ヒートマップ再描画（スマートヒートマップ対応）
      if (showHeatmap && window.google.maps.visualization) {
        const result = DataService.getSmartHeatmapData(heatmapMode);
        setHeatmapStats(result.stats);
        const points = result.points;
        if (points.length > 0) {
          const heatData = points.map(p => ({
            location: new google.maps.LatLng(p.lat, p.lng),
            weight: p.weight,
          }));
          if (heatmapLayerRef.current) {
            heatmapLayerRef.current.setData(heatData);
          } else {
            const z = map.getZoom() || 13;
            const metersPerPx = 156543.03 * Math.cos((map.getCenter().lat() || 43.77) * Math.PI / 180) / Math.pow(2, z);
            const radius = Math.max(10, Math.round(350 / metersPerPx));
            const grads = {
              timeAware: [
                'rgba(0,0,0,0)', 'rgba(30,100,230,0.15)', 'rgba(30,160,255,0.35)', 'rgba(0,200,150,0.5)',
                'rgba(140,230,60,0.65)', 'rgba(255,220,30,0.78)', 'rgba(255,150,0,0.88)', 'rgba(240,60,40,0.95)', 'rgba(180,20,20,1)',
              ],
              all: [
                'rgba(0,0,0,0)', 'rgba(0,100,255,0.15)', 'rgba(0,180,255,0.4)', 'rgba(0,210,120,0.55)',
                'rgba(180,230,50,0.7)', 'rgba(255,220,30,0.8)', 'rgba(255,160,0,0.88)', 'rgba(255,80,20,0.94)', 'rgba(220,30,30,1)',
              ],
            };
            heatmapLayerRef.current = new google.maps.visualization.HeatmapLayer({
              data: heatData, map: map, radius: radius, opacity: 0.85, dissipating: true, maxIntensity: 8,
              gradient: grads[heatmapMode] || grads.all,
            });
          }
        } else if (heatmapLayerRef.current) {
          heatmapLayerRef.current.setData([]);
        }
      }

      // 単価マップ再描画
      if (showPriceTier) {
        priceTierMarkersRef.current.forEach(m => m.setMap(null));
        priceTierMarkersRef.current = [];
        const src = priceTierSource === 'all' ? null : priceTierSource;
        const pts = DataService.getPriceTierHeatmapData(src);
        const tierColors = { short: '#4CAF50', mid: '#FFC107', long: '#F44336' };
        pts.forEach(p => {
          const marker = new google.maps.Marker({
            position: { lat: p.lat, lng: p.lng },
            map: map,
            icon: {
              path: google.maps.SymbolPath.CIRCLE,
              fillColor: tierColors[p.tier],
              fillOpacity: 0.7,
              strokeColor: '#fff',
              strokeWeight: 1,
              scale: p.tier === 'long' ? 10 : p.tier === 'mid' ? 8 : 6,
            },
            title: `¥${p.amount.toLocaleString()} (${p.source}) ${p.area}`,
            zIndex: p.tier === 'long' ? 3 : p.tier === 'mid' ? 2 : 1,
          });
          priceTierMarkersRef.current.push(marker);
        });
        // 周辺推定更新
        const pos = currentPosition || mapCenter;
        if (pos && pos.lat && pos.lng) {
          setNearbyEstimate(DataService.getNearbyEstimate(pos.lat, pos.lng, 2));
        }
      }
    };
    window.addEventListener('taxi-data-changed', handler);
    return () => window.removeEventListener('taxi-data-changed', handler);
  }, [showHeatmap, heatmapMode, showPriceTier, priceTierSource, currentPosition, mapCenter]);

  // 現在位置マーカー更新
  useEffect(() => {
    if (!mapInstanceRef.current || !currentPosition || !window.google) return;
    const map = mapInstanceRef.current;
    const color = _getAccuracyColor(accuracy);

    if (!markerRef.current) {
      _placeMarker(map, currentPosition);
    } else {
      markerRef.current.setPosition(currentPosition);
      // 精度に応じてマーカーの色を更新
      markerRef.current.setIcon({
        path: google.maps.SymbolPath.CIRCLE,
        scale: 10,
        fillColor: color,
        fillOpacity: 1,
        strokeColor: '#ffffff',
        strokeWeight: 3,
      });
      if (accuracyCircleRef.current) {
        accuracyCircleRef.current.setCenter(currentPosition);
        accuracyCircleRef.current.setOptions({
          radius: accuracy || 50,
          fillColor: color,
          strokeColor: color,
          fillOpacity: accuracy && accuracy > 500 ? 0.12 : 0.08,
        });
      }
    }

    // 初回GPS取得時: 中心を移動しズームを精度に応じて設定
    if (!firstGpsDone.current) {
      firstGpsDone.current = true;
      map.setCenter(currentPosition);
      // 精度が低い場合はズームを下げる
      const initZoom = accuracy && accuracy > 1000 ? 13 : accuracy && accuracy > 500 ? 14 : 15;
      map.setZoom(initZoom);
      AppLogger.info(`初回GPS: ${currentPosition.lat.toFixed(6)}, ${currentPosition.lng.toFixed(6)} 精度${Math.round(accuracy || 0)}m → zoom ${initZoom}`);
    } else {
      // 2回目以降はスムーズにパン
      map.panTo(currentPosition);
    }
  }, [currentPosition, accuracy]);

  // ============================================================
  // APIキーなしのデモモード
  // ============================================================
  if (!apiKey) {
    return React.createElement('div', {
      className: `map-container ${fullscreen ? 'map-container--fullscreen' : ''}`,
      style: {
        display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
        background: 'linear-gradient(135deg, var(--bg-medium), var(--bg-light))',
      },
    },
      React.createElement('span', {
        className: 'material-icons-round',
        style: { fontSize: '64px', color: 'var(--color-secondary)', marginBottom: '16px' },
      }, 'map'),
      React.createElement('h3', {
        style: { marginBottom: '8px', color: 'var(--text-primary)' },
      }, 'Google Maps デモモード'),
      React.createElement('p', {
        style: { color: 'var(--text-secondary)', textAlign: 'center', maxWidth: '400px', fontSize: 'var(--font-size-sm)' },
      }, '設定画面からGoogle Maps APIキーを入力すると、実際の地図と交通渋滞情報が表示されます。'),
      React.createElement('div', {
        style: {
          marginTop: '16px', padding: '12px 20px',
          background: 'rgba(255,255,255,0.06)', borderRadius: '8px',
          fontFamily: 'monospace', fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)',
        },
      },
        React.createElement('div', null, `中心: ${mapCenter.lat.toFixed(4)}, ${mapCenter.lng.toFixed(4)}`),
        React.createElement('div', null, `ズーム: ${zoom}`),
        currentPosition && React.createElement('div', {
          style: { color: 'var(--color-accent)', marginTop: '4px' },
        }, `GPS: ${currentPosition.lat.toFixed(6)}, ${currentPosition.lng.toFixed(6)}`)
      ),
      React.createElement(Button, {
        variant: 'primary', icon: 'settings',
        onClick: () => document.dispatchEvent(new CustomEvent('navigate', { detail: 'settings' })),
        style: { marginTop: '16px' },
      }, '設定を開く')
    );
  }

  // ============================================================
  // エラー画面
  // ============================================================
  if (mapError) {
    return React.createElement('div', {
      className: `map-container ${fullscreen ? 'map-container--fullscreen' : ''}`,
      style: { display: 'flex', alignItems: 'center', justifyContent: 'center', flexDirection: 'column', gap: '12px', padding: '24px', overflow: 'auto' },
    },
      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '48px', color: 'var(--color-danger)' } }, 'error'),
      React.createElement('p', { style: { color: 'var(--color-danger)', textAlign: 'center', whiteSpace: 'pre-line', fontSize: 'var(--font-size-sm)', lineHeight: '1.8' } }, mapError),
      React.createElement('div', {
        style: { marginTop: '8px', padding: '8px 14px', background: 'rgba(255,255,255,0.06)', borderRadius: '6px', fontSize: '11px', color: 'var(--text-muted)', wordBreak: 'break-all' },
      },
        React.createElement('div', null, '現在のURL: ' + window.location.origin),
        errorDetail && React.createElement('div', { style: { marginTop: '4px', color: 'var(--color-secondary)' } }, 'Error: ' + errorDetail)
      ),
      React.createElement('div', { style: { display: 'flex', gap: '8px', marginTop: '8px' } },
        React.createElement(Button, {
          variant: 'primary', icon: 'refresh',
          onClick: () => { window._gmapLoader.reset(); _gmapErrorType = ''; setErrorDetail(null); setMapError(null); setMapLoaded(false); },
        }, '再試行'),
        React.createElement(Button, {
          variant: 'secondary', icon: 'settings',
          onClick: () => document.dispatchEvent(new CustomEvent('navigate', { detail: 'settings' })),
        }, '設定を確認')
      )
    );
  }

  // ============================================================
  // メイン地図表示
  // ============================================================
  return React.createElement('div', null,
    // 地図コンテナ
    React.createElement('div', {
      ref: mapRef,
      className: `map-container ${fullscreen ? 'map-container--fullscreen' : ''}`,
      style: { minHeight: '450px', position: 'relative' },
    },
      !mapLoaded && React.createElement(Loading, { message: '地図を読み込み中...' }),
      // 精度低下警告オーバーレイ（地図上に表示）
      mapLoaded && accuracy && accuracy > 1000 && React.createElement('div', {
        style: {
          position: 'absolute', top: '8px', left: '50%', transform: 'translateX(-50%)',
          zIndex: 5, background: 'rgba(229,57,53,0.9)', color: '#fff',
          padding: '6px 14px', borderRadius: '20px', fontSize: '11px', fontWeight: '700',
          display: 'flex', alignItems: 'center', gap: '4px', whiteSpace: 'nowrap',
          boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
        },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'gps_off'),
        `位置精度: 約${Math.round(accuracy / 100) / 10}km（低精度）`
      )
    ),

    // マップ操作パネル（マップの外・下に表示）
    mapLoaded && React.createElement('div', {
      style: {
        marginTop: 'var(--space-md)',
        background: 'rgba(26, 26, 46, 0.95)',
        borderRadius: 'var(--border-radius-sm)',
        padding: 'var(--space-md)',
        border: '1px solid rgba(255,255,255,0.1)',
      },
    },
      // ボタン行
      React.createElement('div', {
        style: {
          display: 'flex', flexWrap: 'wrap', gap: '8px', alignItems: 'center',
        },
      },
        // 渋滞情報トグルボタン
        React.createElement('button', {
          onClick: () => setShowTraffic(prev => !prev),
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 14px', borderRadius: '8px',
            fontSize: '12px', fontWeight: '700',
            color: '#fff', cursor: 'pointer',
            border: showTraffic ? 'none' : '1px solid rgba(255,255,255,0.2)',
            background: showTraffic ? '#ef4444' : 'rgba(255,255,255,0.08)',
            transition: 'all 0.2s ease',
          },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'traffic'),
          `渋滞情報 ${showTraffic ? 'ON' : 'OFF'}`
        ),

        // 現在地に移動ボタン
        currentPosition && React.createElement('button', {
          onClick: () => {
            if (mapInstanceRef.current && currentPosition) {
              mapInstanceRef.current.setCenter(currentPosition);
              mapInstanceRef.current.setZoom(15);
            }
          },
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 14px', borderRadius: '8px',
            fontSize: '12px', fontWeight: '700',
            color: '#fff', cursor: 'pointer',
            border: '1px solid rgba(255,255,255,0.2)',
            background: 'rgba(255,255,255,0.08)',
            transition: 'all 0.2s ease',
          },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'my_location'),
          '現在地'
        ),

        // Google Mapsで開く
        React.createElement('a', {
          href: `https://www.google.com/maps/@${mapCenter.lat},${mapCenter.lng},${zoom}z/data=!5m1!1e1`,
          target: '_blank', rel: 'noreferrer',
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 14px', borderRadius: '8px',
            fontSize: '12px', fontWeight: '700', textDecoration: 'none',
            color: '#fff', border: '1px solid rgba(255,255,255,0.2)',
            background: 'rgba(255,255,255,0.08)',
          },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'open_in_new'),
          'Google Mapsで開く'
        ),

        // 需要ヒートマップトグル
        React.createElement('button', {
          onClick: () => {
            if (!showHeatmap) {
              const pts = DataService.getHeatmapData();
              if (pts.length === 0) {
                AppLogger.warn('GPS付き乗車データを記録するとヒートマップが表示されます');
                return;
              }
            }
            setShowHeatmap(prev => !prev);
          },
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 14px', borderRadius: '8px',
            fontSize: '12px', fontWeight: '700',
            color: '#fff', cursor: 'pointer',
            border: showHeatmap ? 'none' : '1px solid rgba(255,255,255,0.2)',
            background: showHeatmap ? '#f59e0b' : 'rgba(255,255,255,0.08)',
            transition: 'all 0.2s ease',
          },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'whatshot'),
          `ヒートマップ ${showHeatmap ? 'ON' : 'OFF'}`
        ),

        // ヒートマップモード切替タブ（ヒートマップON時のみ）
        showHeatmap && React.createElement('div', {
          style: {
            display: 'flex', gap: '3px', background: 'rgba(0,0,0,0.3)', borderRadius: '8px', padding: '3px',
          },
        },
          ...[
            { id: 'timeAware', label: '時間帯', icon: 'schedule', color: '#2196F3' },
            { id: 'all', label: '全件', icon: 'public', color: '#78909C' },
            { id: 'transit', label: '交通', icon: 'directions_transit', color: '#ec4899' },
            { id: 'combined', label: '統合', icon: 'merge_type', color: '#7c3aed' },
          ].map(m => React.createElement('button', {
            key: m.id,
            onClick: () => setHeatmapMode(m.id),
            style: {
              display: 'flex', alignItems: 'center', gap: '3px',
              padding: '5px 8px', borderRadius: '6px',
              fontSize: '11px', fontWeight: heatmapMode === m.id ? 700 : 500,
              color: heatmapMode === m.id ? '#fff' : 'rgba(255,255,255,0.6)',
              cursor: 'pointer', border: 'none',
              background: heatmapMode === m.id ? m.color : 'transparent',
              transition: 'all 0.2s ease',
            },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, m.icon),
            m.label
          ))
        ),

        // AI需要予測トグル
        React.createElement('button', {
          onClick: () => {
            if (showAiHeatmap) {
              setShowAiHeatmap(false);
            } else {
              aiModelRef.current = null; // 再学習
              setShowAiHeatmap(true);
            }
          },
          disabled: aiTraining,
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 14px', borderRadius: '8px',
            fontSize: '12px', fontWeight: '700',
            color: '#fff', cursor: aiTraining ? 'wait' : 'pointer',
            border: showAiHeatmap ? 'none' : '1px solid rgba(255,255,255,0.2)',
            background: showAiHeatmap ? '#8b5cf6' : 'rgba(255,255,255,0.08)',
            transition: 'all 0.2s ease',
            opacity: aiTraining ? 0.7 : 1,
          },
        },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '16px', animation: aiTraining ? 'spin 1s linear infinite' : 'none' },
          }, aiTraining ? 'sync' : 'psychology'),
          aiTraining ? 'LightGBM 学習中...' : `AI予測 ${showAiHeatmap ? 'ON' : 'OFF'}`
        ),

        // 単価マップトグル
        React.createElement('button', {
          onClick: () => {
            const pts = DataService.getPriceTierHeatmapData(null);
            if (pts.length === 0 && !showPriceTier) {
              AppLogger.warn('GPS付き乗車データを記録すると単価マップが表示されます');
              return;
            }
            setShowPriceTier(prev => !prev);
          },
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 14px', borderRadius: '8px',
            fontSize: '12px', fontWeight: '700',
            color: '#fff', cursor: 'pointer',
            border: showPriceTier ? 'none' : '1px solid rgba(255,255,255,0.2)',
            background: showPriceTier ? '#10b981' : 'rgba(255,255,255,0.08)',
            transition: 'all 0.2s ease',
          },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'paid'),
          `単価マップ ${showPriceTier ? 'ON' : 'OFF'}`
        ),

        // AI単価予測トグル
        React.createElement('button', {
          onClick: () => {
            if (showPricePredict) {
              setShowPricePredict(false);
            } else {
              priceModelRef.current = null;
              setShowPricePredict(true);
            }
          },
          disabled: priceTraining,
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 14px', borderRadius: '8px',
            fontSize: '12px', fontWeight: '700',
            color: '#fff', cursor: priceTraining ? 'wait' : 'pointer',
            border: showPricePredict ? 'none' : '1px solid rgba(255,255,255,0.2)',
            background: showPricePredict ? '#ec4899' : 'rgba(255,255,255,0.08)',
            transition: 'all 0.2s ease',
            opacity: priceTraining ? 0.7 : 1,
          },
        },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '16px', animation: priceTraining ? 'spin 1s linear infinite' : 'none' },
          }, priceTraining ? 'sync' : 'auto_awesome'),
          priceTraining ? '単価学習中...' : `AI単価予測 ${showPricePredict ? 'ON' : 'OFF'}`
        )
      ),

      // ヒートマップ情報パネル
      showHeatmap && heatmapStats && (() => {
        const modeColor = { timeAware: '#2196F3', all: '#FF9800', transit: '#ec4899', combined: '#7c3aed' }[heatmapMode] || '#FF9800';
        const modeDesc = {
          timeAware: '現在時間帯(±2h)・曜日・鮮度で重み付け',
          all: '全期間の乗車データを均等表示',
          transit: 'バス・JR到着 + 病院ピークの需要分布',
          combined: '乗車実績 + 交通需要の統合',
        }[heatmapMode];
        return React.createElement('div', {
          style: {
            marginTop: '8px', padding: '10px 12px', borderRadius: '8px',
            background: `${modeColor}10`, border: `1px solid ${modeColor}40`,
          },
        },
          // 説明行
          React.createElement('div', {
            style: { display: 'flex', alignItems: 'center', gap: '6px', fontSize: '12px', marginBottom: '6px' },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '15px', color: modeColor } }, 'info'),
            React.createElement('span', { style: { color: 'var(--text-secondary)', flex: 1 } }, modeDesc),
            heatmapMode !== 'transit' && React.createElement('span', {
              style: { fontWeight: 700, color: 'var(--text-primary)', fontSize: '12px', whiteSpace: 'nowrap' },
            }, `${heatmapStats.totalRides}件`),
            heatmapMode === 'transit' && React.createElement('span', {
              style: { fontWeight: 700, color: modeColor, fontSize: '12px', whiteSpace: 'nowrap' },
            }, `${heatmapStats.timeFiltered}pt`)
          ),
          // 凡例バー
          React.createElement('div', {
            style: { display: 'flex', alignItems: 'center', gap: '6px', fontSize: '10px', color: 'var(--text-muted)' },
          },
            React.createElement('span', null, '低'),
            React.createElement('div', {
              style: {
                flex: 1, height: 6, borderRadius: 3,
                background: heatmapMode === 'transit'
                  ? 'linear-gradient(to right, rgba(200,50,150,0.2), #ec4899, #b4143c)'
                  : heatmapMode === 'combined'
                  ? 'linear-gradient(to right, rgba(124,58,237,0.2), #7c3aed, #c83028)'
                  : 'linear-gradient(to right, rgba(0,100,255,0.3), #00d278, #ffdc1e, #ffa000, #dc1e1e)',
              },
            }),
            React.createElement('span', null, '高')
          ),
          // 時間帯一致バッジ
          heatmapMode === 'timeAware' && heatmapStats.timeFiltered > 0 && React.createElement('div', {
            style: { marginTop: '5px', fontSize: '11px', display: 'flex', alignItems: 'center', gap: '4px' },
          },
            React.createElement('span', {
              style: { padding: '1px 8px', borderRadius: '10px', background: `${modeColor}30`, fontWeight: 600, color: modeColor },
            }, `${heatmapStats.timeFiltered}件が時間帯一致`)
          ),
          // ヒント
          heatmapMode !== 'transit' && heatmapStats.totalRides < 10 && React.createElement('div', {
            style: { marginTop: '5px', fontSize: '11px', color: '#FF9800', display: 'flex', alignItems: 'center', gap: '4px' },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '13px' } }, 'tips_and_updates'),
            'データが増えるほど精度が向上します'
          ),
          heatmapMode === 'transit' && heatmapStats.timeFiltered === 0 && React.createElement('div', {
            style: { marginTop: '5px', fontSize: '11px', color: '#ec4899', display: 'flex', alignItems: 'center', gap: '4px' },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '13px' } }, 'tips_and_updates'),
            '「営業プラン取得」で交通需要が表示されます'
          )
        );
      })(),

      // 時間帯シミュレーション スライダー
      (showAiHeatmap || showPricePredict) && React.createElement('div', {
        style: {
          marginTop: '8px', padding: '10px 12px', borderRadius: '8px',
          background: 'rgba(236,72,153,0.08)', border: '1px solid rgba(236,72,153,0.25)',
        },
      },
        React.createElement('div', {
          style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '6px' },
        },
          React.createElement('div', {
            style: { display: 'flex', alignItems: 'center', gap: '6px' },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: '#ec4899' } }, 'schedule'),
            React.createElement('span', { style: { fontSize: '12px', fontWeight: 600, color: '#ec4899' } }, '時間帯シミュレーション')
          ),
          React.createElement('button', {
            onClick: () => {
              const next = !simMode;
              setSimMode(next);
              if (!next) {
                setSimHour(new Date().getHours());
              }
            },
            style: {
              padding: '3px 10px', borderRadius: '12px', border: 'none', cursor: 'pointer',
              fontSize: '11px', fontWeight: 600, fontFamily: 'var(--font-family)',
              background: simMode ? '#ec4899' : 'rgba(255,255,255,0.1)',
              color: simMode ? '#fff' : 'var(--text-secondary)',
            },
          }, simMode ? 'シミュレーションON' : 'OFF（現在時刻）')
        ),

        // スライダー
        React.createElement('div', {
          style: { display: 'flex', alignItems: 'center', gap: '8px' },
        },
          React.createElement('span', { style: { fontSize: '11px', color: 'var(--text-muted)', minWidth: '24px' } }, '0時'),
          React.createElement('input', {
            type: 'range', min: 0, max: 23, step: 1,
            value: simHour,
            onChange: (e) => { setSimMode(true); setSimHour(parseInt(e.target.value, 10)); },
            style: { flex: 1, accentColor: '#ec4899' },
          }),
          React.createElement('span', { style: { fontSize: '11px', color: 'var(--text-muted)', minWidth: '30px' } }, '23時')
        ),

        React.createElement('div', {
          style: { textAlign: 'center', marginTop: '4px' },
        },
          React.createElement('span', {
            style: { fontSize: '16px', fontWeight: 700, color: simMode ? '#ec4899' : 'var(--text-secondary)' },
          }, simHour + '時台'),
          !simMode && React.createElement('span', {
            style: { fontSize: '11px', color: 'var(--text-muted)', marginLeft: '8px' },
          }, '（現在時刻）'),
          simMode && React.createElement('span', {
            style: { fontSize: '11px', color: '#ec4899', marginLeft: '8px' },
          }, (() => {
            const diff = simHour - new Date().getHours();
            if (diff === 0) return '（現在）';
            return diff > 0 ? '（' + diff + '時間後）' : '（' + Math.abs(diff) + '時間前）';
          })())
        )
      ),

      // AI予測 情報メッセージ
      showAiHeatmap && !aiTraining && React.createElement('div', {
        style: {
          marginTop: '8px', padding: '8px 12px', borderRadius: '6px',
          background: 'rgba(139,92,246,0.1)', border: '1px solid rgba(139,92,246,0.3)',
          fontSize: 'var(--font-size-xs)', color: '#a78bfa',
          display: 'flex', alignItems: 'center', gap: '6px',
        },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'psychology'),
        (() => {
          const now = new Date();
          const days = ['日', '月', '火', '水', '木', '金', '土'];
          const entries = DataService.getEntries();
          const w = entries.length > 0 ? (entries[0].weather || '未設定') : '未設定';
          const hr = simMode ? simHour : now.getHours();
          return `LightGBM予測: ${days[now.getDay()]}曜 ${hr}時 ${w} の需要分布${simMode ? ' (シミュレーション)' : ''}`;
        })()
      ),

      // ヒートマップ データなしメッセージ
      showHeatmap && DataService.getHeatmapData().length === 0 && React.createElement('div', {
        style: {
          marginTop: '8px', padding: '8px 12px', borderRadius: '6px',
          background: 'rgba(245,158,11,0.1)', border: '1px solid rgba(245,158,11,0.3)',
          fontSize: 'var(--font-size-xs)', color: '#f59e0b',
          display: 'flex', alignItems: 'center', gap: '6px',
        },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'info'),
        'GPS付き乗車データを記録するとヒートマップが表示されます（各地点から半径2km圏の重なりで乗車率を分析）'
      ),

      // AI単価予測 情報メッセージ
      showPricePredict && !priceTraining && React.createElement('div', {
        style: {
          marginTop: '8px', padding: '8px 12px', borderRadius: '6px',
          background: 'rgba(236,72,153,0.1)', border: '1px solid rgba(236,72,153,0.3)',
          fontSize: 'var(--font-size-xs)', color: '#f472b6',
        },
      },
        React.createElement('div', {
          style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '4px' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'auto_awesome'),
          (() => {
            const hr = simMode ? simHour : new Date().getHours();
            const days = ['日', '月', '火', '水', '木', '金', '土'];
            return 'AI単価予測: ' + days[new Date().getDay()] + '曜 ' + hr + '時' + (simMode ? ' (シミュレーション)' : '');
          })()
        ),
        React.createElement('div', {
          style: { display: 'flex', gap: '10px', fontSize: '10px', color: 'var(--text-secondary)' },
        },
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '3px' } },
            React.createElement('span', { style: { width: '8px', height: '8px', borderRadius: '50%', background: '#4CAF50', display: 'inline-block' } }),
            '¥1,000以下'
          ),
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '3px' } },
            React.createElement('span', { style: { width: '10px', height: '10px', borderRadius: '50%', background: '#FFC107', display: 'inline-block' } }),
            '¥1,001〜1,999'
          ),
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '3px' } },
            React.createElement('span', { style: { width: '12px', height: '12px', borderRadius: '50%', background: '#F44336', display: 'inline-block' } }),
            '¥2,000以上'
          )
        )
      ),

      // 単価マップ表示時: 配車方法フィルター + 周辺推定 + 凡例
      showPriceTier && React.createElement('div', {
        style: {
          marginTop: '8px', padding: '10px 12px', borderRadius: '8px',
          background: 'rgba(16,185,129,0.08)', border: '1px solid rgba(16,185,129,0.25)',
        },
      },
        // 配車方法フィルター
        React.createElement('div', {
          style: { display: 'flex', gap: '4px', flexWrap: 'wrap', marginBottom: '8px' },
        },
          React.createElement('span', {
            style: { fontSize: '11px', fontWeight: 600, color: 'var(--text-secondary)', display: 'flex', alignItems: 'center', marginRight: '4px' },
          }, '配車方法:'),
          ...['all', 'Go', 'Uber', 'DIDI', '電話', '流し'].map(s =>
            React.createElement('button', {
              key: s,
              onClick: () => setPriceTierSource(s),
              style: {
                padding: '3px 10px', borderRadius: '12px', border: 'none', cursor: 'pointer',
                fontSize: '11px', fontWeight: 600, fontFamily: 'var(--font-family)',
                background: priceTierSource === s ? '#10b981' : 'rgba(255,255,255,0.1)',
                color: priceTierSource === s ? '#fff' : 'var(--text-secondary)',
                transition: 'all 0.15s ease',
              },
            }, s === 'all' ? '全て' : s)
          )
        ),

        // 周辺推定
        nearbyEstimate && nearbyEstimate.count > 0 && React.createElement('div', {
          style: {
            padding: '8px', borderRadius: '6px', background: 'rgba(0,0,0,0.2)',
            marginBottom: '8px',
          },
        },
          React.createElement('div', {
            style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '6px' },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: '#10b981' } }, 'near_me'),
            React.createElement('span', { style: { fontSize: '12px', fontWeight: 600, color: '#10b981' } }, '現在地周辺（半径2km）')
          ),
          React.createElement('div', {
            style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '6px', fontSize: '11px' },
          },
            React.createElement('div', null,
              React.createElement('span', { style: { color: 'var(--text-muted)' } }, '推定客単価 '),
              React.createElement('span', { style: { fontWeight: 700, color: '#fff', fontSize: '14px' } }, '¥' + nearbyEstimate.avgPrice.toLocaleString())
            ),
            React.createElement('div', null,
              React.createElement('span', { style: { color: 'var(--text-muted)' } }, '過去データ '),
              React.createElement('span', { style: { fontWeight: 600, color: '#fff' } }, nearbyEstimate.count + '件')
            ),
            React.createElement('div', null,
              React.createElement('span', { style: { color: 'var(--text-muted)' } }, '単価構成 '),
              React.createElement('span', { style: { color: '#4CAF50' } }, '短' + nearbyEstimate.tierCounts.short),
              ' ',
              React.createElement('span', { style: { color: '#FFC107' } }, '中' + nearbyEstimate.tierCounts.mid),
              ' ',
              React.createElement('span', { style: { color: '#F44336' } }, '長' + nearbyEstimate.tierCounts.long)
            ),
            nearbyEstimate.topArea && React.createElement('div', null,
              React.createElement('span', { style: { color: 'var(--text-muted)' } }, '最多エリア '),
              React.createElement('span', { style: { fontWeight: 600, color: '#fff' } }, nearbyEstimate.topArea)
            )
          ),
          // 配車方法内訳
          Object.keys(nearbyEstimate.sources).length > 0 && React.createElement('div', {
            style: { marginTop: '6px', display: 'flex', gap: '6px', flexWrap: 'wrap' },
          },
            ...Object.entries(nearbyEstimate.sources).sort((a, b) => b[1] - a[1]).map(([src, cnt]) =>
              React.createElement('span', {
                key: src,
                style: { fontSize: '10px', padding: '2px 6px', borderRadius: '4px', background: 'rgba(255,255,255,0.1)', color: 'var(--text-secondary)' },
              }, src + ' ' + cnt + '件')
            )
          )
        ),

        // 凡例
        React.createElement('div', {
          style: { display: 'flex', gap: '12px', alignItems: 'center', fontSize: '11px' },
        },
          React.createElement('span', { style: { fontWeight: 600, color: 'var(--text-secondary)' } }, '凡例:'),
          ...[
            { c: '#4CAF50', l: '¥1,000以下', s: 6 },
            { c: '#FFC107', l: '¥1,001〜1,999', s: 8 },
            { c: '#F44336', l: '¥2,000以上', s: 10 },
          ].map(item =>
            React.createElement('span', {
              key: item.l,
              style: { display: 'flex', alignItems: 'center', gap: '3px' },
            },
              React.createElement('span', {
                style: { display: 'inline-block', width: item.s * 2 + 'px', height: item.s * 2 + 'px', borderRadius: '50%', background: item.c, opacity: 0.7 },
              }),
              React.createElement('span', { style: { color: 'var(--text-secondary)' } }, item.l)
            )
          )
        )
      ),

      // 渋滞凡例
      showTraffic && React.createElement('div', {
        style: {
          marginTop: '10px', paddingTop: '10px',
          borderTop: '1px solid rgba(255,255,255,0.08)',
          display: 'flex', flexWrap: 'wrap', gap: '10px', alignItems: 'center',
        },
      },
        React.createElement('span', {
          style: { fontSize: '11px', fontWeight: '600', color: 'var(--text-secondary)' },
        }, '渋滞:'),
        ...[
          { c: '#22c55e', l: 'スムーズ' },
          { c: '#f59e0b', l: 'やや混雑' },
          { c: '#f97316', l: '混雑' },
          { c: '#ef4444', l: '渋滞' },
          { c: '#7f1d1d', l: '大渋滞' },
        ].map(item =>
          React.createElement('span', {
            key: item.l,
            style: { display: 'flex', alignItems: 'center', gap: '3px' },
          },
            React.createElement('span', {
              style: { display: 'inline-block', width: '18px', height: '4px', borderRadius: '2px', background: item.c },
            }),
            React.createElement('span', { style: { fontSize: '10px', color: 'var(--text-secondary)' } }, item.l)
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/components/Map/GpsTracker.jsx
// ============================================================
(function() {
// GpsTracker.jsx - GPS追跡パネル
window.GpsTracker = () => {
  const { currentPosition, isTracking, gpsError, accuracy, speed, heading } = useMapContext();
  const geo = useGeolocation();

  const formatCoord = (val) => val ? val.toFixed(6) : '---';
  const formatAccuracy = (val) => {
    if (!val) return '---';
    const m = Math.round(val);
    if (m <= 100) return `${m}m (高精度)`;
    if (m <= 500) return `${m}m (中精度)`;
    return `${m}m (低精度)`;
  };
  const formatSpeed = (val) => val !== null && val !== undefined ? `${(val * 3.6).toFixed(1)} km/h` : '---';
  const formatHeading = (val) => {
    if (val === null || val === undefined) return '---';
    const dirs = ['北', '北東', '東', '南東', '南', '南西', '西', '北西'];
    return dirs[Math.round(val / 45) % 8] + ` (${Math.round(val)}°)`;
  };

  return React.createElement('div', { className: 'gps-panel' },
    // ステータス行
    React.createElement('div', {
      style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' },
    },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: isTracking ? 'var(--color-accent)' : 'var(--text-muted)' },
        }, isTracking ? 'gps_fixed' : 'gps_not_fixed'),
        React.createElement('span', {
          className: `badge ${isTracking ? 'badge--success' : 'badge--warning'}`,
        }, isTracking ? 'GPS追跡中' : 'GPS停止中')
      ),
      React.createElement('div', { style: { display: 'flex', gap: '4px' } },
        !isTracking && React.createElement(Button, {
          variant: 'primary',
          icon: 'my_location',
          onClick: () => { geo.getCurrentPosition(); },
          style: { padding: '4px 12px', fontSize: '12px' },
        }, '現在地'),
        React.createElement(Button, {
          variant: isTracking ? 'danger' : 'success',
          icon: isTracking ? 'stop' : 'play_arrow',
          onClick: () => isTracking ? geo.stopTracking() : geo.startTracking(),
          style: { padding: '4px 12px', fontSize: '12px' },
        }, isTracking ? '停止' : '追跡開始')
      )
    ),

    // エラー表示
    gpsError && React.createElement('div', {
      style: { color: 'var(--color-danger)', fontSize: 'var(--font-size-xs)', marginBottom: '6px', display: 'flex', alignItems: 'center', gap: '4px' },
    },
      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'warning'),
      gpsError
    ),

    // PC環境での精度警告
    accuracy && accuracy > 500 && React.createElement('div', {
      style: {
        color: accuracy > 1000 ? 'var(--color-danger)' : 'var(--color-warning)',
        fontSize: 'var(--font-size-xs)', marginBottom: '6px',
        display: 'flex', alignItems: 'center', gap: '4px',
        background: accuracy > 1000 ? 'rgba(229,57,53,0.1)' : 'rgba(249,168,37,0.1)',
        padding: '4px 8px', borderRadius: '4px',
      },
    },
      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'info'),
      'PCではGPSがないため位置精度が低くなります。スマートフォンでの利用を推奨します。'
    ),

    // 位置情報
    React.createElement('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px 16px' } },
      React.createElement('div', { className: 'gps-panel__row' },
        React.createElement('span', { className: 'gps-panel__label' }, '緯度'),
        React.createElement('span', { className: 'gps-panel__value' }, formatCoord(currentPosition?.lat))
      ),
      React.createElement('div', { className: 'gps-panel__row' },
        React.createElement('span', { className: 'gps-panel__label' }, '経度'),
        React.createElement('span', { className: 'gps-panel__value' }, formatCoord(currentPosition?.lng))
      ),
      React.createElement('div', { className: 'gps-panel__row' },
        React.createElement('span', { className: 'gps-panel__label' }, '精度'),
        React.createElement('span', {
          className: 'gps-panel__value',
          style: { color: !accuracy ? undefined : accuracy <= 100 ? 'var(--color-accent)' : accuracy <= 500 ? 'var(--color-warning)' : 'var(--color-danger)' },
        }, formatAccuracy(accuracy))
      ),
      React.createElement('div', { className: 'gps-panel__row' },
        React.createElement('span', { className: 'gps-panel__label' }, '速度'),
        React.createElement('span', { className: 'gps-panel__value' }, formatSpeed(speed))
      ),
      React.createElement('div', { className: 'gps-panel__row' },
        React.createElement('span', { className: 'gps-panel__label' }, '方角'),
        React.createElement('span', { className: 'gps-panel__value' }, formatHeading(heading))
      )
    )
  );
};

})();

// ============================================================
// FILE: src/components/Map/MapControls.jsx
// ============================================================
(function() {
// MapControls.jsx - 地図操作コントロール
//
// 地図上に表示する操作ボタン群（渋滞情報トグル、現在地移動、外部マップ起動）

window.MapControls = ({
  showTraffic,
  onToggleTraffic,
  onCenterToPosition,
  currentPosition,
  mapCenter,
  zoom,
}) => {
  const controlBtnBase = {
    display: 'flex',
    alignItems: 'center',
    gap: '6px',
    padding: '8px 14px',
    borderRadius: '8px',
    fontSize: '12px',
    fontWeight: '700',
    color: '#fff',
    cursor: 'pointer',
    border: '1px solid rgba(255,255,255,0.2)',
    background: 'rgba(26,26,46,0.85)',
    boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
    backdropFilter: 'blur(8px)',
    transition: 'all 0.2s ease',
  };

  return React.createElement('div', {
    style: {
      position: 'absolute',
      top: '12px',
      right: '12px',
      display: 'flex',
      flexDirection: 'column',
      gap: '6px',
      zIndex: 5,
    },
  },
    // 渋滞情報トグル
    React.createElement('button', {
      onClick: onToggleTraffic,
      style: {
        ...controlBtnBase,
        border: showTraffic ? 'none' : controlBtnBase.border,
        background: showTraffic ? '#ef4444' : controlBtnBase.background,
      },
    },
      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'traffic'),
      `渋滞情報 ${showTraffic ? 'ON' : 'OFF'}`
    ),

    // 現在地に移動
    currentPosition && React.createElement('button', {
      onClick: onCenterToPosition,
      style: controlBtnBase,
    },
      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'my_location'),
      '現在地'
    ),

    // Google Mapsで開く
    React.createElement('a', {
      href: `https://www.google.com/maps/@${mapCenter.lat},${mapCenter.lng},${zoom}z/data=!5m1!1e1`,
      target: '_blank',
      rel: 'noreferrer',
      style: { ...controlBtnBase, textDecoration: 'none' },
    },
      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'open_in_new'),
      'Google Mapsで開く'
    )
  );
};

// 渋滞凡例コンポーネント
window.TrafficLegend = ({ visible }) => {
  if (!visible) return null;

  const items = [
    { c: '#22c55e', l: 'スムーズ' },
    { c: '#f59e0b', l: 'やや混雑' },
    { c: '#f97316', l: '混雑' },
    { c: '#ef4444', l: '渋滞' },
    { c: '#7f1d1d', l: '大渋滞' },
  ];

  return React.createElement('div', {
    style: {
      position: 'absolute',
      bottom: '12px',
      left: '12px',
      background: 'rgba(255,255,255,0.92)',
      borderRadius: '8px',
      padding: '6px 10px',
      display: 'flex',
      gap: '8px',
      alignItems: 'center',
      boxShadow: '0 1px 4px rgba(0,0,0,0.2)',
      zIndex: 5,
    },
  },
    React.createElement('span', {
      style: { fontSize: '11px', fontWeight: '600', color: '#333' },
    }, '渋滞:'),
    ...items.map(item =>
      React.createElement('span', {
        key: item.l,
        style: { display: 'flex', alignItems: 'center', gap: '3px' },
      },
        React.createElement('span', {
          style: { display: 'inline-block', width: '18px', height: '4px', borderRadius: '2px', background: item.c },
        }),
        React.createElement('span', { style: { fontSize: '10px', color: '#555' } }, item.l)
      )
    )
  );
};

})();

// ============================================================
// FILE: src/components/Layout/Header.jsx
// ============================================================
(function() {
// Header.jsx - ヘッダーナビゲーション
window.Header = () => {
  const { currentPage, navigate, sidebarOpen, setSidebarOpen } = useAppContext();

  return React.createElement('header', { className: 'header' },
    // メニュートグル（モバイル）
    React.createElement('button', {
      className: 'header__menu-toggle',
      onClick: () => setSidebarOpen(!sidebarOpen),
    },
      React.createElement('span', { className: 'material-icons-round' }, sidebarOpen ? 'close' : 'menu')
    ),

    // ロゴ
    React.createElement('div', {
      className: 'header__logo',
      onClick: () => navigate('dashboard'),
    },
      React.createElement('span', { className: 'material-icons-round' }, 'local_taxi'),
      React.createElement('span', null, 'タクシー売上サポート')
    ),

    // ナビゲーション（PC用）
    React.createElement('nav', { className: 'header__nav' },
      APP_CONSTANTS.NAV_ITEMS.map(item =>
        React.createElement('button', {
          key: item.id,
          className: `header__nav-btn ${currentPage === item.id ? 'active' : ''}`,
          onClick: () => navigate(item.id),
        },
          React.createElement('span', { className: 'material-icons-round' }, item.icon),
          React.createElement('span', null, item.label)
        )
      ),
      // 情報セクション セパレーター + 項目
      React.createElement('span', {
        style: { display: 'inline-block', width: '1px', height: '24px', background: 'rgba(255,255,255,0.1)', margin: '0 4px', verticalAlign: 'middle' },
      }),
      APP_CONSTANTS.INFO_NAV_ITEMS.map(item =>
        React.createElement('button', {
          key: item.id,
          className: `header__nav-btn ${currentPage === item.id ? 'active' : ''}`,
          onClick: () => navigate(item.id),
        },
          React.createElement('span', { className: 'material-icons-round' }, item.icon),
          React.createElement('span', null, item.label)
        )
      ),
      // 開発者ツールボタン
      React.createElement('button', {
        className: `header__nav-btn ${currentPage.startsWith('dev') ? 'active' : ''}`,
        onClick: () => navigate('dev'),
        style: { marginLeft: '8px', borderLeft: '1px solid rgba(255,255,255,0.1)', paddingLeft: '16px' },
      },
        React.createElement('span', { className: 'material-icons-round' }, 'code'),
        React.createElement('span', null, '開発者')
      )
    )
  );
};

})();

// ============================================================
// FILE: src/components/Layout/Sidebar.jsx
// ============================================================
(function() {
// Sidebar.jsx - PC用サイドバー
window.Sidebar = () => {
  const { currentPage, navigate, sidebarOpen } = useAppContext();

  const devItems = [
    { id: 'dev', label: '開発者ツール', icon: 'code' },
    { id: 'dev-structure', label: 'サイト構造', icon: 'account_tree' },
    { id: 'dev-logs', label: 'ログビューア', icon: 'terminal' },
    { id: 'dev-api', label: 'API状態', icon: 'cloud' },
  ];

  return React.createElement('aside', {
    className: `sidebar ${sidebarOpen ? 'open' : ''}`,
  },
    // メインナビ
    React.createElement('div', { className: 'sidebar__section' },
      React.createElement('div', { className: 'sidebar__section-title' }, 'メインメニュー'),
      APP_CONSTANTS.NAV_ITEMS.map(item =>
        React.createElement('button', {
          key: item.id,
          className: `sidebar__item ${currentPage === item.id ? 'active' : ''}`,
          onClick: () => navigate(item.id),
        },
          React.createElement('span', { className: 'material-icons-round' }, item.icon),
          item.label
        )
      )
    ),

    // 情報
    React.createElement('div', { className: 'sidebar__section' },
      React.createElement('div', { className: 'sidebar__section-title' }, '情報'),
      APP_CONSTANTS.INFO_NAV_ITEMS.map(item =>
        React.createElement('button', {
          key: item.id,
          className: `sidebar__item ${currentPage === item.id ? 'active' : ''}`,
          onClick: () => navigate(item.id),
        },
          React.createElement('span', { className: 'material-icons-round' }, item.icon),
          item.label
        )
      )
    ),

    // 開発者ツール
    React.createElement('div', { className: 'sidebar__section' },
      React.createElement('div', { className: 'sidebar__section-title' }, '開発者ツール'),
      devItems.map(item =>
        React.createElement('button', {
          key: item.id,
          className: `sidebar__item ${currentPage === item.id ? 'active' : ''}`,
          onClick: () => navigate(item.id),
        },
          React.createElement('span', { className: 'material-icons-round' }, item.icon),
          item.label
        )
      )
    ),

    // バージョン
    React.createElement('div', {
      style: {
        padding: 'var(--space-md)',
        marginTop: 'auto',
        fontSize: 'var(--font-size-xs)',
        color: 'var(--text-muted)',
        textAlign: 'center',
      },
    }, `v${APP_CONSTANTS.VERSION}`)
  );
};

})();

// ============================================================
// FILE: src/components/Layout/BottomNav.jsx
// ============================================================
(function() {
// BottomNav.jsx - モバイル用ボトムナビゲーション
window.BottomNav = () => {
  const { currentPage, navigate } = useAppContext();

  return React.createElement('nav', { className: 'bottom-nav' },
    React.createElement('div', { className: 'bottom-nav__items' },
      APP_CONSTANTS.BOTTOM_NAV_ITEMS.map(item =>
        React.createElement('button', {
          key: item.id,
          className: `bottom-nav__item ${currentPage === item.id ? 'active' : ''}`,
          onClick: () => navigate(item.id),
        },
          React.createElement('span', { className: 'material-icons-round' }, item.icon),
          React.createElement('span', null, item.label)
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/components/Layout/Layout.jsx
// ============================================================
(function() {
// Layout.jsx - レイアウトラッパー
window.Layout = ({ children }) => {
  const { sidebarOpen, setSidebarOpen } = useAppContext();

  return React.createElement(React.Fragment, null,
    React.createElement(Header),
    React.createElement(Sidebar),
    React.createElement('main', { className: 'main-content' }, children),
    React.createElement(BottomNav),

    // オーバーレイ（モバイルサイドバー表示時）
    sidebarOpen && React.createElement('div', {
      style: {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: 'rgba(0,0,0,0.5)',
        zIndex: 800,
      },
      onClick: () => setSidebarOpen(false),
    })
  );
};

})();

// ============================================================
// FILE: src/pages/Dashboard.jsx
// ============================================================
(function() {
// Dashboard.jsx - ダッシュボード（DataServiceからリアルタイムデータ取得）
window.DashboardPage = () => {
  const { useState, useEffect, useMemo, useCallback, useRef } = React;
  const { navigate, geminiApiKey } = useAppContext();
  const { currentPosition, isTracking } = useMapContext();

  // DataServiceからリアルタイムデータを取得
  const [refreshKey, setRefreshKey] = useState(0);

  // localStorageの変更・データ変更イベントを監視して自動更新
  useEffect(() => {
    const handleStorage = (e) => {
      if (e.key === APP_CONSTANTS.STORAGE_KEYS.REVENUE_DATA) {
        setRefreshKey(k => k + 1);
      }
    };
    const handleDataChanged = () => setRefreshKey(k => k + 1);
    window.addEventListener('storage', handleStorage);
    window.addEventListener('taxi-data-changed', handleDataChanged);

    // 画面に戻った時も更新
    const handleVisibility = () => {
      if (!document.hidden) setRefreshKey(k => k + 1);
    };
    document.addEventListener('visibilitychange', handleVisibility);

    return () => {
      window.removeEventListener('storage', handleStorage);
      window.removeEventListener('taxi-data-changed', handleDataChanged);
      document.removeEventListener('visibilitychange', handleVisibility);
    };
  }, []);

  const todaySummary = useMemo(() => DataService.getTodaySummary(), [refreshKey]);
  const overallSummary = useMemo(() => DataService.getOverallSummary(), [refreshKey]);

  const hourlyRate = useMemo(() => {
    if (todaySummary.workMinutes > 0 && todaySummary.rideCount >= 2) {
      return Math.round(todaySummary.totalAmount / (todaySummary.workMinutes / 60));
    }
    return null;
  }, [refreshKey]);

  const utilization = useMemo(() => DataService.getUtilizationRate(), [refreshKey]);
  const goalProgress = useMemo(() => DataService.getGoalProgress(), [refreshKey]);
  const topAreas = useMemo(() => DataService.getTopPickupAreasForNow(), [refreshKey]);
  const eventAlerts = useMemo(() => DataService.getUpcomingEventAlerts(), [refreshKey]);

  // 営業プラン関連
  const dailySchedule = useMemo(() => DataService.getDailyDemandSchedule(), [refreshKey]);
  const [demandPlanLoading, setDemandPlanLoading] = useState(false);
  const demandPlanFetched = useRef(false);
  const demandPlanLoadingRef = useRef(false);

  const handleFetchDemandPlan = useCallback(async () => {
    if (!geminiApiKey || demandPlanLoadingRef.current) return;
    demandPlanLoadingRef.current = true;
    setDemandPlanLoading(true);
    const result = await GeminiService.fetchDailyDemandPlan(geminiApiKey, '旭川');
    if (result.success && result.data) {
      const today = new Date().toISOString().slice(0, 10);
      AppStorage.set(APP_CONSTANTS.STORAGE_KEYS.DAILY_DEMAND_PLAN, { date: today, data: result.data, fetchedAt: new Date().toISOString() });
      window.dispatchEvent(new CustomEvent('taxi-data-changed', { detail: { type: 'demand-plan' } }));
    }
    demandPlanLoadingRef.current = false;
    setDemandPlanLoading(false);
  }, [geminiApiKey]);

  // Gemini APIキーがありプランが未取得なら初回自動fetch
  useEffect(() => {
    if (geminiApiKey && !dailySchedule.available && !demandPlanFetched.current) {
      demandPlanFetched.current = true;
      handleFetchDemandPlan();
    }
  }, [geminiApiKey, dailySchedule.available, handleFetchDemandPlan]);

  const stats = [
    {
      label: '本日の売上（税込）',
      value: `¥${todaySummary.totalAmount.toLocaleString()}`,
      sub: `税抜¥${Math.floor(todaySummary.totalAmount / 1.1).toLocaleString()} 税¥${(todaySummary.totalAmount - Math.floor(todaySummary.totalAmount / 1.1)).toLocaleString()}`,
      icon: 'payments',
      color: 'var(--color-secondary)',
    },
    {
      label: '乗車回数',
      value: `${todaySummary.rideCount}回`,
      icon: 'people',
      color: 'var(--color-primary-light)',
    },
    {
      label: '平均単価',
      value: `¥${todaySummary.avgAmount.toLocaleString()}`,
      icon: 'price_check',
      color: 'var(--color-accent)',
    },
    {
      label: '稼働時間',
      value: todaySummary.workTime,
      icon: 'schedule',
      color: 'var(--color-warning)',
    },
  ];

  const quickActions = [
    { label: '地図を開く', icon: 'map', page: 'map', color: 'var(--color-primary)' },
    { label: '売上を記録', icon: 'add_circle', page: 'revenue', color: 'var(--color-accent)' },
    { label: '分析を見る', icon: 'analytics', page: 'analytics', color: 'var(--color-secondary)' },
    { label: '開発者ツール', icon: 'code', page: 'dev', color: 'var(--color-warning)' },
  ];

  return React.createElement('div', null,
    // タイトル
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'dashboard'),
      'ダッシュボード'
    ),

    // GPS状態
    React.createElement(Card, {
      style: { marginBottom: 'var(--space-md)', padding: 'var(--space-md)' },
    },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '12px' } },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '24px', color: isTracking ? 'var(--color-accent)' : 'var(--text-muted)' },
        }, isTracking ? 'gps_fixed' : 'gps_off'),
        React.createElement('div', null,
          React.createElement('div', { style: { fontWeight: 500, fontSize: 'var(--font-size-sm)' } },
            isTracking ? 'GPS追跡中' : 'GPS未接続'
          ),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } },
            currentPosition
              ? `${currentPosition.lat.toFixed(4)}, ${currentPosition.lng.toFixed(4)}`
              : '地図ページでGPSを有効にしてください'
          )
        )
      )
    ),

    // リアルタイム時給
    hourlyRate !== null && React.createElement(Card, {
      style: {
        marginBottom: 'var(--space-md)', padding: 'var(--space-lg)',
        background: 'linear-gradient(135deg, rgba(249,168,37,0.15), rgba(255,152,0,0.08))',
        border: '1px solid rgba(249,168,37,0.3)',
        textAlign: 'center',
      },
    },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', marginBottom: '4px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '28px', color: 'var(--color-secondary)' } }, 'speed'),
        React.createElement('span', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } }, 'リアルタイム時給')
      ),
      React.createElement('div', {
        style: { fontSize: '2rem', fontWeight: 700, color: 'var(--color-secondary)' },
      }, `¥${hourlyRate.toLocaleString()}/h`)
    ),

    // 本日の統計カード
    React.createElement('div', { className: 'grid grid--4', style: { marginBottom: 'var(--space-lg)' } },
      stats.map((stat, i) =>
        React.createElement(Card, { key: i, className: 'stat-card' },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '32px', color: stat.color, marginBottom: '8px' },
          }, stat.icon),
          React.createElement('div', { className: 'stat-card__value' }, stat.value),
          stat.sub && React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)', marginTop: '2px' } }, stat.sub),
          React.createElement('div', { className: 'stat-card__label' }, stat.label)
        )
      )
    ),

    // 目標ペーストラッカー
    goalProgress && React.createElement(Card, {
      style: {
        marginBottom: 'var(--space-md)', padding: 'var(--space-lg)',
        background: goalProgress.dailyRate >= 100
          ? 'linear-gradient(135deg, rgba(76,175,80,0.15), rgba(76,175,80,0.05))'
          : 'linear-gradient(135deg, rgba(33,150,243,0.15), rgba(33,150,243,0.05))',
        border: goalProgress.dailyRate >= 100
          ? '1px solid rgba(76,175,80,0.3)'
          : '1px solid rgba(33,150,243,0.3)',
      },
    },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '12px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '24px', color: goalProgress.dailyRate >= 100 ? '#4CAF50' : '#2196F3' } },
          goalProgress.dailyRate >= 100 ? 'emoji_events' : 'flag'
        ),
        React.createElement('span', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)' } }, '日額目標進捗')
      ),
      // プログレスバー
      React.createElement('div', { style: { background: 'rgba(255,255,255,0.1)', borderRadius: '8px', height: '12px', overflow: 'hidden', marginBottom: '8px' } },
        React.createElement('div', { style: {
          width: `${Math.min(goalProgress.dailyRate, 100)}%`,
          height: '100%', borderRadius: '8px',
          background: goalProgress.dailyRate >= 100 ? '#4CAF50' : '#2196F3',
          transition: 'width 0.5s ease',
        } })
      ),
      React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between', fontSize: 'var(--font-size-sm)' } },
        React.createElement('span', null, `¥${goalProgress.todayAmount.toLocaleString()} / ¥${goalProgress.dailyGoal.toLocaleString()}`),
        React.createElement('span', { style: { fontWeight: 700, color: goalProgress.dailyRate >= 100 ? '#4CAF50' : '#2196F3' } }, `${goalProgress.dailyRate}%`)
      ),
      // 月間進捗
      goalProgress.monthDays > 0 && React.createElement('div', { style: { marginTop: '12px', paddingTop: '12px', borderTop: '1px solid rgba(255,255,255,0.08)', fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } },
        `今月: ¥${goalProgress.monthAmount.toLocaleString()} / ¥${goalProgress.monthlyGoal.toLocaleString()} (${goalProgress.monthlyRate}%) — ${goalProgress.monthDays}日稼働`
      )
    ),

    // 実車率トラッキング
    utilization.rideCount >= 2 && React.createElement(Card, {
      style: { marginBottom: 'var(--space-md)', padding: 'var(--space-lg)' },
    },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '12px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '24px', color: 'var(--color-accent)' } }, 'local_taxi'),
        React.createElement('span', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)' } }, '実車率')
      ),
      React.createElement('div', { style: { display: 'flex', alignItems: 'baseline', gap: '8px', marginBottom: '8px' } },
        React.createElement('span', { style: { fontSize: '2rem', fontWeight: 700, color: 'var(--color-accent)' } }, `${utilization.rate}%`),
        React.createElement('span', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } },
          `実車${utilization.occupiedMin}分 / 空車${utilization.vacantMin}分`
        )
      ),
      React.createElement('div', { style: { background: 'rgba(255,255,255,0.1)', borderRadius: '8px', height: '8px', overflow: 'hidden' } },
        React.createElement('div', { style: {
          width: `${utilization.rate}%`, height: '100%', borderRadius: '8px',
          background: utilization.rate >= 50 ? 'var(--color-accent)' : 'var(--color-warning)',
          transition: 'width 0.5s ease',
        } })
      )
    ),

    // 単価最適化アドバイザー
    topAreas.length > 0 && React.createElement(Card, {
      style: { marginBottom: 'var(--space-md)', padding: 'var(--space-lg)' },
    },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '12px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '24px', color: '#FF9800' } }, 'trending_up'),
        React.createElement('span', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)' } }, 'この時間帯の高単価エリア')
      ),
      topAreas.map((area, i) =>
        React.createElement('div', {
          key: area.name,
          style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '8px 0',
            borderBottom: i < topAreas.length - 1 ? '1px solid rgba(255,255,255,0.06)' : 'none' },
        },
          React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
            React.createElement('span', { style: { fontWeight: 700, fontSize: 'var(--font-size-lg)', color: i === 0 ? '#FFD700' : i === 1 ? '#C0C0C0' : '#CD7F32', width: '24px' } }, `${i + 1}`),
            React.createElement('div', null,
              React.createElement('div', { style: { fontWeight: 500, fontSize: 'var(--font-size-sm)' } }, area.name),
              React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, `${area.count}回の実績`)
            )
          ),
          React.createElement('div', { style: { fontWeight: 700, color: 'var(--color-secondary)' } }, `¥${area.avg.toLocaleString()}`)
        )
      )
    ),

    // イベント需要アラート
    eventAlerts.length > 0 && React.createElement(Card, {
      style: {
        marginBottom: 'var(--space-md)', padding: 'var(--space-lg)',
        background: 'linear-gradient(135deg, rgba(255,152,0,0.15), rgba(255,87,34,0.08))',
        border: '1px solid rgba(255,152,0,0.3)',
      },
    },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '12px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '24px', color: '#FF9800' } }, 'event_available'),
        React.createElement('span', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)' } }, 'イベント終了間近')
      ),
      eventAlerts.map(alert =>
        React.createElement('div', {
          key: alert.name,
          style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '8px 0' },
        },
          React.createElement('div', null,
            React.createElement('div', { style: { fontWeight: 500, fontSize: 'var(--font-size-sm)' } }, alert.name),
            alert.location && React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, alert.location)
          ),
          React.createElement('div', { style: { textAlign: 'right' } },
            React.createElement('div', { style: { fontWeight: 700, color: '#FF9800' } }, `あと${alert.minutesLeft}分`),
            React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, `〜${alert.endTime}`)
          )
        )
      )
    ),

    // 本日の営業プラン
    React.createElement(Card, {
      style: {
        marginBottom: 'var(--space-md)', padding: 'var(--space-lg)',
        background: 'linear-gradient(135deg, rgba(124,58,237,0.12), rgba(236,72,153,0.06))',
        border: '1px solid rgba(124,58,237,0.25)',
      },
    },
      // ヘッダー
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '12px' } },
        React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '24px', color: '#7c3aed' } }, 'route'),
          React.createElement('span', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)' } }, '本日の営業プラン'),
          React.createElement('span', {
            style: {
              fontSize: '10px', fontWeight: 600, padding: '2px 6px', borderRadius: '4px',
              background: new Date().getDate() % 2 === 0 ? 'rgba(34,197,94,0.15)' : 'rgba(239,68,68,0.15)',
              color: new Date().getDate() % 2 === 0 ? '#22c55e' : '#ef4444',
            },
          }, new Date().getDate() % 2 === 0 ? '駅前待機OK' : '駅前待機不可')
        ),
        React.createElement('button', {
          onClick: handleFetchDemandPlan,
          disabled: demandPlanLoading || !geminiApiKey,
          style: {
            display: 'flex', alignItems: 'center', gap: '4px',
            padding: '4px 10px', borderRadius: '6px', border: 'none',
            background: 'rgba(124,58,237,0.2)', color: '#a78bfa', cursor: geminiApiKey ? 'pointer' : 'not-allowed',
            fontSize: '11px', fontWeight: 600, fontFamily: 'var(--font-family)',
            opacity: demandPlanLoading ? 0.6 : 1,
          },
        },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '14px', animation: demandPlanLoading ? 'spin 1s linear infinite' : 'none' },
          }, demandPlanLoading ? 'sync' : 'refresh'),
          demandPlanLoading ? '取得中...' : '更新'
        )
      ),

      // APIキー未設定時
      !geminiApiKey && React.createElement('div', {
        style: { padding: '12px', borderRadius: '8px', background: 'rgba(255,255,255,0.05)', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', textAlign: 'center' },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '20px', display: 'block', marginBottom: '4px' } }, 'vpn_key'),
        'Gemini APIキーを設定すると、JR特急・バスの到着時刻と病院外来ピークに基づく営業プランが表示されます。',
        React.createElement('div', {
          onClick: () => navigate('settings'),
          style: { color: '#7c3aed', cursor: 'pointer', marginTop: '4px', fontWeight: 600 },
        }, '設定ページへ →')
      ),

      // タイムラインブロック
      geminiApiKey && dailySchedule.available && dailySchedule.dailyPlan.length > 0 && React.createElement('div', {
        style: { marginBottom: '12px' },
      },
        dailySchedule.dailyPlan.map((block, i) => {
          const now = new Date();
          const nowStr = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
          const isCurrent = nowStr >= (block.startTime || '') && nowStr < (block.endTime || '24:00');
          const levelColor = block.demandLevel === 'high' ? '#ef4444' : block.demandLevel === 'medium' ? '#f59e0b' : '#3b82f6';
          return React.createElement('div', {
            key: i,
            style: {
              display: 'flex', gap: '10px', padding: '8px',
              borderRadius: '6px', marginBottom: '4px',
              background: isCurrent ? 'rgba(124,58,237,0.15)' : 'transparent',
              border: isCurrent ? '1px solid rgba(124,58,237,0.4)' : '1px solid transparent',
            },
          },
            React.createElement('div', {
              style: {
                minWidth: '70px', padding: '2px 6px', borderRadius: '4px',
                background: `${levelColor}20`, color: levelColor,
                fontSize: '11px', fontWeight: 700, textAlign: 'center',
                borderLeft: `3px solid ${levelColor}`,
              },
            },
              `${block.startTime || ''}`,
              React.createElement('br'),
              `〜${block.endTime || ''}`
            ),
            React.createElement('div', { style: { flex: 1 } },
              React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', fontWeight: 600, color: 'var(--text-primary)' } }, block.location || ''),
              React.createElement('div', { style: { fontSize: '11px', color: 'var(--text-muted)' } }, block.action || '')
            ),
            isCurrent && React.createElement('span', {
              style: { fontSize: '10px', padding: '2px 6px', borderRadius: '8px', background: '#7c3aed', color: '#fff', alignSelf: 'center', fontWeight: 700 },
            }, 'NOW')
          );
        })
      ),

      // 次の到着便（今後3便）
      geminiApiKey && dailySchedule.available && dailySchedule.transitArrivals.length > 0 && (() => {
        const now = new Date();
        const nowMin = now.getHours() * 60 + now.getMinutes();
        const upcoming = dailySchedule.transitArrivals
          .filter(a => {
            if (!a.arrivalTime) return false;
            const p = a.arrivalTime.split(':');
            return parseInt(p[0], 10) * 60 + parseInt(p[1], 10) > nowMin;
          })
          .slice(0, 3);
        if (upcoming.length === 0) return null;
        return React.createElement('div', {
          style: { padding: '8px', borderRadius: '6px', background: 'rgba(255,255,255,0.04)' },
        },
          React.createElement('div', {
            style: { fontSize: '11px', fontWeight: 600, color: 'var(--text-secondary)', marginBottom: '6px', display: 'flex', alignItems: 'center', gap: '4px' },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'directions_transit'),
            '次の到着便'
          ),
          upcoming.map((arr, i) => {
            const p = arr.arrivalTime.split(':');
            const arrMin = parseInt(p[0], 10) * 60 + parseInt(p[1], 10);
            const diff = arrMin - nowMin;
            return React.createElement('div', {
              key: i,
              style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '4px 0', fontSize: '12px' },
            },
              React.createElement('div', null,
                React.createElement('span', { style: { fontWeight: 600 } }, `${arr.type || ''} ${arr.line || ''}`),
                React.createElement('span', { style: { color: 'var(--text-muted)', marginLeft: '6px' } }, `(${arr.origin || ''})`)
              ),
              React.createElement('div', { style: { textAlign: 'right' } },
                React.createElement('span', { style: { fontWeight: 700, color: '#7c3aed' } }, arr.arrivalTime),
                React.createElement('span', { style: { fontSize: '10px', color: diff <= 15 ? '#ef4444' : '#f59e0b', marginLeft: '6px', fontWeight: 600 } }, `あと${diff}分`)
              )
            );
          })
        );
      })(),

      // ホテル需要セクション（APIキー不要・静的データ）
      dailySchedule.available && (dailySchedule.hotelWindows || []).length > 0 && React.createElement('div', {
        style: { padding: '8px', borderRadius: '6px', background: 'rgba(255,255,255,0.04)', marginTop: '8px' },
      },
        React.createElement('div', {
          style: { fontSize: '11px', fontWeight: 600, color: 'var(--text-secondary)', marginBottom: '6px', display: 'flex', alignItems: 'center', gap: '4px' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'hotel'),
          'ホテル需要'
        ),
        (dailySchedule.hotelWindows || []).map((hw, i) => {
          const levelColors = { very_high: '#ef4444', high: '#f59e0b', medium: '#3b82f6', low: '#6b7280' };
          return React.createElement('div', { key: i, style: { marginBottom: '6px' } },
            React.createElement('div', {
              style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '4px' },
            },
              React.createElement('span', {
                style: {
                  fontSize: '10px', fontWeight: 700, padding: '2px 6px', borderRadius: '4px',
                  background: hw.isCurrent ? 'rgba(239,68,68,0.15)' : 'rgba(245,158,11,0.15)',
                  color: hw.isCurrent ? '#ef4444' : '#f59e0b',
                },
              }, hw.isCurrent ? 'NOW' : 'SOON'),
              React.createElement('span', { style: { fontSize: '12px', fontWeight: 600 } },
                `${hw.start}〜${hw.end} ${hw.label}`
              )
            ),
            React.createElement('div', { style: { display: 'flex', flexWrap: 'wrap', gap: '4px' } },
              hw.hotels.slice(0, 5).map((h, j) =>
                React.createElement('span', {
                  key: j,
                  style: {
                    fontSize: '10px', padding: '2px 6px', borderRadius: '4px',
                    background: `${levelColors[h.demandLevel] || '#6b7280'}18`,
                    color: levelColors[h.demandLevel] || '#6b7280',
                    fontWeight: 600, whiteSpace: 'nowrap',
                  },
                }, `${h.name}(${h.rooms}室)`)
              )
            )
          );
        })
      ),

      // ローディング中
      geminiApiKey && demandPlanLoading && !dailySchedule.available && React.createElement('div', {
        style: { textAlign: 'center', padding: '16px', color: 'var(--text-muted)', fontSize: 'var(--font-size-xs)' },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '24px', animation: 'spin 1s linear infinite', display: 'block', marginBottom: '4px' } }, 'sync'),
        'Gemini AIから需要予測データを取得中...'
      )
    ),

    // 累計情報
    overallSummary.rideCount > 0 && React.createElement(Card, {
      style: { marginBottom: 'var(--space-lg)', padding: 'var(--space-md)' },
    },
      React.createElement('div', { style: { fontWeight: 500, fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' } },
        '累計実績'
      ),
      React.createElement('div', { style: { display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '12px', textAlign: 'center' } },
        React.createElement('div', null,
          React.createElement('div', { style: { fontSize: 'var(--font-size-lg)', fontWeight: 700, color: 'var(--color-secondary)' } },
            `¥${overallSummary.totalAmount.toLocaleString()}`
          ),
          React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(overallSummary.totalAmount / 1.1).toLocaleString()}`),
          React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税¥${(overallSummary.totalAmount - Math.floor(overallSummary.totalAmount / 1.1)).toLocaleString()}`),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, '累計売上（税込）')
        ),
        React.createElement('div', null,
          React.createElement('div', { style: { fontSize: 'var(--font-size-lg)', fontWeight: 700 } },
            `${overallSummary.rideCount}回`
          ),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, '累計乗車')
        ),
        React.createElement('div', null,
          React.createElement('div', { style: { fontSize: 'var(--font-size-lg)', fontWeight: 700 } },
            `¥${overallSummary.dailyAvg.toLocaleString()}`
          ),
          React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(overallSummary.dailyAvg / 1.1).toLocaleString()}`),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, '日平均売上（税込）')
        ),
        React.createElement('div', null,
          React.createElement('div', { style: { fontSize: 'var(--font-size-lg)', fontWeight: 700 } },
            `${overallSummary.activeDays}日`
          ),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, '稼働日数')
        )
      )
    ),

    // 最近の売上（本日分）
    todaySummary.entries.length > 0 && React.createElement(Card, {
      title: `本日の記録（${todaySummary.entries.length}件）`,
      style: { marginBottom: 'var(--space-lg)' },
    },
      todaySummary.entries.slice(0, 5).map(entry =>
        React.createElement('div', {
          key: entry.id,
          style: {
            display: 'flex', justifyContent: 'space-between', alignItems: 'center',
            padding: '8px 0', borderBottom: '1px solid rgba(255,255,255,0.06)',
          },
        },
          React.createElement('div', null,
            React.createElement('div', { style: { fontSize: 'var(--font-size-sm)' } },
              `${entry.pickup || '---'} → ${entry.dropoff || '---'}`
            ),
            React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } },
              new Date(entry.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })
            )
          ),
          React.createElement('div', { style: { textAlign: 'right' } },
            entry.noPassenger
              ? React.createElement('div', { style: { fontWeight: 700, color: '#d32f2f' } }, '¥0（待機）')
              : React.createElement('div', { style: { fontWeight: 700, color: 'var(--color-secondary)' } }, `¥${entry.amount.toLocaleString()}`),
            !entry.noPassenger && React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(entry.amount / 1.1).toLocaleString()} 税¥${(entry.amount - Math.floor(entry.amount / 1.1)).toLocaleString()}`)
          )
        )
      ),
      todaySummary.entries.length > 5 && React.createElement(Button, {
        variant: 'secondary', icon: 'arrow_forward',
        onClick: () => navigate('revenue'),
        style: { marginTop: 'var(--space-sm)', width: '100%' },
      }, 'すべての記録を見る')
    ),

    // クイックアクション
    React.createElement('h2', {
      style: { fontSize: 'var(--font-size-lg)', marginBottom: 'var(--space-md)', fontWeight: 500 },
    }, 'クイックアクション'),

    React.createElement('div', { className: 'grid grid--4' },
      quickActions.map((action, i) =>
        React.createElement(Card, {
          key: i,
          onClick: () => navigate(action.page),
          style: { textAlign: 'center', cursor: 'pointer', padding: 'var(--space-lg)' },
        },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '36px', color: action.color, marginBottom: '8px' },
          }, action.icon),
          React.createElement('div', { style: { fontWeight: 500, fontSize: 'var(--font-size-sm)' } }, action.label)
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/MapView.jsx
// ============================================================
(function() {
// MapView.jsx - 地図ページ
window.MapViewPage = () => {
  const { useState } = React;
  const [isFullscreen, setIsFullscreen] = useState(false);

  return React.createElement('div', null,
    !isFullscreen && React.createElement('div', {
      style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 'var(--space-md)' },
    },
      React.createElement('h1', { className: 'page-title', style: { marginBottom: 0 } },
        React.createElement('span', { className: 'material-icons-round' }, 'map'),
        '地図'
      ),
      React.createElement(Button, {
        variant: 'secondary',
        icon: 'fullscreen',
        onClick: () => setIsFullscreen(true),
      }, '全画面')
    ),

    // 地図コンテナ
    React.createElement('div', { style: { position: 'relative' } },
      React.createElement(GoogleMapView, { fullscreen: isFullscreen }),

      // 全画面時の閉じるボタン
      isFullscreen && React.createElement(Button, {
        variant: 'secondary',
        icon: 'fullscreen_exit',
        onClick: () => setIsFullscreen(false),
        style: {
          position: 'absolute',
          top: '12px',
          right: '12px',
          zIndex: 10,
          background: 'rgba(26,26,46,0.9)',
        },
      }, '閉じる')
    ),

    // GPS追跡パネル（マップの外側・下に表示）
    React.createElement(GpsTracker)
  );
};

})();

// ============================================================
// FILE: src/pages/Revenue.jsx
// ============================================================
(function() {
// Revenue.jsx - 売上記録ページ（DataService統合・バリデーション・CSVエクスポート）
// v0.3.2: DataServiceのCRUDメソッドに一元化。ローカルstate独自管理を廃止し、
//         DataServiceを唯一のデータソースとして使用する。
// v0.3.4: 乗車地・降車地のGPS現在地取得機能を追加
// v0.3.5: 日付・天候フィールドを追加
// v0.3.6: 乗車時間・降車時間フィールドを追加
// v0.3.7: 日付・曜日・天候の自動取得
window.RevenuePage = () => {
  const { useState, useEffect, useCallback, useRef, useMemo } = React;

  // 本日の日付をデフォルト値に
  const todayDefault = getLocalDateString();

  const getNowTime = TaxiApp.utils.getNowTime;

  // WMO天気コードを天候カテゴリに変換
  const wmoToWeather = (code) => {
    if (code === undefined || code === null) return '';
    // 0-1: 晴れ, 2-3: 曇り, 45-67: 雨系, 71-77,85-86: 雪系
    if (code <= 1) return '晴れ';
    if (code <= 3 || code === 45 || code === 48) return '曇り';
    if ((code >= 51 && code <= 67) || (code >= 80 && code <= 82) || code === 95 || code === 96 || code === 99) return '雨';
    if ((code >= 71 && code <= 77) || code === 85 || code === 86) return '雪';
    return '曇り'; // デフォルト
  };

  // DataServiceから最新データを取得するためのrefreshKey
  const [refreshKey, setRefreshKey] = useState(0);
  const [form, setForm] = useState({ date: todayDefault, weather: '', amount: '', paymentMethod: 'cash', discountAmount: '', discountType: '', pickup: '', pickupTime: '', dropoff: '', dropoffTime: '', passengers: '1', gender: '', purpose: '', memo: '', source: '' });
  const [errors, setErrors] = useState([]);
  const [saved, setSaved] = useState(false);
  const [gpsLoading, setGpsLoading] = useState({ pickup: false, dropoff: false });
  const [gpsInfo, setGpsInfo] = useState({ pickup: null, dropoff: null });
  const [mapPickerField, setMapPickerField] = useState(null); // 'pickup' | 'dropoff' | null
  const mapPickerRef = useRef(null);
  const mapPickerInstanceRef = useRef(null);
  const mapPickerMarkerRef = useRef(null);
  const [weatherLoading, setWeatherLoading] = useState(false);
  const weatherFetched = useRef(false);
  const [shiftInfo, setShiftInfo] = useState({ active: false, startTime: null });
  const [receiptLoading, setReceiptLoading] = useState(false);

  const { apiKey, geminiApiKey } = useAppContext();

  // 始業シフト状態をlocalStorageから復元
  useEffect(() => {
    const shifts = JSON.parse(localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.SHIFTS) || '[]');
    const activeShift = shifts.find(s => !s.endTime);
    if (activeShift) {
      setShiftInfo({ active: true, startTime: activeShift.startTime });
    }
  }, []);

  // 始業ボタン処理
  const handleShiftStart = useCallback(() => {
    const now = new Date();
    const shifts = JSON.parse(localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.SHIFTS) || '[]');
    const activeShift = shifts.find(s => !s.endTime);

    if (activeShift) {
      if (!confirm('現在のシフトを終了して新しいシフトを開始しますか？')) return;
      // 前回シフトの終業時間 = 直前の売上記録の時刻
      const allEntries = DataService.getEntries();
      if (allEntries.length > 0) {
        const lastEntry = allEntries[0]; // 最新のエントリ（unshiftで追加されるため先頭）
        activeShift.endTime = lastEntry.dropoffTime
          ? `${lastEntry.date || lastEntry.timestamp.split('T')[0]}T${lastEntry.dropoffTime}`
          : lastEntry.timestamp;
      } else {
        activeShift.endTime = now.toISOString();
      }
    }

    const newShift = {
      id: Date.now().toString(),
      startTime: now.toISOString(),
      endTime: null,
    };
    shifts.push(newShift);
    localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.SHIFTS, JSON.stringify(shifts));
    setShiftInfo({ active: true, startTime: now.toISOString() });
    AppLogger.info(`始業記録: ${now.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })}`);
  }, []);

  // ページ読み込み時に天気を自動取得
  useEffect(() => {
    if (weatherFetched.current) return;
    weatherFetched.current = true;

    const fetchWeather = () => {
      if (!navigator.geolocation) {
        AppLogger.warn('天気自動取得: GPS利用不可');
        return;
      }
      setWeatherLoading(true);
      getAccuratePosition({ accuracyThreshold: 500, timeout: 10000, maxWaitAfterFix: 3000 })
        .then((position) => {
          const lat = position.coords.latitude.toFixed(4);
          const lng = position.coords.longitude.toFixed(4);
          const meteoParams = new URLSearchParams({ latitude: lat, longitude: lng, current_weather: 'true', timezone: 'Asia/Tokyo' });
          const url = `https://api.open-meteo.com/v1/forecast?${meteoParams}`;
          return fetch(url).then(res => res.json());
        })
        .then(data => {
          setWeatherLoading(false);
          if (data && data.current_weather) {
            const w = wmoToWeather(data.current_weather.weathercode);
            if (w) {
              setForm(prev => prev.weather ? prev : { ...prev, weather: w });
              AppLogger.info(`天気自動取得成功: ${w} (WMO code: ${data.current_weather.weathercode})`);
            }
          }
        })
        .catch(err => {
          setWeatherLoading(false);
          AppLogger.warn('天気取得用GPS失敗: ' + (err.message || ''));
        });
    };
    fetchWeather();
  }, []);

  // データは常にDataServiceから取得（単一のデータソース）
  const entries = useMemo(() => DataService.getEntries(), [refreshKey]);

  // localStorageの変更・データ変更イベントを監視して自動更新
  useEffect(() => {
    const handleStorage = (e) => {
      if (e.key === APP_CONSTANTS.STORAGE_KEYS.REVENUE_DATA) {
        setRefreshKey(k => k + 1);
      }
    };
    const handleDataChanged = () => setRefreshKey(k => k + 1);
    window.addEventListener('storage', handleStorage);
    window.addEventListener('taxi-data-changed', handleDataChanged);

    const handleVisibility = () => {
      if (!document.hidden) {
        setRefreshKey(k => k + 1);
        // 日付が変わっていたらフォームの日付を自動更新
        const currentDate = getLocalDateString();
        setForm(prev => {
          if (prev.date !== currentDate) {
            return { ...prev, date: currentDate };
          }
          return prev;
        });
      }
    };
    document.addEventListener('visibilitychange', handleVisibility);

    return () => {
      window.removeEventListener('storage', handleStorage);
      window.removeEventListener('taxi-data-changed', handleDataChanged);
      document.removeEventListener('visibilitychange', handleVisibility);
    };
  }, []);

  // GPS現在地を取得して住所に変換
  const getGpsLocation = useCallback((field) => {
    if (!navigator.geolocation) {
      setErrors(['このブラウザではGPS機能が使えません']);
      return;
    }

    setGpsLoading(prev => ({ ...prev, [field]: true }));
    setErrors([]);

    getAccuratePosition({ accuracyThreshold: 30, timeout: 20000, maxWaitAfterFix: 8000 })
      .then((position) => {
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;
        const acc = Math.round(position.coords.accuracy);
        setGpsInfo(prev => ({ ...prev, [field]: { ...((prev && prev[field]) || {}), lat, lng, accuracy: acc } }));

        // Google Maps Geocoding APIで逆ジオコーディング
        if (apiKey && window.google && window.google.maps) {
          const geocoder = new google.maps.Geocoder();
          geocoder.geocode({ location: { lat, lng } }, (results, status) => {
            setGpsLoading(prev => ({ ...prev, [field]: false }));
            if (status === 'OK' && results[0]) {
              // 住所コンポーネントから簡潔な住所を生成
              const address = _formatAddress(results[0]);
              const fullAddress = results[0].formatted_address.replace(/、日本$/, '').replace(/^日本、/, '');
              const timeField = field === 'pickup' ? 'pickupTime' : 'dropoffTime';
              setForm(prev => ({ ...prev, [field]: address, [timeField]: getNowTime() }));
              setGpsInfo(prev => ({ ...prev, [field]: { ...(prev[field] || {}), lat, lng, address: fullAddress } }));
              AppLogger.info(`GPS逆ジオコーディング成功 (${field}): ${address}`);
            } else {
              // Google Geocoding失敗時はNominatimにフォールバック
              const timeField2 = field === 'pickup' ? 'pickupTime' : 'dropoffTime';
              const nomUrl2 = TaxiApp.utils.nominatimUrl(lat, lng, 18);
              fetch(nomUrl2)
                .then(res2 => res2.json())
                .then(data2 => {
                  if (data2 && data2.address) {
                    const a2 = data2.address;
                    const parts2 = [a2.city || a2.town || a2.village || a2.county || '', a2.suburb || a2.neighbourhood || a2.quarter || '', a2.road || ''].filter(Boolean);
                    const shortAddr2 = parts2.join(' ') || data2.display_name.split(',').slice(0, 3).join(' ');
                    setForm(prev => ({ ...prev, [field]: shortAddr2, [timeField2]: getNowTime() }));
                    setGpsInfo(prev => ({ ...prev, [field]: { ...(prev[field] || {}), lat, lng, address: data2.display_name || shortAddr2 } }));
                  } else {
                    const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                    setForm(prev => ({ ...prev, [field]: coordStr, [timeField2]: getNowTime() }));
                    setGpsInfo(prev => ({ ...prev, [field]: { ...(prev[field] || {}), lat, lng, address: null } }));
                  }
                })
                .catch(() => {
                  const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                  setForm(prev => ({ ...prev, [field]: coordStr, [timeField2]: getNowTime() }));
                  setGpsInfo(prev => ({ ...prev, [field]: { ...(prev[field] || {}), lat, lng, address: null } }));
                });
              AppLogger.warn(`Google逆ジオコーディング失敗、Nominatimにフォールバック`);
            }
          });
        } else {
          // APIキーなし or Google Maps未ロードの場合はNominatim（OpenStreetMap）で逆ジオコーディング
          const timeField3 = field === 'pickup' ? 'pickupTime' : 'dropoffTime';
          const nomUrl = TaxiApp.utils.nominatimUrl(lat, lng, 18);
          fetch(nomUrl)
            .then(res => res.json())
            .then(data => {
              setGpsLoading(prev => ({ ...prev, [field]: false }));
              if (data && data.address) {
                // 日本の住所形式で組み立て
                const a = data.address;
                const parts = [a.city || a.town || a.village || a.county || '', a.suburb || a.neighbourhood || a.quarter || '', a.road || ''].filter(Boolean);
                const shortAddr = parts.join(' ') || data.display_name.split(',').slice(0, 3).join(' ');
                const fullAddr = data.display_name || shortAddr;
                setForm(prev => ({ ...prev, [field]: shortAddr, [timeField3]: getNowTime() }));
                setGpsInfo(prev => ({ ...prev, [field]: { ...(prev[field] || {}), lat, lng, address: fullAddr } }));
                AppLogger.info(`Nominatim逆ジオコーディング成功 (${field}): ${shortAddr}`);
              } else {
                const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                setForm(prev => ({ ...prev, [field]: coordStr, [timeField3]: getNowTime() }));
                setGpsInfo(prev => ({ ...prev, [field]: { ...(prev[field] || {}), lat, lng, address: null } }));
                AppLogger.warn(`Nominatim逆ジオコーディング失敗、座標を使用: ${coordStr}`);
              }
            })
            .catch(err => {
              setGpsLoading(prev => ({ ...prev, [field]: false }));
              const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
              setForm(prev => ({ ...prev, [field]: coordStr, [timeField3]: getNowTime() }));
              setGpsInfo(prev => ({ ...prev, [field]: { ...(prev[field] || {}), lat, lng, address: null } }));
              AppLogger.warn(`Nominatim API失敗、座標を使用: ${err.message}`);
            });
        }
      })
      .catch((error) => {
        setGpsLoading(prev => ({ ...prev, [field]: false }));
        const messages = {
          1: 'GPS使用が許可されていません。ブラウザの設定を確認してください。',
          2: '現在地を取得できませんでした。',
          3: 'GPS取得がタイムアウトしました。',
        };
        setErrors([messages[error.code] || 'GPS取得に失敗しました']);
        AppLogger.error(`GPS取得失敗 (${field}): code=${error.code || 0}`);
      });
  }, [apiKey]);

  // Geocoding結果から簡潔な住所を抽出
  function _formatAddress(result) {
    const comps = result.address_components;
    // 都道府県、市区町村、町名、番地を抽出
    let prefecture = '';
    let city = '';
    let ward = '';
    let town = '';
    let sublocality = '';

    for (const c of comps) {
      if (c.types.includes('administrative_area_level_1')) prefecture = c.long_name;
      if (c.types.includes('locality')) city = c.long_name;
      if (c.types.includes('sublocality_level_1') || c.types.includes('ward')) ward = c.long_name;
      if (c.types.includes('sublocality_level_2')) town = c.long_name;
      if (c.types.includes('sublocality_level_3')) sublocality = c.long_name;
    }

    // 簡潔な形式: 市区町村 + 町名 (都道府県は省略可)
    const parts = [ward || city || prefecture, town, sublocality].filter(Boolean);
    if (parts.length > 0) return parts.join(' ');

    // フォールバック: formatted_address から国名を除去
    return result.formatted_address.replace(/、日本$/, '').replace(/^日本、/, '');
  }

  // マップピッカーの初期化・クリックハンドラ（売上記録ページ用）
  useEffect(() => {
    if (!mapPickerField || !mapPickerRef.current || !window.google || !window.google.maps) return;
    setTimeout(() => { mapPickerRef.current && mapPickerRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' }); }, 100);
    const center = APP_CONSTANTS.DEFAULT_MAP_CENTER;
    const map = new google.maps.Map(mapPickerRef.current, {
      center, zoom: 13, mapTypeId: 'roadmap', disableDefaultUI: true,
      zoomControl: true, fullscreenControl: false, mapTypeControl: false,
    });
    mapPickerInstanceRef.current = map;
    const marker = new google.maps.Marker({ map, position: center, visible: false });
    mapPickerMarkerRef.current = marker;

    // GPS現在地を取得してマップの中心に設定
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const currentPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
          map.setCenter(currentPos);
          map.setZoom(13);
          new google.maps.Marker({ map, position: currentPos, icon: { path: google.maps.SymbolPath.CIRCLE, scale: 8, fillColor: '#4285F4', fillOpacity: 1, strokeColor: '#fff', strokeWeight: 2 }, title: '現在地', clickable: false });
        },
        () => {},
        { enableHighAccuracy: true, timeout: 5000, maximumAge: 10000 }
      );
    }

    const _extractAddress = TaxiApp.utils.extractAddress;

    map.addListener('click', (e) => {
      const lat = e.latLng.lat();
      const lng = e.latLng.lng();
      marker.setPosition(e.latLng);
      marker.setVisible(true);

      const timeField = mapPickerField === 'pickup' ? 'pickupTime' : 'dropoffTime';
      // 逆ジオコーディング
      const geocoder = new google.maps.Geocoder();
      geocoder.geocode({ location: { lat, lng } }, (results, status) => {
        if (status === 'OK' && results && results.length > 0) {
          const preferred = results.find(r => r.types.includes('street_address'))
            || results.find(r => r.types.includes('premise'))
            || results.find(r => r.types.includes('sublocality_level_3') || r.types.includes('sublocality_level_2'))
            || results.find(r => r.types.includes('route'))
            || results[0];
          const addr = _extractAddress(preferred);
          setForm(f => ({ ...f, [mapPickerField]: addr, [timeField]: getNowTime() }));
          setGpsInfo(prev => ({ ...prev, [mapPickerField]: { lat, lng, address: addr, accuracy: null } }));
        } else {
          // Nominatimフォールバック
          fetch(TaxiApp.utils.nominatimUrl(lat, lng, 18))
            .then(r => r.json()).then(data => {
              const a = data.address || {};
              const parts = [a.city || a.town || a.village || '', a.suburb || a.neighbourhood || a.quarter || '', a.road || '', a.house_number || ''].filter(Boolean);
              const addr = parts.join(' ') || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
              setForm(f => ({ ...f, [mapPickerField]: addr, [timeField]: getNowTime() }));
              setGpsInfo(prev => ({ ...prev, [mapPickerField]: { lat, lng, address: addr, accuracy: null } }));
            }).catch(() => {
              setForm(f => ({ ...f, [mapPickerField]: `${lat.toFixed(6)}, ${lng.toFixed(6)}`, [timeField]: getNowTime() }));
              setGpsInfo(prev => ({ ...prev, [mapPickerField]: { lat, lng, address: null, accuracy: null } }));
            });
        }
      });
    });

    return () => { mapPickerInstanceRef.current = null; mapPickerMarkerRef.current = null; };
  }, [mapPickerField]);

  const handleSubmit = (e) => {
    e.preventDefault();
    setErrors([]);

    // GPS座標をformに注入
    const formWithCoords = { ...form };
    if (gpsInfo.pickup && gpsInfo.pickup.lat != null) {
      formWithCoords.pickupCoords = { lat: gpsInfo.pickup.lat, lng: gpsInfo.pickup.lng };
    }
    if (gpsInfo.dropoff && gpsInfo.dropoff.lat != null) {
      formWithCoords.dropoffCoords = { lat: gpsInfo.dropoff.lat, lng: gpsInfo.dropoff.lng };
    }

    // DataServiceのaddEntryに完全委譲（バリデーション含む）
    const result = DataService.addEntry(formWithCoords);
    if (!result.success) {
      setErrors(result.errors);
      return;
    }

    setForm({ date: getLocalDateString(), weather: form.weather, amount: '', paymentMethod: 'cash', discountAmount: '', discountType: '', pickup: '', pickupTime: '', dropoff: '', dropoffTime: '', passengers: '1', gender: '', purpose: '', memo: '', source: '' });
    setGpsInfo({ pickup: null, dropoff: null });
    setMapPickerField(null);
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
    setRefreshKey(k => k + 1);
  };

  const handleReceiptCapture = async () => {
    setReceiptLoading(true);
    setErrors([]);
    let stream = null;
    try {
      // 背面カメラを無音で起動
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } },
        audio: false,
      });
      const video = document.createElement('video');
      video.srcObject = stream;
      video.setAttribute('playsinline', '');
      video.muted = true;
      await video.play();
      // カメラ安定のため少し待つ
      await new Promise(r => setTimeout(r, 500));
      // canvasで即時キャプチャ
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.getContext('2d').drawImage(video, 0, 0);
      // ストリーム停止
      stream.getTracks().forEach(t => t.stop());
      stream = null;
      // base64に変換
      const dataUrl = canvas.toDataURL('image/jpeg', 0.85);
      const base64 = dataUrl.split(',')[1];
      // Gemini APIで金額読み取り
      const amount = await GeminiService.analyzeReceiptImage(geminiApiKey, base64, 'image/jpeg');
      if (amount > 0) {
        setForm(prev => ({ ...prev, amount: String(amount) }));
      } else {
        setErrors(['レシートから金額を読み取れませんでした。手動で入力してください。']);
      }
    } catch (err) {
      if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
        setErrors(['カメラの使用が許可されていません。ブラウザの設定を確認してください。']);
      } else {
        setErrors([`レシート読み取りエラー: ${err.message}`]);
      }
    } finally {
      if (stream) stream.getTracks().forEach(t => t.stop());
      setReceiptLoading(false);
    }
  };

  const handleDelete = useCallback((id) => {
    DataService.deleteEntry(id);
    setRefreshKey(k => k + 1);
  }, []);

  const handleExportCSV = () => {
    DataService.downloadCSV();
  };

  const handleClearAll = () => {
    if (entries.length === 0) return;
    DataService.clearAllEntries();
    setRefreshKey(k => k + 1);
  };

  // 本日の日付文字列
  const today = getLocalDateString();
  const todayEntries = entries.filter(e => (e.date || e.timestamp.split('T')[0]) === today);
  const todayTotal = todayEntries.reduce((sum, e) => sum + e.amount, 0);
  const todayCashEntries = todayEntries.filter(e => (e.paymentMethod || 'cash') === 'cash');
  const todayUncollectedEntries = todayEntries.filter(e => e.paymentMethod === 'uncollected');
  const todayCash = todayCashEntries.reduce((sum, e) => sum + e.amount, 0);
  const todayUncollected = todayUncollectedEntries.reduce((sum, e) => sum + e.amount, 0);
  const todayDiscount = todayEntries.reduce((sum, e) => sum + (e.discountAmount || 0), 0);
  const allTotal = entries.reduce((sum, e) => sum + e.amount, 0);

  // GPS取得ボタンのスタイル
  const gpsButtonStyle = (loading) => ({
    display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
    padding: '8px 12px', borderRadius: '6px',
    fontSize: '11px', fontWeight: '600',
    color: loading ? 'var(--color-secondary)' : '#fff',
    cursor: loading ? 'wait' : 'pointer',
    border: '1px solid rgba(255,255,255,0.15)',
    background: loading ? 'rgba(249,168,37,0.15)' : 'rgba(26,115,232,0.2)',
    transition: 'all 0.2s ease',
    whiteSpace: 'nowrap',
    minWidth: '0',
    flex: '0 0 auto',
  });

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'receipt_long'),
      '売上記録'
    ),

    // 本日の合計
    React.createElement(Card, { style: { marginBottom: 'var(--space-lg)' } },
      // 合計金額セクション
      React.createElement('div', { style: { textAlign: 'center', paddingBottom: 'var(--space-sm)', marginBottom: 'var(--space-sm)', borderBottom: '1px solid var(--border-color)' } },
        React.createElement('div', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)', marginBottom: 4 } }, '本日の売上合計'),
        React.createElement('div', {
          style: { fontSize: 'var(--font-size-2xl)', fontWeight: 700, color: 'var(--color-secondary)', margin: '4px 0' },
        }, `¥${todayTotal.toLocaleString()}`),
        React.createElement('div', {
          style: { display: 'flex', justifyContent: 'center', gap: '16px', fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' },
        },
          React.createElement('span', null, `税抜: ¥${Math.floor(todayTotal / 1.1).toLocaleString()}`),
          React.createElement('span', { style: { color: 'var(--color-warning)' } }, `消費税: ¥${(todayTotal - Math.floor(todayTotal / 1.1)).toLocaleString()}`)
        )
      ),

      // 現金・未収 内訳
      React.createElement('div', {
        style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 'var(--space-md)', marginBottom: 'var(--space-sm)' },
      },
        // 現金
        React.createElement('div', {
          style: { padding: '10px', borderRadius: 'var(--border-radius)', background: 'rgba(26,115,232,0.08)', border: '1px solid rgba(26,115,232,0.2)' },
        },
          React.createElement('div', {
            style: { display: 'flex', alignItems: 'center', gap: 4, fontSize: 'var(--font-size-xs)', color: 'var(--color-accent)', fontWeight: 600, marginBottom: 6 },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: 14 } }, 'payments'),
            '現金'
          ),
          React.createElement('div', { style: { fontSize: 'var(--font-size-lg)', fontWeight: 700, color: 'var(--color-accent)' } },
            `¥${todayCash.toLocaleString()}`
          ),
          React.createElement('div', { style: { fontSize: 11, color: 'var(--text-muted)', marginTop: 4 } },
            `税抜: ¥${Math.floor(todayCash / 1.1).toLocaleString()}`
          ),
          React.createElement('div', { style: { fontSize: 11, color: 'var(--text-muted)' } },
            `消費税: ¥${(todayCash - Math.floor(todayCash / 1.1)).toLocaleString()}`
          )
        ),
        // 未収
        React.createElement('div', {
          style: { padding: '10px', borderRadius: 'var(--border-radius)', background: 'rgba(229,57,53,0.08)', border: '1px solid rgba(229,57,53,0.2)' },
        },
          React.createElement('div', {
            style: { display: 'flex', alignItems: 'center', gap: 4, fontSize: 'var(--font-size-xs)', color: 'var(--color-error)', fontWeight: 600, marginBottom: 6 },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: 14 } }, 'pending'),
            '未収'
          ),
          React.createElement('div', { style: { fontSize: 'var(--font-size-lg)', fontWeight: 700, color: 'var(--color-error)' } },
            `¥${todayUncollected.toLocaleString()}`
          ),
          React.createElement('div', { style: { fontSize: 11, color: 'var(--text-muted)', marginTop: 4 } },
            `税抜: ¥${Math.floor(todayUncollected / 1.1).toLocaleString()}`
          ),
          React.createElement('div', { style: { fontSize: 11, color: 'var(--text-muted)' } },
            `消費税: ¥${(todayUncollected - Math.floor(todayUncollected / 1.1)).toLocaleString()}`
          )
        )
      ),

      // 割引合計（割引がある場合のみ表示）
      todayDiscount > 0 && React.createElement('div', {
        style: { display: 'flex', justifyContent: 'center', gap: '12px', padding: '6px 0', borderTop: '1px solid var(--border-color)', fontSize: 'var(--font-size-xs)' },
      },
        React.createElement('span', { style: { color: '#a78bfa', fontWeight: 600 } },
          `割引合計: -¥${todayDiscount.toLocaleString()}`
        ),
        React.createElement('span', { style: { color: 'var(--text-muted)' } },
          `実収入: ¥${(todayTotal - todayDiscount).toLocaleString()}`
        )
      ),

      // 件数内訳
      React.createElement('div', {
        style: { display: 'flex', justifyContent: 'center', gap: '12px', padding: '8px 0', borderTop: '1px solid var(--border-color)', fontSize: 'var(--font-size-xs)' },
      },
        React.createElement('span', { style: { color: 'var(--text-secondary)', fontWeight: 600 } },
          `本日: ${todayEntries.length}件`
        ),
        React.createElement('span', { style: { color: 'var(--color-accent)' } },
          `現金: ${todayCashEntries.length}件`
        ),
        React.createElement('span', { style: { color: 'var(--color-error)' } },
          `未収: ${todayUncollectedEntries.length}件`
        ),
        React.createElement('span', { style: { color: 'var(--text-muted)' } },
          `全${entries.length}件 累計¥${allTotal.toLocaleString()}`
        )
      )
    ),

    // 入力フォーム
    React.createElement(Card, { title: '新規売上を記録', style: { marginBottom: 'var(--space-lg)' } },
      // バリデーションエラー表示
      errors.length > 0 && React.createElement('div', {
        style: {
          background: 'rgba(229,57,53,0.1)', border: '1px solid rgba(229,57,53,0.3)',
          borderRadius: '8px', padding: '8px 12px', marginBottom: 'var(--space-md)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: 'var(--color-danger)' },
        }, 'error'),
        React.createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-danger)' } },
          errors.join('、')
        )
      ),

      // 保存成功メッセージ
      saved && React.createElement('div', {
        style: {
          background: 'rgba(0,200,83,0.1)', border: '1px solid rgba(0,200,83,0.3)',
          borderRadius: '8px', padding: '8px 12px', marginBottom: 'var(--space-md)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: 'var(--color-accent)' },
        }, 'check_circle'),
        React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-accent)' } },
          '記録を追加しました'
        )
      ),

      React.createElement('form', { onSubmit: handleSubmit },
        React.createElement('div', { className: 'grid grid--2' },
          // 乗車地（GPS付き）
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '乗車地'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'stretch' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'text',
                placeholder: '東京駅',
                value: form.pickup,
                onChange: (e) => { setForm({ ...form, pickup: e.target.value }); if (!e.target.value) setGpsInfo(prev => ({ ...prev, pickup: null })); },
                style: { flex: 1, minWidth: 0 },
              }),
              React.createElement('button', {
                type: 'button',
                onClick: () => getGpsLocation('pickup'),
                disabled: gpsLoading.pickup,
                style: gpsButtonStyle(gpsLoading.pickup),
                title: 'GPSで現在地を取得',
              },
                React.createElement('span', {
                  className: 'material-icons-round',
                  style: { fontSize: '16px', animation: gpsLoading.pickup ? 'spin 1s linear infinite' : 'none' },
                }, gpsLoading.pickup ? 'sync' : 'my_location'),
                gpsLoading.pickup ? '取得中' : 'GPS'
              ),
              React.createElement('button', {
                type: 'button',
                onClick: () => setMapPickerField(mapPickerField === 'pickup' ? null : 'pickup'),
                style: {
                  display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
                  padding: '8px 12px', borderRadius: '6px', fontSize: '11px', fontWeight: '600',
                  color: mapPickerField === 'pickup' ? '#fff' : '#fff', cursor: 'pointer',
                  border: '1px solid rgba(255,255,255,0.15)',
                  background: mapPickerField === 'pickup' ? 'rgba(156,39,176,0.6)' : 'rgba(156,39,176,0.2)',
                  transition: 'all 0.2s ease', whiteSpace: 'nowrap', flex: '0 0 auto',
                },
                title: '地図から場所を選択',
              },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'map'),
                '地図'
              )
            ),
            // GPS取得結果の住所・座標表示
            gpsInfo.pickup && gpsInfo.pickup.lat != null && React.createElement('div', {
              style: {
                marginTop: '6px', padding: '6px 10px', borderRadius: '6px',
                background: 'rgba(26,115,232,0.08)', border: '1px solid rgba(26,115,232,0.15)',
                fontSize: '11px', color: 'var(--text-secondary)', lineHeight: '1.5',
              },
            },
              gpsInfo.pickup.address && React.createElement('div', { style: { display: 'flex', alignItems: 'flex-start', gap: '4px', marginBottom: '3px' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '13px', color: 'var(--color-primary-light)', marginTop: '1px', flexShrink: 0 } }, 'place'),
                React.createElement('span', { style: { fontWeight: '600', color: 'var(--color-primary-light)', wordBreak: 'break-all' } }, gpsInfo.pickup.address)
              ),
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '4px', color: 'var(--text-muted)', fontSize: '10px', flexWrap: 'wrap' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px', flexShrink: 0 } }, 'gps_fixed'),
                `${gpsInfo.pickup.lat.toFixed(6)}, ${gpsInfo.pickup.lng.toFixed(6)}`,
                gpsInfo.pickup.accuracy && React.createElement('span', {
                  style: { padding: '1px 6px', borderRadius: '3px', fontWeight: '600',
                    background: gpsInfo.pickup.accuracy <= 50 ? 'rgba(0,200,83,0.15)' : gpsInfo.pickup.accuracy <= 200 ? 'rgba(249,168,37,0.15)' : 'rgba(229,57,53,0.15)',
                    color: gpsInfo.pickup.accuracy <= 50 ? '#4caf50' : gpsInfo.pickup.accuracy <= 200 ? '#f9a825' : '#e53935' },
                }, `精度 ${gpsInfo.pickup.accuracy}m`),
                React.createElement('a', { href: `https://www.google.com/maps?q=${gpsInfo.pickup.lat},${gpsInfo.pickup.lng}`, target: '_blank', rel: 'noopener', style: { color: 'var(--color-primary-light)', textDecoration: 'underline' } }, '地図で確認')
              )
            ),
            // 乗車地マップピッカー
            mapPickerField === 'pickup' && React.createElement('div', { style: { marginTop: '6px' } },
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '4px', fontSize: '11px', color: 'rgba(156,39,176,0.9)' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'touch_app'),
                '地図をタップして乗車地を選択'
              ),
              (window.google && window.google.maps)
                ? React.createElement('div', { ref: mapPickerRef, style: { width: '100%', height: '300px', borderRadius: '8px', border: '2px solid rgba(156,39,176,0.5)', overflow: 'hidden' } })
                : React.createElement('div', { style: { padding: '20px', textAlign: 'center', color: 'var(--text-muted)', fontSize: '12px', background: 'var(--bg-tertiary)', borderRadius: '8px' } }, '設定画面でGoogle Maps APIキーを入力してください')
            )
          ),

          // 乗車時間
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '乗車時間'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'stretch' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'time',
                value: form.pickupTime,
                onChange: (e) => setForm({ ...form, pickupTime: e.target.value }),
                style: { flex: 1, minWidth: 0, colorScheme: 'dark' },
              }),
              React.createElement('button', {
                type: 'button',
                onClick: () => setForm({ ...form, pickupTime: getNowTime() }),
                style: {
                  display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
                  padding: '8px 12px', borderRadius: '6px', fontSize: '11px', fontWeight: '600',
                  color: '#fff', cursor: 'pointer',
                  border: '1px solid rgba(255,255,255,0.15)',
                  background: 'rgba(0,200,83,0.2)',
                  transition: 'all 0.2s ease', whiteSpace: 'nowrap', flex: '0 0 auto',
                },
                title: '現在時刻をセット',
              },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'schedule'),
                '現在'
              )
            )
          ),

          // 降車地（GPS付き）
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '降車地'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'stretch' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'text',
                placeholder: '渋谷駅',
                value: form.dropoff,
                onChange: (e) => { setForm({ ...form, dropoff: e.target.value }); if (!e.target.value) setGpsInfo(prev => ({ ...prev, dropoff: null })); },
                style: { flex: 1, minWidth: 0 },
              }),
              React.createElement('button', {
                type: 'button',
                onClick: () => getGpsLocation('dropoff'),
                disabled: gpsLoading.dropoff,
                style: gpsButtonStyle(gpsLoading.dropoff),
                title: 'GPSで現在地を取得',
              },
                React.createElement('span', {
                  className: 'material-icons-round',
                  style: { fontSize: '16px', animation: gpsLoading.dropoff ? 'spin 1s linear infinite' : 'none' },
                }, gpsLoading.dropoff ? 'sync' : 'my_location'),
                gpsLoading.dropoff ? '取得中' : 'GPS'
              ),
              React.createElement('button', {
                type: 'button',
                onClick: () => setMapPickerField(mapPickerField === 'dropoff' ? null : 'dropoff'),
                style: {
                  display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
                  padding: '8px 12px', borderRadius: '6px', fontSize: '11px', fontWeight: '600',
                  color: mapPickerField === 'dropoff' ? '#fff' : '#fff', cursor: 'pointer',
                  border: '1px solid rgba(255,255,255,0.15)',
                  background: mapPickerField === 'dropoff' ? 'rgba(156,39,176,0.6)' : 'rgba(156,39,176,0.2)',
                  transition: 'all 0.2s ease', whiteSpace: 'nowrap', flex: '0 0 auto',
                },
                title: '地図から場所を選択',
              },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'map'),
                '地図'
              )
            ),
            // GPS取得結果の住所・座標表示
            gpsInfo.dropoff && gpsInfo.dropoff.lat != null && React.createElement('div', {
              style: {
                marginTop: '6px', padding: '6px 10px', borderRadius: '6px',
                background: 'rgba(0,200,83,0.08)', border: '1px solid rgba(0,200,83,0.15)',
                fontSize: '11px', color: 'var(--text-secondary)', lineHeight: '1.5',
              },
            },
              gpsInfo.dropoff.address && React.createElement('div', { style: { display: 'flex', alignItems: 'flex-start', gap: '4px', marginBottom: '3px' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '13px', color: 'var(--color-accent)', marginTop: '1px', flexShrink: 0 } }, 'place'),
                React.createElement('span', { style: { fontWeight: '600', color: 'var(--color-accent)', wordBreak: 'break-all' } }, gpsInfo.dropoff.address)
              ),
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '4px', color: 'var(--text-muted)', fontSize: '10px', flexWrap: 'wrap' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px', flexShrink: 0 } }, 'gps_fixed'),
                `${gpsInfo.dropoff.lat.toFixed(6)}, ${gpsInfo.dropoff.lng.toFixed(6)}`,
                gpsInfo.dropoff.accuracy && React.createElement('span', {
                  style: { padding: '1px 6px', borderRadius: '3px', fontWeight: '600',
                    background: gpsInfo.dropoff.accuracy <= 50 ? 'rgba(0,200,83,0.15)' : gpsInfo.dropoff.accuracy <= 200 ? 'rgba(249,168,37,0.15)' : 'rgba(229,57,53,0.15)',
                    color: gpsInfo.dropoff.accuracy <= 50 ? '#4caf50' : gpsInfo.dropoff.accuracy <= 200 ? '#f9a825' : '#e53935' },
                }, `精度 ${gpsInfo.dropoff.accuracy}m`),
                React.createElement('a', { href: `https://www.google.com/maps?q=${gpsInfo.dropoff.lat},${gpsInfo.dropoff.lng}`, target: '_blank', rel: 'noopener', style: { color: 'var(--color-primary-light)', textDecoration: 'underline' } }, '地図で確認')
              )
            ),
            // 降車地マップピッカー
            mapPickerField === 'dropoff' && React.createElement('div', { style: { marginTop: '6px' } },
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '4px', fontSize: '11px', color: 'rgba(156,39,176,0.9)' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'touch_app'),
                '地図をタップして降車地を選択'
              ),
              (window.google && window.google.maps)
                ? React.createElement('div', { ref: mapPickerRef, style: { width: '100%', height: '300px', borderRadius: '8px', border: '2px solid rgba(156,39,176,0.5)', overflow: 'hidden' } })
                : React.createElement('div', { style: { padding: '20px', textAlign: 'center', color: 'var(--text-muted)', fontSize: '12px', background: 'var(--bg-tertiary)', borderRadius: '8px' } }, '設定画面でGoogle Maps APIキーを入力してください')
            ),
            // 乗客なしボタン（降車地GPS下）
            React.createElement('button', {
              type: 'button',
              onClick: () => {
                setErrors([]);
                const now = new Date();
                const hh = String(now.getHours()).padStart(2, '0');
                const mm = String(now.getMinutes()).padStart(2, '0');
                const dropoffTime = `${hh}:${mm}`;
                const formData = {
                  ...form,
                  dropoffTime,
                  amount: '0',
                  passengers: '0',
                  noPassenger: true,
                };
                if (gpsInfo.pickup && gpsInfo.pickup.lat != null) {
                  formData.pickupCoords = { lat: gpsInfo.pickup.lat, lng: gpsInfo.pickup.lng };
                }
                if (gpsInfo.dropoff && gpsInfo.dropoff.lat != null) {
                  formData.dropoffCoords = { lat: gpsInfo.dropoff.lat, lng: gpsInfo.dropoff.lng };
                }
                const result = DataService.addEntry(formData);
                if (result.success) {
                  setForm({ date: getLocalDateString(), weather: form.weather, amount: '', paymentMethod: 'cash', discountAmount: '', discountType: '', pickup: '', pickupTime: '', dropoff: '', dropoffTime: '', passengers: '1', gender: '', purpose: '', memo: '', source: '' });
                  setGpsInfo({ pickup: null, dropoff: null });
                  setMapPickerField(null);
                  setSaved(true);
                  setTimeout(() => setSaved(false), 2000);
                  setRefreshKey(k => k + 1);
                } else {
                  setErrors(result.errors);
                }
              },
              style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px', width: '100%', padding: '10px', marginTop: '8px', borderRadius: '8px', border: 'none', cursor: 'pointer', fontSize: '13px', fontWeight: 700, background: '#d32f2f', color: '#fff' },
            },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, 'person_off'),
              '乗客なし（待機時間を記録）'
            )
          ),

          // 降車時間
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '降車時間'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'stretch' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'time',
                value: form.dropoffTime,
                onChange: (e) => setForm({ ...form, dropoffTime: e.target.value }),
                style: { flex: 1, minWidth: 0, colorScheme: 'dark' },
              }),
              React.createElement('button', {
                type: 'button',
                onClick: () => setForm({ ...form, dropoffTime: getNowTime() }),
                style: {
                  display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
                  padding: '8px 12px', borderRadius: '6px', fontSize: '11px', fontWeight: '600',
                  color: '#fff', cursor: 'pointer',
                  border: '1px solid rgba(255,255,255,0.15)',
                  background: 'rgba(0,200,83,0.2)',
                  transition: 'all 0.2s ease', whiteSpace: 'nowrap', flex: '0 0 auto',
                },
                title: '現在時刻をセット',
              },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'schedule'),
                '現在'
              )
            )
          ),

          // 日付（自動：本日 + 曜日・祝日を自動計算）
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '日付 *',
              React.createElement('span', {
                style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: '400', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.1)' },
              }, '自動')
            ),
            React.createElement('input', {
              className: 'form-input',
              type: 'date',
              value: form.date,
              onChange: (e) => setForm({ ...form, date: e.target.value }),
              required: true,
              style: { colorScheme: 'dark' },
            }),
            // 曜日・祝日の自動表示
            form.date && (() => {
              const info = JapaneseHolidays.getDateInfo(form.date);
              const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-secondary)';
              return React.createElement('div', {
                style: { marginTop: '6px', display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' },
              },
                React.createElement('span', {
                  style: {
                    fontSize: '13px', fontWeight: '600', color: dayColor,
                    padding: '2px 10px', borderRadius: '4px',
                    background: info.isSunday || info.isHoliday ? 'rgba(239,68,68,0.12)' : info.isSaturday ? 'rgba(59,130,246,0.12)' : 'rgba(255,255,255,0.06)',
                  },
                }, `${info.dayOfWeek}曜日`),
                info.holiday && React.createElement('span', {
                  style: {
                    fontSize: '12px', fontWeight: '600', color: '#ef4444',
                    padding: '2px 10px', borderRadius: '4px',
                    background: 'rgba(239,68,68,0.12)',
                    display: 'flex', alignItems: 'center', gap: '4px',
                  },
                },
                  React.createElement('span', { style: { fontSize: '13px' } }, '🎌'),
                  info.holiday
                )
              );
            })()
          ),

          // 始業ボタン
          React.createElement('div', { className: 'form-group', style: { gridColumn: '1 / -1' } },
            React.createElement('button', {
              type: 'button',
              onClick: handleShiftStart,
              style: {
                width: '100%',
                display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px',
                padding: '14px 16px', borderRadius: '10px',
                fontSize: '15px', fontWeight: '700',
                cursor: 'pointer',
                border: shiftInfo.active ? '2px solid var(--color-accent)' : '2px solid var(--color-warning)',
                background: shiftInfo.active ? 'rgba(0,200,83,0.12)' : 'rgba(255,152,0,0.15)',
                color: shiftInfo.active ? 'var(--color-accent)' : 'var(--color-warning)',
                transition: 'all 0.2s ease',
              },
            },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '22px' } },
                shiftInfo.active ? 'work' : 'play_arrow'),
              shiftInfo.active
                ? `始業中 ${new Date(shiftInfo.startTime).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })}〜`
                : '始業'
            ),
            shiftInfo.active && React.createElement('div', {
              style: {
                marginTop: '8px', padding: '8px 12px', borderRadius: '8px',
                background: 'rgba(0,200,83,0.06)', border: '1px solid rgba(0,200,83,0.15)',
                fontSize: '12px', color: 'var(--text-secondary)', textAlign: 'center',
                display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px',
              },
            },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px', color: 'var(--color-accent)' } }, 'schedule'),
              `${new Date(shiftInfo.startTime).toLocaleDateString('ja-JP')} ${new Date(shiftInfo.startTime).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })} から勤務中`,
              (() => {
                const elapsed = Date.now() - new Date(shiftInfo.startTime).getTime();
                const hours = Math.floor(elapsed / 3600000);
                const mins = Math.floor((elapsed % 3600000) / 60000);
                return React.createElement('span', {
                  style: { fontWeight: '600', color: 'var(--color-accent)', padding: '1px 8px', borderRadius: '4px', background: 'rgba(0,200,83,0.12)' },
                }, `${hours}時間${mins}分`);
              })()
            )
          ),

          // 天候（自動取得 + 手動変更可）
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '天候',
              weatherLoading && React.createElement('span', {
                style: { fontSize: '11px', color: 'var(--color-secondary)', fontWeight: '400', animation: 'pulse 1.5s ease-in-out infinite' },
              }, '取得中...'),
              !weatherLoading && form.weather && React.createElement('span', {
                style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: '400', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.1)' },
              }, '自動取得済')
            ),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              ...[
                { value: '晴れ', icon: '☀️' },
                { value: '曇り', icon: '☁️' },
                { value: '雨', icon: '🌧️' },
                { value: '雪', icon: '❄️' },
              ].map(w =>
                React.createElement('button', {
                  key: w.value,
                  type: 'button',
                  onClick: () => setForm({ ...form, weather: form.weather === w.value ? '' : w.value }),
                  style: {
                    display: 'flex', alignItems: 'center', gap: '4px',
                    padding: '8px 14px', borderRadius: '8px',
                    fontSize: '13px', fontWeight: form.weather === w.value ? '700' : '400',
                    cursor: 'pointer',
                    border: form.weather === w.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.weather === w.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.weather === w.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', { style: { fontSize: '16px' } }, w.icon),
                  w.value
                )
              )
            )
          ),

          // 配車方法
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '配車方法'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              ...[
                { value: 'Go', icon: '🟢' },
                { value: 'Uber', icon: '⚫' },
                { value: 'DIDI', icon: '🟠' },
                { value: '電話', icon: '📞' },
                { value: '流し', icon: '🚕' },
              ].map(s =>
                React.createElement('button', {
                  key: s.value,
                  type: 'button',
                  onClick: () => setForm({ ...form, source: form.source === s.value ? '' : s.value }),
                  style: {
                    display: 'flex', alignItems: 'center', gap: '4px',
                    padding: '8px 14px', borderRadius: '8px',
                    fontSize: '13px', fontWeight: form.source === s.value ? '700' : '400',
                    cursor: 'pointer',
                    border: form.source === s.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.source === s.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.source === s.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', { style: { fontSize: '16px' } }, s.icon),
                  s.value
                )
              )
            )
          ),

          // 金額
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '金額 (税込・円) *'),
            React.createElement('div', { style: { display: 'flex', gap: '8px', alignItems: 'center' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'number',
                min: '1',
                max: '1000000',
                placeholder: '3500',
                value: form.amount,
                onChange: (e) => { setForm({ ...form, amount: e.target.value }); setErrors([]); },
                required: true,
                style: { flex: 1 },
              }),
              geminiApiKey && React.createElement('button', {
                type: 'button',
                onClick: handleReceiptCapture,
                disabled: receiptLoading,
                style: {
                  display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
                  padding: '8px 12px', borderRadius: '8px', border: '1px solid var(--border-color)',
                  background: receiptLoading ? 'var(--bg-secondary)' : 'var(--bg-card)',
                  color: 'var(--text-primary)', cursor: receiptLoading ? 'wait' : 'pointer',
                  fontSize: '14px', whiteSpace: 'nowrap', minWidth: '44px',
                },
                title: 'レシート撮影で金額を読み取る',
              },
                receiptLoading
                  ? React.createElement('span', { className: 'material-icons-round', style: { fontSize: '20px', animation: 'spin 1s linear infinite' } }, 'sync')
                  : React.createElement('span', { className: 'material-icons-round', style: { fontSize: '20px' } }, 'camera_alt')
              )
            ),
            // 税内訳表示
            form.amount && parseInt(form.amount) > 0 && (() => {
              const taxIncluded = parseInt(form.amount);
              const taxExcluded = Math.floor(taxIncluded / 1.1);
              const tax = taxIncluded - taxExcluded;
              return React.createElement('div', {
                style: {
                  marginTop: '6px', padding: '6px 10px', borderRadius: '6px',
                  background: 'rgba(249,168,37,0.08)', border: '1px solid rgba(249,168,37,0.15)',
                  fontSize: '12px', color: 'var(--text-secondary)',
                  display: 'flex', gap: '12px', flexWrap: 'wrap',
                },
              },
                React.createElement('span', null, `税抜: ¥${taxExcluded.toLocaleString()}`),
                React.createElement('span', { style: { color: 'var(--color-warning)' } }, `消費税: ¥${tax.toLocaleString()}`),
                React.createElement('span', null, `税込: ¥${taxIncluded.toLocaleString()}`)
              );
            })()
          ),

          // 支払い方法
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '支払い方法'),
            React.createElement('div', { style: { display: 'flex', gap: '8px' } },
              ...['cash', 'uncollected'].map(method => {
                const selected = form.paymentMethod === method;
                const label = method === 'cash' ? '現金' : '未収';
                const icon = method === 'cash' ? 'payments' : 'pending';
                const activeColor = method === 'cash' ? 'var(--color-accent)' : 'var(--color-error)';
                return React.createElement('button', {
                  key: method,
                  type: 'button',
                  onClick: () => setForm({ ...form, paymentMethod: method }),
                  style: {
                    flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px',
                    padding: '10px 12px', borderRadius: '8px', fontSize: '14px', fontWeight: selected ? 700 : 400,
                    cursor: 'pointer',
                    border: selected ? `2px solid ${activeColor}` : '1px solid rgba(255,255,255,0.15)',
                    background: selected ? (method === 'cash' ? 'rgba(0,200,83,0.15)' : 'rgba(229,57,53,0.15)') : 'rgba(255,255,255,0.05)',
                    color: selected ? activeColor : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, icon),
                  label
                );
              })
            )
          ),

          // 割引
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '割引'),
            React.createElement('div', { style: { display: 'flex', gap: '8px', flexWrap: 'wrap', marginBottom: '8px' } },
              ...['disability', 'coupon', 'ticket'].map(dtype => {
                const selected = form.discountType === dtype;
                const labels = { disability: '障害者割引', coupon: 'クーポン', ticket: 'タクシーチケット' };
                const icons = { disability: 'accessible', coupon: 'local_offer', ticket: 'confirmation_number' };
                return React.createElement('button', {
                  key: dtype,
                  type: 'button',
                  onClick: () => setForm({ ...form, discountType: selected ? '' : dtype, discountAmount: selected ? '' : form.discountAmount }),
                  style: {
                    flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
                    padding: '8px 6px', borderRadius: '8px', fontSize: '12px', fontWeight: selected ? 700 : 400,
                    cursor: 'pointer', minWidth: '90px',
                    border: selected ? '2px solid #a78bfa' : '1px solid rgba(255,255,255,0.15)',
                    background: selected ? 'rgba(167,139,250,0.15)' : 'rgba(255,255,255,0.05)',
                    color: selected ? '#a78bfa' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, icons[dtype]),
                  labels[dtype]
                );
              })
            ),
            form.discountType && React.createElement('div', { style: { display: 'flex', gap: '8px', alignItems: 'center' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'number',
                min: '0',
                max: '1000000',
                placeholder: '割引金額',
                value: form.discountAmount,
                onChange: (e) => setForm({ ...form, discountAmount: e.target.value }),
                style: { flex: 1 },
              }),
              React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-muted)', whiteSpace: 'nowrap' } }, '円')
            ),
            form.discountType && form.discountAmount && parseInt(form.discountAmount) > 0 && parseInt(form.amount) > 0 && React.createElement('div', {
              style: {
                marginTop: '6px', padding: '6px 10px', borderRadius: '6px',
                background: 'rgba(167,139,250,0.08)', border: '1px solid rgba(167,139,250,0.15)',
                fontSize: '12px', color: 'var(--text-secondary)',
                display: 'flex', gap: '12px',
              },
            },
              React.createElement('span', null, `割引後: ¥${(parseInt(form.amount) - parseInt(form.discountAmount)).toLocaleString()}`),
              React.createElement('span', { style: { color: '#a78bfa' } },
                `割引率: ${Math.round((parseInt(form.discountAmount) / parseInt(form.amount)) * 100)}%`
              )
            )
          ),

          // お客様人数
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, 'お客様人数'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              ...['1', '2', '3', '4'].map(n =>
                React.createElement('button', {
                  key: n,
                  type: 'button',
                  onClick: () => setForm({ ...form, passengers: n }),
                  style: {
                    display: 'flex', alignItems: 'center', justifyContent: 'center',
                    width: '44px', height: '44px', borderRadius: '8px',
                    fontSize: '15px', fontWeight: form.passengers === n ? '700' : '400',
                    cursor: 'pointer',
                    border: form.passengers === n ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.passengers === n ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.passengers === n ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                }, `${n}名`)
              ),
              React.createElement('input', {
                className: 'form-input',
                type: 'number',
                min: '1',
                max: '99',
                placeholder: '5+',
                value: !['1','2','3','4'].includes(form.passengers) ? form.passengers : '',
                onChange: (e) => setForm({ ...form, passengers: e.target.value }),
                onFocus: () => { if (['1','2','3','4'].includes(form.passengers)) setForm({ ...form, passengers: '' }); },
                style: { width: '60px', minWidth: '60px', flex: '0 0 auto', textAlign: 'center', fontSize: '14px' },
              })
            )
          ),

          // お客様性別
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, 'お客様性別'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              ...[
                { value: '男性', icon: '👨' },
                { value: '女性', icon: '👩' },
                { value: '混合', icon: '👥' },
              ].map(g =>
                React.createElement('button', {
                  key: g.value,
                  type: 'button',
                  onClick: () => setForm({ ...form, gender: form.gender === g.value ? '' : g.value }),
                  style: {
                    display: 'flex', alignItems: 'center', gap: '4px',
                    padding: '8px 14px', borderRadius: '8px',
                    fontSize: '13px', fontWeight: form.gender === g.value ? '700' : '400',
                    cursor: 'pointer',
                    border: form.gender === g.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.gender === g.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.gender === g.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', { style: { fontSize: '16px' } }, g.icon),
                  g.value
                )
              )
            )
          ),

          // 用途
          React.createElement('div', { className: 'form-group', style: { gridColumn: '1 / -1' } },
            React.createElement('label', { className: 'form-label' }, '用途'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              ...[
                { value: '通勤', icon: '🏢' },
                { value: '通院', icon: '🏥' },
                { value: '買物', icon: '🛒' },
                { value: '観光', icon: '📸' },
                { value: '出張', icon: '💼' },
                { value: '送迎', icon: '🚗' },
                { value: '空港', icon: '✈️' },
                { value: '飲食', icon: '🍺' },
                { value: 'パチンコ', icon: '🎰' },
              ].map(p =>
                React.createElement('button', {
                  key: p.value,
                  type: 'button',
                  onClick: () => setForm({ ...form, purpose: form.purpose === p.value ? '' : p.value }),
                  style: {
                    display: 'flex', alignItems: 'center', gap: '4px',
                    padding: '8px 12px', borderRadius: '8px',
                    fontSize: '12px', fontWeight: form.purpose === p.value ? '700' : '400',
                    cursor: 'pointer',
                    border: form.purpose === p.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.purpose === p.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.purpose === p.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', { style: { fontSize: '14px' } }, p.icon),
                  p.value
                )
              )
            )
          ),

          // メモ
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, 'メモ'),
            React.createElement('input', {
              className: 'form-input',
              type: 'text',
              placeholder: '任意のメモ',
              value: form.memo,
              onChange: (e) => setForm({ ...form, memo: e.target.value }),
            })
          )
        ),
        React.createElement(Button, {
          variant: 'primary',
          icon: 'add',
          style: { marginTop: 'var(--space-sm)' },
        }, '記録を追加')
      )
    ),

    // データ管理ツールバー
    React.createElement(Card, { style: { marginBottom: 'var(--space-md)' } },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '10px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--color-primary-light)' } }, 'folder'),
        React.createElement('span', { style: { fontSize: '13px', fontWeight: '600', color: 'var(--text-primary)' } }, 'データ管理'),
        entries.length > 0 && React.createElement('span', { style: { fontSize: '11px', color: 'var(--text-muted)', marginLeft: 'auto' } },
          `全 ${entries.length} 件の記録`
        )
      ),
      React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
        // 保存先フォルダ選択
        React.createElement(Button, {
          variant: 'secondary',
          icon: DataService.hasSaveFolder() ? 'folder_open' : 'create_new_folder',
          onClick: async () => {
            const result = await DataService.selectSaveFolder();
            if (result.success) {
              setSaved(false); setErrors([]);
              alert('保存先フォルダを設定しました: ' + result.folderName + '\n\n記録の追加時に自動保存されます。');
              setRefreshKey(k => k + 1);
            } else {
              if (result.message) alert(result.message);
            }
          },
          style: { padding: '6px 12px', fontSize: '11px' },
        }, DataService.hasSaveFolder() ? '保存先変更' : '保存先フォルダ設定'),
        // 手動保存
        entries.length > 0 && React.createElement(Button, {
          variant: 'secondary',
          icon: 'save',
          onClick: () => DataService.manualSaveToFile(),
          style: { padding: '6px 12px', fontSize: '11px' },
        }, 'JSON保存'),
        // CSVエクスポート
        entries.length > 0 && React.createElement(Button, {
          variant: 'secondary',
          icon: 'download',
          onClick: handleExportCSV,
          style: { padding: '6px 12px', fontSize: '11px' },
        }, 'CSV出力'),
        // ファイルから復元
        React.createElement(Button, {
          variant: 'secondary',
          icon: 'upload_file',
          onClick: async () => {
            const result = await DataService.importFromFile();
            if (result.success) {
              setRefreshKey(k => k + 1);
              alert(result.message);
            } else {
              if (result.message) alert(result.message);
            }
          },
          style: { padding: '6px 12px', fontSize: '11px' },
        }, 'ファイル復元'),
        // 全削除
        entries.length > 0 && React.createElement(Button, {
          variant: 'danger',
          icon: 'delete_forever',
          onClick: () => { if (confirm('全ての売上記録を削除しますか？この操作は取り消せません。')) handleClearAll(); },
          style: { padding: '6px 12px', fontSize: '11px' },
        }, '全削除')
      ),
      // 保存先フォルダ状態表示
      React.createElement('div', {
        style: { marginTop: '8px', fontSize: '10px', color: 'var(--text-muted)', display: 'flex', alignItems: 'center', gap: '4px' },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px' } }, 'info'),
        DataService.hasSaveFolder()
          ? '保存先フォルダ設定済み — 「売上記録」サブフォルダに自動保存されます'
          : '保存先フォルダ未設定 — 記録追加時にダウンロードとして保存されます'
      )
    ),

    // 記録一覧
    entries.length > 0 && React.createElement(Card, { title: `記録一覧（${entries.length}件）` },
      entries.map(entry =>
        React.createElement('div', {
          key: entry.id,
          style: {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            padding: '12px 0',
            borderBottom: '1px solid rgba(255,255,255,0.06)',
          },
        },
          React.createElement('div', { style: { flex: 1 } },
            React.createElement('div', { style: { fontWeight: 500, display: 'flex', alignItems: 'center', gap: '4px', flexWrap: 'wrap' } },
              entry.pickupTime && React.createElement('span', {
                style: { fontSize: '11px', color: 'var(--color-primary-light)', fontWeight: '600', padding: '1px 6px', borderRadius: '3px', background: 'rgba(26,115,232,0.12)' },
              }, entry.pickupTime),
              React.createElement('span', null, `${entry.pickup || '---'}`),
              React.createElement('span', { style: { color: 'var(--text-muted)', margin: '0 2px' } }, '→'),
              entry.dropoffTime && React.createElement('span', {
                style: { fontSize: '11px', color: 'var(--color-accent)', fontWeight: '600', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.12)' },
              }, entry.dropoffTime),
              React.createElement('span', null, `${entry.dropoff || '---'}`)
            ),
            React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', display: 'flex', flexWrap: 'wrap', alignItems: 'center', gap: '4px' } },
              (() => {
                const eDate = entry.date || getLocalDateString(new Date(entry.timestamp));
                const info = entry.dayOfWeek ? { dayOfWeek: entry.dayOfWeek, holiday: entry.holiday, isSunday: entry.dayOfWeek === '日', isSaturday: entry.dayOfWeek === '土', isHoliday: !!entry.holiday } : JapaneseHolidays.getDateInfo(eDate);
                const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-muted)';
                return React.createElement(React.Fragment, null,
                  React.createElement('span', null, eDate),
                  React.createElement('span', { style: { color: dayColor, fontWeight: '600' } }, `(${info.dayOfWeek})`),
                  info.holiday && React.createElement('span', {
                    style: { color: '#ef4444', fontSize: '10px', padding: '1px 6px', borderRadius: '3px', background: 'rgba(239,68,68,0.1)' },
                  }, info.holiday),
                  entry.weather && React.createElement('span', null, entry.weather),
                  entry.passengers && React.createElement('span', {
                    style: { fontSize: '10px', padding: '1px 5px', borderRadius: '3px', background: 'rgba(255,255,255,0.08)' },
                  }, `${entry.passengers}名`),
                  entry.gender && React.createElement('span', {
                    style: { fontSize: '10px', padding: '1px 5px', borderRadius: '3px', background: 'rgba(255,255,255,0.08)' },
                  }, entry.gender),
                  entry.purpose && React.createElement('span', {
                    style: { fontSize: '10px', padding: '1px 5px', borderRadius: '3px', background: 'rgba(26,115,232,0.1)', color: 'var(--color-primary-light)' },
                  }, entry.purpose),
                  entry.source && React.createElement('span', {
                    style: { fontSize: '10px', padding: '1px 5px', borderRadius: '3px', background: 'rgba(255,152,0,0.15)', color: '#ffb74d', fontWeight: '600' },
                  }, entry.source),
                  React.createElement('span', null, new Date(entry.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })),
                  entry.memo && React.createElement('span', null, `| ${entry.memo}`)
                );
              })()
            )
          ),
          React.createElement('div', { style: { marginRight: '12px', textAlign: 'right' } },
            entry.noPassenger
              ? React.createElement('div', { style: { fontWeight: 700, color: '#d32f2f', fontSize: 'var(--font-size-lg)' } }, '¥0（待機）')
              : React.createElement('div', { style: { fontWeight: 700, color: 'var(--color-secondary)', fontSize: 'var(--font-size-lg)' } }, `¥${entry.amount.toLocaleString()}`),
            !entry.noPassenger && React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(entry.amount / 1.1).toLocaleString()} 税¥${(entry.amount - Math.floor(entry.amount / 1.1)).toLocaleString()}`),
            entry.paymentMethod === 'uncollected' && React.createElement('div', {
              style: { fontSize: '10px', color: 'var(--color-error)', fontWeight: 600, marginTop: '2px' }
            }, '未収'),
            entry.discountAmount > 0 && React.createElement('div', {
              style: { fontSize: '10px', color: '#a78bfa', fontWeight: 600, marginTop: '2px' }
            }, `割引 -¥${entry.discountAmount.toLocaleString()}${entry.discountType === 'disability' ? ' (障害者)' : entry.discountType === 'coupon' ? ' (クーポン)' : entry.discountType === 'ticket' ? ' (チケット)' : ''}`)
          ),
          React.createElement('button', {
            onClick: () => handleDelete(entry.id),
            style: {
              background: 'none', border: 'none', cursor: 'pointer',
              color: 'var(--text-muted)', padding: '4px',
              borderRadius: '4px', transition: 'color 0.2s',
            },
            title: '削除',
          },
            React.createElement('span', {
              className: 'material-icons-round',
              style: { fontSize: '18px' },
            }, 'delete_outline')
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/RivalRide.jsx
// ============================================================
(function() {
// RivalRide.jsx - 他社乗車情報記録ページ
window.RivalRidePage = () => {
  const { useState, useEffect, useCallback, useRef, useMemo } = React;

  const todayDefault = getLocalDateString();

  const getNowTime = TaxiApp.utils.getNowTime;

  const wmoToWeather = (code) => {
    if (code === undefined || code === null) return '';
    if (code <= 1) return '晴れ';
    if (code <= 3 || code === 45 || code === 48) return '曇り';
    if ((code >= 51 && code <= 67) || (code >= 80 && code <= 82) || code === 95 || code === 96 || code === 99) return '雨';
    if ((code >= 71 && code <= 77) || code === 85 || code === 86) return '雪';
    return '曇り';
  };

  const [refreshKey, setRefreshKey] = useState(0);
  const [form, setForm] = useState({ date: todayDefault, time: getNowTime(), weather: '', location: '', locationCoords: null, memo: '' });
  const [errors, setErrors] = useState([]);
  const [saved, setSaved] = useState(false);
  const [gpsLoading, setGpsLoading] = useState(false);
  const [gpsInfo, setGpsInfo] = useState(null);
  const [weatherLoading, setWeatherLoading] = useState(false);
  const weatherFetched = useRef(false);
  const locationFetched = useRef(false);
  const formRef = useRef(form);
  useEffect(() => { formRef.current = form; }, [form]);

  const { apiKey } = useAppContext();

  // ページロード時に天気を自動取得
  useEffect(() => {
    if (weatherFetched.current) return;
    weatherFetched.current = true;

    if (!navigator.geolocation) return;
    setWeatherLoading(true);
    getAccuratePosition({ accuracyThreshold: 500, timeout: 10000, maxWaitAfterFix: 3000 })
      .then((position) => {
        const lat = position.coords.latitude.toFixed(4);
        const lng = position.coords.longitude.toFixed(4);
        const meteoParams = new URLSearchParams({ latitude: lat, longitude: lng, current_weather: 'true', timezone: 'Asia/Tokyo' });
        const url = `https://api.open-meteo.com/v1/forecast?${meteoParams}`;
        return fetch(url).then(res => res.json());
      })
      .then(data => {
        setWeatherLoading(false);
        if (data && data.current_weather) {
          const w = wmoToWeather(data.current_weather.weathercode);
          if (w) {
            setForm(prev => prev.weather ? prev : { ...prev, weather: w });
            AppLogger.info(`他社乗車 天気自動取得成功: ${w}`);
          }
        }
      })
      .catch(() => setWeatherLoading(false));
  }, []);

  // ページロード時にGPS場所を自動取得
  useEffect(() => {
    if (locationFetched.current) return;
    locationFetched.current = true;
    getGpsLocationAuto();
  }, []);

  const getGpsLocationAuto = () => {
    if (!navigator.geolocation) return;
    setGpsLoading(true);
    getAccuratePosition({ accuracyThreshold: 50, timeout: 20000, maxWaitAfterFix: 8000 })
      .then((position) => {
        setGpsInfo(prev => ({ ...prev, accuracy: Math.round(position.coords.accuracy) }));
        reverseGeocode(position.coords.latitude, position.coords.longitude, false);
      })
      .catch(() => setGpsLoading(false));
  };

  const getGpsLocation = useCallback(() => {
    if (!navigator.geolocation) {
      setErrors(['このブラウザではGPS機能が使えません']);
      return;
    }
    setGpsLoading(true);
    setErrors([]);
    getAccuratePosition({ accuracyThreshold: 30, timeout: 20000, maxWaitAfterFix: 8000 })
      .then((position) => {
        setGpsInfo(prev => ({ ...prev, accuracy: Math.round(position.coords.accuracy) }));
        reverseGeocode(position.coords.latitude, position.coords.longitude, true);
      })
      .catch((error) => {
        setGpsLoading(false);
        const messages = {
          1: 'GPS使用が許可されていません。ブラウザの設定を確認してください。',
          2: '現在地を取得できませんでした。',
          3: 'GPS取得がタイムアウトしました。',
        };
        setErrors([messages[error.code] || 'GPS取得に失敗しました']);
      });
  }, [apiKey]);

  // GPS解決時に自動記録追加
  const autoAddEntry = (location, coords) => {
    const cur = formRef.current;
    const entryData = { date: cur.date, time: getNowTime(), weather: cur.weather, location, locationCoords: coords, memo: cur.memo };
    const result = DataService.addRivalEntry(entryData);
    if (result.success) {
      setForm({ date: getLocalDateString(), time: getNowTime(), weather: cur.weather, location: '', locationCoords: null, memo: '' });
      setGpsInfo(null);
      setSaved(true);
      setTimeout(() => setSaved(false), 2000);
      setRefreshKey(k => k + 1);
    }
  };

  // 逆ジオコーディング共通処理（autoAdd=trueでGPS解決時に自動記録追加）
  const reverseGeocode = (lat, lng, autoAdd) => {
    if (apiKey && window.google && window.google.maps) {
      const geocoder = new google.maps.Geocoder();
      geocoder.geocode({ location: { lat, lng } }, (results, status) => {
        setGpsLoading(false);
        if (status === 'OK' && results[0]) {
          const address = _formatRivalAddress(results[0]);
          const fullAddress = results[0].formatted_address.replace(/、日本$/, '').replace(/^日本、/, '');
          AppLogger.info(`他社乗車 GPS逆ジオコーディング成功: ${address}`);
          if (autoAdd) {
            autoAddEntry(address, { lat, lng });
          } else {
            setForm(prev => ({ ...prev, location: address, locationCoords: { lat, lng }, time: getNowTime() }));
            setGpsInfo(prev => ({ ...prev, lat, lng, address: fullAddress }));
          }
        } else {
          nominatimFallback(lat, lng, autoAdd);
        }
      });
    } else {
      nominatimFallback(lat, lng, autoAdd);
    }
  };

  const nominatimFallback = (lat, lng, autoAdd) => {
    const nomUrl = TaxiApp.utils.nominatimUrl(lat, lng, 18);
    fetch(nomUrl)
      .then(res => res.json())
      .then(data => {
        setGpsLoading(false);
        if (data && data.address) {
          const a = data.address;
          const parts = [a.city || a.town || a.village || a.county || '', a.suburb || a.neighbourhood || a.quarter || '', a.road || ''].filter(Boolean);
          const shortAddr = parts.join(' ') || data.display_name.split(',').slice(0, 3).join(' ');
          AppLogger.info(`他社乗車 Nominatim逆ジオコーディング成功: ${shortAddr}`);
          if (autoAdd) {
            autoAddEntry(shortAddr, { lat, lng });
          } else {
            setForm(prev => ({ ...prev, location: shortAddr, locationCoords: { lat, lng }, time: getNowTime() }));
            setGpsInfo(prev => ({ ...prev, lat, lng, address: data.display_name || shortAddr }));
          }
        } else {
          const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
          if (autoAdd) {
            autoAddEntry(coordStr, { lat, lng });
          } else {
            setForm(prev => ({ ...prev, location: coordStr, locationCoords: { lat, lng }, time: getNowTime() }));
            setGpsInfo(prev => ({ ...prev, lat, lng, address: null }));
          }
        }
      })
      .catch(() => {
        setGpsLoading(false);
        const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
        if (autoAdd) {
          autoAddEntry(coordStr, { lat, lng });
        } else {
          setForm(prev => ({ ...prev, location: coordStr, locationCoords: { lat, lng } }));
          setGpsInfo(prev => ({ ...prev, lat, lng, address: null }));
        }
      });
  };

  function _formatRivalAddress(result) {
    const comps = result.address_components;
    let prefecture = '', city = '', ward = '', town = '', sublocality = '';
    for (const c of comps) {
      if (c.types.includes('administrative_area_level_1')) prefecture = c.long_name;
      if (c.types.includes('locality')) city = c.long_name;
      if (c.types.includes('sublocality_level_1') || c.types.includes('ward')) ward = c.long_name;
      if (c.types.includes('sublocality_level_2')) town = c.long_name;
      if (c.types.includes('sublocality_level_3')) sublocality = c.long_name;
    }
    const parts = [ward || city || prefecture, town, sublocality].filter(Boolean);
    if (parts.length > 0) return parts.join(' ');
    return result.formatted_address.replace(/、日本$/, '').replace(/^日本、/, '');
  }

  const entries = useMemo(() => DataService.getRivalEntries(), [refreshKey]);

  useEffect(() => {
    const handleStorage = (e) => {
      if (e.key === APP_CONSTANTS.STORAGE_KEYS.RIVAL_RIDES) {
        setRefreshKey(k => k + 1);
      }
    };
    window.addEventListener('storage', handleStorage);
    const handleVisibility = () => {
      if (!document.hidden) setRefreshKey(k => k + 1);
    };
    document.addEventListener('visibilitychange', handleVisibility);
    const handleDataChanged = () => setRefreshKey(k => k + 1);
    window.addEventListener('taxi-data-changed', handleDataChanged);
    return () => {
      window.removeEventListener('storage', handleStorage);
      document.removeEventListener('visibilitychange', handleVisibility);
      window.removeEventListener('taxi-data-changed', handleDataChanged);
    };
  }, []);

  const handleSubmit = (e) => {
    e.preventDefault();
    setErrors([]);
    const result = DataService.addRivalEntry(form);
    if (!result.success) {
      setErrors(result.errors);
      return;
    }
    setForm({ date: getLocalDateString(), time: getNowTime(), weather: form.weather, location: '', locationCoords: null, memo: '' });
    setGpsInfo(null);
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
    setRefreshKey(k => k + 1);
  };

  const handleDelete = useCallback((id) => {
    DataService.deleteRivalEntry(id);
    setRefreshKey(k => k + 1);
  }, []);

  const handleExportCSV = () => {
    DataService.downloadRivalCSV();
  };

  const handleClearAll = () => {
    if (entries.length === 0) return;
    DataService.clearAllRivalEntries();
    setRefreshKey(k => k + 1);
  };

  const gpsButtonStyle = (loading) => ({
    display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
    padding: '8px 12px', borderRadius: '6px',
    fontSize: '11px', fontWeight: '600',
    color: loading ? 'var(--color-secondary)' : '#fff',
    cursor: loading ? 'wait' : 'pointer',
    border: '1px solid rgba(255,255,255,0.15)',
    background: loading ? 'rgba(249,168,37,0.15)' : 'rgba(26,115,232,0.2)',
    transition: 'all 0.2s ease',
    whiteSpace: 'nowrap',
    minWidth: '0',
    flex: '0 0 auto',
  });

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'local_taxi'),
      '他社乗車情報'
    ),

    // 記録件数
    React.createElement(Card, { style: { marginBottom: 'var(--space-lg)', textAlign: 'center' } },
      React.createElement('div', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)' } }, '他社乗車記録'),
      React.createElement('div', {
        style: { fontSize: 'var(--font-size-2xl)', fontWeight: 700, color: 'var(--color-primary-light)', margin: '8px 0' },
      }, `${entries.length} 件`),
      React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-xs)' } },
        entries.length > 0 ? `最新: ${entries[0].date} ${entries[0].time}` : 'まだ記録がありません'
      )
    ),

    // 入力フォーム
    React.createElement(Card, { title: '他社乗車を記録', style: { marginBottom: 'var(--space-lg)' } },
      errors.length > 0 && React.createElement('div', {
        style: {
          background: 'rgba(229,57,53,0.1)', border: '1px solid rgba(229,57,53,0.3)',
          borderRadius: '8px', padding: '8px 12px', marginBottom: 'var(--space-md)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: 'var(--color-danger)' },
        }, 'error'),
        React.createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-danger)' } },
          errors.join('、')
        )
      ),

      saved && React.createElement('div', {
        style: {
          background: 'rgba(0,200,83,0.1)', border: '1px solid rgba(0,200,83,0.3)',
          borderRadius: '8px', padding: '8px 12px', marginBottom: 'var(--space-md)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: 'var(--color-accent)' },
        }, 'check_circle'),
        React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-accent)' } },
          '記録を追加しました'
        )
      ),

      React.createElement('form', { onSubmit: handleSubmit },
        React.createElement('div', { className: 'grid grid--2' },
          // 日付
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '年月日 *',
              React.createElement('span', {
                style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: '400', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.1)' },
              }, '自動')
            ),
            React.createElement('input', {
              className: 'form-input',
              type: 'date',
              value: form.date,
              onChange: (e) => setForm({ ...form, date: e.target.value }),
              required: true,
              style: { colorScheme: 'dark' },
            }),
            form.date && (() => {
              const info = JapaneseHolidays.getDateInfo(form.date);
              const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-secondary)';
              return React.createElement('div', {
                style: { marginTop: '6px', display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' },
              },
                React.createElement('span', {
                  style: {
                    fontSize: '13px', fontWeight: '600', color: dayColor,
                    padding: '2px 10px', borderRadius: '4px',
                    background: info.isSunday || info.isHoliday ? 'rgba(239,68,68,0.12)' : info.isSaturday ? 'rgba(59,130,246,0.12)' : 'rgba(255,255,255,0.06)',
                  },
                }, `${info.dayOfWeek}曜日`),
                info.holiday && React.createElement('span', {
                  style: {
                    fontSize: '12px', fontWeight: '600', color: '#ef4444',
                    padding: '2px 10px', borderRadius: '4px',
                    background: 'rgba(239,68,68,0.12)',
                    display: 'flex', alignItems: 'center', gap: '4px',
                  },
                },
                  React.createElement('span', { style: { fontSize: '13px' } }, '🎌'),
                  info.holiday
                )
              );
            })()
          ),

          // 時間
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '時間 *',
              React.createElement('span', {
                style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: '400', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.1)' },
              }, '自動')
            ),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'stretch' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'time',
                value: form.time,
                onChange: (e) => setForm({ ...form, time: e.target.value }),
                required: true,
                style: { flex: 1, minWidth: 0, colorScheme: 'dark' },
              }),
              React.createElement('button', {
                type: 'button',
                onClick: () => setForm({ ...form, time: getNowTime() }),
                style: {
                  display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
                  padding: '8px 12px', borderRadius: '6px', fontSize: '11px', fontWeight: '600',
                  color: '#fff', cursor: 'pointer',
                  border: '1px solid rgba(255,255,255,0.15)',
                  background: 'rgba(0,200,83,0.2)',
                  transition: 'all 0.2s ease', whiteSpace: 'nowrap', flex: '0 0 auto',
                },
                title: '現在時刻をセット',
              },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'schedule'),
                '現在'
              )
            )
          ),

          // 天候
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '天気',
              weatherLoading && React.createElement('span', {
                style: { fontSize: '11px', color: 'var(--color-secondary)', fontWeight: '400', animation: 'pulse 1.5s ease-in-out infinite' },
              }, '取得中...'),
              !weatherLoading && form.weather && React.createElement('span', {
                style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: '400', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.1)' },
              }, '自動取得済')
            ),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              ...[
                { value: '晴れ', icon: '☀️' },
                { value: '曇り', icon: '☁️' },
                { value: '雨', icon: '🌧️' },
                { value: '雪', icon: '❄️' },
              ].map(w =>
                React.createElement('button', {
                  key: w.value,
                  type: 'button',
                  onClick: () => setForm({ ...form, weather: form.weather === w.value ? '' : w.value }),
                  style: {
                    display: 'flex', alignItems: 'center', gap: '4px',
                    padding: '8px 14px', borderRadius: '8px',
                    fontSize: '13px', fontWeight: form.weather === w.value ? '700' : '400',
                    cursor: 'pointer',
                    border: form.weather === w.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.weather === w.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.weather === w.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', { style: { fontSize: '16px' } }, w.icon),
                  w.value
                )
              )
            )
          ),

          // 乗車場所（GPS付き）
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '乗車場所 *',
              gpsLoading && React.createElement('span', {
                style: { fontSize: '11px', color: 'var(--color-secondary)', fontWeight: '400', animation: 'pulse 1.5s ease-in-out infinite' },
              }, '取得中...'),
              !gpsLoading && form.location && React.createElement('span', {
                style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: '400', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.1)' },
              }, 'GPS取得済')
            ),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'stretch' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'text',
                placeholder: '東京駅前',
                value: form.location,
                onChange: (e) => { setForm({ ...form, location: e.target.value }); if (!e.target.value) setGpsInfo(null); },
                required: true,
                style: { flex: 1, minWidth: 0 },
              }),
              React.createElement('button', {
                type: 'button',
                onClick: getGpsLocation,
                disabled: gpsLoading,
                style: gpsButtonStyle(gpsLoading),
                title: 'GPSで現在地を取得',
              },
                React.createElement('span', {
                  className: 'material-icons-round',
                  style: { fontSize: '16px', animation: gpsLoading ? 'spin 1s linear infinite' : 'none' },
                }, gpsLoading ? 'sync' : 'my_location'),
                gpsLoading ? '取得中' : 'GPS'
              )
            ),
            gpsInfo && gpsInfo.lat && React.createElement('div', {
              style: {
                marginTop: '6px', padding: '8px 10px', borderRadius: '6px',
                background: 'rgba(26,115,232,0.08)', border: '1px solid rgba(26,115,232,0.15)',
                fontSize: '11px', color: 'var(--text-secondary)', lineHeight: '1.6',
              },
            },
              gpsInfo.address && React.createElement('div', { style: { display: 'flex', alignItems: 'flex-start', gap: '4px', marginBottom: '4px' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '13px', color: 'var(--color-primary-light)', marginTop: '1px', flexShrink: 0 } }, 'place'),
                React.createElement('span', { style: { fontWeight: '600', color: 'var(--color-primary-light)', wordBreak: 'break-all' } }, gpsInfo.address)
              ),
              // 座標 + 精度
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '4px', color: 'var(--text-muted)', fontSize: '10px', flexWrap: 'wrap' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px', flexShrink: 0 } }, 'gps_fixed'),
                `${gpsInfo.lat.toFixed(6)}, ${gpsInfo.lng.toFixed(6)}`,
                gpsInfo.accuracy && React.createElement('span', {
                  style: {
                    padding: '1px 6px', borderRadius: '3px', fontWeight: '600',
                    background: gpsInfo.accuracy <= 50 ? 'rgba(0,200,83,0.15)' : gpsInfo.accuracy <= 200 ? 'rgba(249,168,37,0.15)' : 'rgba(229,57,53,0.15)',
                    color: gpsInfo.accuracy <= 50 ? '#4caf50' : gpsInfo.accuracy <= 200 ? '#f9a825' : '#e53935',
                  },
                }, `精度 ${gpsInfo.accuracy}m`)
              ),
              // Google Maps で確認リンク
              React.createElement('div', { style: { marginTop: '4px' } },
                React.createElement('a', {
                  href: `https://www.google.com/maps?q=${gpsInfo.lat},${gpsInfo.lng}`,
                  target: '_blank',
                  rel: 'noopener',
                  style: { fontSize: '10px', color: 'var(--color-primary-light)', textDecoration: 'underline' },
                }, 'Google Mapsで位置を確認'),
              ),
              // 精度が低い場合のガイド
              gpsInfo.accuracy && gpsInfo.accuracy > 100 && React.createElement('div', {
                style: {
                  marginTop: '6px', padding: '6px 8px', borderRadius: '4px',
                  background: 'rgba(249,168,37,0.1)', border: '1px solid rgba(249,168,37,0.2)',
                  fontSize: '10px', color: '#f9a825', lineHeight: '1.5',
                },
              },
                React.createElement('div', { style: { fontWeight: '600', marginBottom: '2px' } }, 'GPS精度が低い場合:'),
                React.createElement('div', null, '・Androidの設定 → 位置情報 → 「正確な位置情報」をON'),
                React.createElement('div', null, '・Chromeの権限 → 位置情報 → 「正確な位置情報」を許可'),
                React.createElement('div', null, '・屋外で再取得すると精度が向上します')
              )
            )
          ),

          // メモ
          React.createElement('div', { className: 'form-group', style: { gridColumn: '1 / -1' } },
            React.createElement('label', { className: 'form-label' }, 'メモ'),
            React.createElement('input', {
              className: 'form-input',
              type: 'text',
              placeholder: '任意のメモ',
              value: form.memo,
              onChange: (e) => setForm({ ...form, memo: e.target.value }),
            })
          ),

          // 送信ボタン
          React.createElement('div', { style: { gridColumn: '1 / -1', marginTop: 'var(--space-sm)' } },
            React.createElement(Button, {
              variant: 'primary',
              icon: 'add',
              type: 'submit',
            }, '記録')
          )
        )
      )
    ),

    // データ管理ツールバー
    React.createElement(Card, { style: { marginBottom: 'var(--space-md)' } },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '10px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--color-primary-light)' } }, 'folder'),
        React.createElement('span', { style: { fontSize: '13px', fontWeight: '600', color: 'var(--text-primary)' } }, 'データ管理'),
        entries.length > 0 && React.createElement('span', { style: { fontSize: '11px', color: 'var(--text-muted)', marginLeft: 'auto' } },
          `全 ${entries.length} 件の記録`
        )
      ),
      React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
        // 保存先フォルダ選択
        React.createElement(Button, {
          variant: 'secondary',
          icon: DataService.hasSaveFolder() ? 'folder_open' : 'create_new_folder',
          onClick: async () => {
            const result = await DataService.selectSaveFolder();
            if (result.success) {
              setSaved(false); setErrors([]);
              alert('保存先フォルダを設定しました: ' + result.folderName + '\n\n記録の追加時に自動保存されます。\n（売上記録と共通の親フォルダです）');
              setRefreshKey(k => k + 1);
            } else {
              if (result.message) alert(result.message);
            }
          },
          style: { padding: '6px 12px', fontSize: '11px' },
        }, DataService.hasSaveFolder() ? '保存先変更' : '保存先フォルダ設定'),
        // 手動保存
        entries.length > 0 && React.createElement(Button, {
          variant: 'secondary',
          icon: 'save',
          onClick: () => DataService.manualSaveRivalToFile(),
          style: { padding: '6px 12px', fontSize: '11px' },
        }, 'JSON保存'),
        entries.length > 0 && React.createElement(Button, {
          variant: 'secondary',
          icon: 'download',
          onClick: handleExportCSV,
          style: { padding: '6px 12px', fontSize: '11px' },
        }, 'CSV出力'),
        entries.length > 0 && React.createElement(Button, {
          variant: 'danger',
          icon: 'delete_forever',
          onClick: () => { if (confirm('全ての他社乗車記録を削除しますか？この操作は取り消せません。')) handleClearAll(); },
          style: { padding: '6px 12px', fontSize: '11px' },
        }, '全削除')
      ),
      // 保存先フォルダ状態表示
      React.createElement('div', {
        style: { marginTop: '8px', fontSize: '10px', color: 'var(--text-muted)', display: 'flex', alignItems: 'center', gap: '4px' },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px' } }, 'info'),
        DataService.hasSaveFolder()
          ? '保存先フォルダ設定済み — 「他社乗車」サブフォルダに自動保存されます'
          : '保存先フォルダ未設定 — 記録追加時にダウンロードとして保存されます'
      )
    ),

    // 記録一覧
    entries.length > 0 && React.createElement(Card, { title: `記録一覧（${entries.length}件）` },
      entries.map(entry =>
        React.createElement('div', {
          key: entry.id,
          style: {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            padding: '12px 0',
            borderBottom: '1px solid rgba(255,255,255,0.06)',
          },
        },
          React.createElement('div', { style: { flex: 1 } },
            React.createElement('div', { style: { fontWeight: 500, display: 'flex', alignItems: 'center', gap: '6px', flexWrap: 'wrap' } },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: 'var(--color-primary-light)' } }, 'local_taxi'),
              React.createElement('span', null, entry.location || '---')
            ),
            React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', display: 'flex', flexWrap: 'wrap', alignItems: 'center', gap: '4px', marginTop: '4px' } },
              (() => {
                const info = entry.dayOfWeek ? { dayOfWeek: entry.dayOfWeek, holiday: entry.holiday, isSunday: entry.dayOfWeek === '日', isSaturday: entry.dayOfWeek === '土', isHoliday: !!entry.holiday } : JapaneseHolidays.getDateInfo(entry.date);
                const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-muted)';
                return React.createElement(React.Fragment, null,
                  React.createElement('span', null, entry.date),
                  React.createElement('span', { style: { color: dayColor, fontWeight: '600' } }, `(${info.dayOfWeek})`),
                  info.holiday && React.createElement('span', {
                    style: { color: '#ef4444', fontSize: '10px', padding: '1px 6px', borderRadius: '3px', background: 'rgba(239,68,68,0.1)' },
                  }, info.holiday),
                  entry.time && React.createElement('span', {
                    style: { fontSize: '11px', color: 'var(--color-primary-light)', fontWeight: '600', padding: '1px 6px', borderRadius: '3px', background: 'rgba(26,115,232,0.12)' },
                  }, entry.time),
                  entry.weather && React.createElement('span', null, entry.weather),
                  entry.memo && React.createElement('span', null, `| ${entry.memo}`)
                );
              })()
            )
          ),
          React.createElement('button', {
            onClick: () => handleDelete(entry.id),
            style: {
              background: 'none', border: 'none', cursor: 'pointer',
              color: 'var(--text-muted)', padding: '4px',
              borderRadius: '4px', transition: 'color 0.2s',
            },
            title: '削除',
          },
            React.createElement('span', {
              className: 'material-icons-round',
              style: { fontSize: '18px' },
            }, 'delete_outline')
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/TransitInfo.jsx
// ============================================================
(function() {
// TransitInfo.jsx - 公共交通機関情報ページ
// Gemini AI を使用して電車・バス・飛行機の運行情報と遅延情報を取得・保存
window.TransitInfoPage = () => {
  const { useState, useCallback, useEffect, useMemo, useRef } = React;
  const { geminiApiKey, apiKey } = useAppContext();

  const STORAGE_KEY = APP_CONSTANTS.STORAGE_KEYS.TRANSIT_INFO;

  // GPS地域検出
  const [region, setRegion] = useState(null);
  const [regionLoading, setRegionLoading] = useState(false);
  const regionFetched = useRef(false);

  // ページ読み込み時にGPSで現在地の地域を取得
  useEffect(() => {
    if (regionFetched.current) return;
    regionFetched.current = true;

    if (!navigator.geolocation) return;
    setRegionLoading(true);

    getAccuratePosition({ accuracyThreshold: 500, timeout: 10000, maxWaitAfterFix: 3000 })
      .then((position) => {
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;

        // Google Maps Geocoder があれば使用
        if (apiKey && window.google && window.google.maps) {
          const geocoder = new google.maps.Geocoder();
          geocoder.geocode({ location: { lat, lng } }, (results, status) => {
            setRegionLoading(false);
            if (status === 'OK' && results[0]) {
              const comps = results[0].address_components;
              let prefecture = '', city = '';
              for (const c of comps) {
                if (c.types.includes('administrative_area_level_1')) prefecture = c.long_name;
                if (c.types.includes('locality')) city = c.long_name;
                if (!city && (c.types.includes('sublocality_level_1') || c.types.includes('ward'))) city = c.long_name;
              }
              const regionStr = [prefecture, city].filter(Boolean).join(' ');
              if (regionStr) {
                setRegion(regionStr);
                AppLogger.info(`交通情報: 地域検出成功 (Google) - ${regionStr}`);
              }
            } else {
              // Google失敗時はNominatimにフォールバック
              _fetchRegionNominatim(lat, lng);
            }
          });
        } else {
          // Nominatimで逆ジオコーディング
          _fetchRegionNominatim(lat, lng);
        }
      })
      .catch((err) => {
        setRegionLoading(false);
        AppLogger.warn('交通情報: 地域検出失敗 - ' + (err.message || ''));
      });
  }, [apiKey]);

  // Nominatim逆ジオコーディングで地域名を取得
  const _fetchRegionNominatim = useCallback((lat, lng) => {
    const url = TaxiApp.utils.nominatimUrl(lat, lng, 10);
    fetch(url)
      .then(res => res.json())
      .then(data => {
        setRegionLoading(false);
        if (data && data.address) {
          const a = data.address;
          const prefecture = a.province || a.state || '';
          const city = a.city || a.town || a.village || a.county || '';
          const regionStr = [prefecture, city].filter(Boolean).join(' ');
          if (regionStr) {
            setRegion(regionStr);
            AppLogger.info(`交通情報: 地域検出成功 (Nominatim) - ${regionStr}`);
          }
        }
      })
      .catch(() => {
        setRegionLoading(false);
      });
  }, []);

  // カテゴリ定義
  const categories = useMemo(() => [
    { key: 'demand',  icon: 'insights',         label: '需要予測',       color: '124,58,237',  fetchFn: null },
    { key: 'trouble', icon: 'warning',        label: '遅延・トラブル', color: '229,57,53',  fetchFn: GeminiService.fetchTroubleInfo },
    { key: 'train',   icon: 'train',           label: '電車',           color: '26,115,232',  fetchFn: GeminiService.fetchTrainInfo },
    { key: 'bus',     icon: 'directions_bus',   label: 'バス',           color: '46,125,50',   fetchFn: GeminiService.fetchBusInfo },
    { key: 'flight',  icon: 'flight',           label: '飛行機',         color: '156,39,176',  fetchFn: GeminiService.fetchFlightInfo },
  ], []);

  // localStorageから保存済みデータを読み込み
  const loadSaved = () => {
    const saved = AppStorage.get(STORAGE_KEY, {});
    const result = {};
    categories.forEach(c => {
      if (c.key === 'demand') return;
      const s = saved[c.key];
      result[c.key] = { loading: false, result: s?.text || null, error: null, fetchedAt: s?.fetchedAt || null };
    });
    return result;
  };

  const [data, setData] = useState(loadSaved);
  const [activeTab, setActiveTab] = useState(geminiApiKey ? 'demand' : 'bus');

  // 需要予測プラン関連（data/setData宣言後に配置）
  const [demandLoading, setDemandLoading] = useState(false);
  const demandLoadingRef = useRef(false);
  const demandSchedule = useMemo(() => DataService.getDailyDemandSchedule(), [data]);

  const handleFetchDemandPlan = useCallback(async () => {
    if (!geminiApiKey || demandLoadingRef.current) return;
    demandLoadingRef.current = true;
    setDemandLoading(true);
    const result = await GeminiService.fetchDailyDemandPlan(geminiApiKey, region);
    if (result.success && result.data) {
      const today = new Date().toISOString().slice(0, 10);
      AppStorage.set(APP_CONSTANTS.STORAGE_KEYS.DAILY_DEMAND_PLAN, { date: today, data: result.data, fetchedAt: new Date().toISOString() });
      window.dispatchEvent(new CustomEvent('taxi-data-changed', { detail: { type: 'demand-plan' } }));
      setData(prev => ({ ...prev }));
    }
    demandLoadingRef.current = false;
    setDemandLoading(false);
  }, [geminiApiKey, region]);

  // データをlocalStorageに保存 + ファイル保存
  const saveToStorage = useCallback((newData) => {
    const toSave = {};
    Object.keys(newData).forEach(key => {
      if (newData[key].result) {
        toSave[key] = { text: newData[key].result, fetchedAt: newData[key].fetchedAt };
      }
    });
    AppStorage.set(STORAGE_KEY, toSave);
    // 保存先フォルダが設定されていればファイルにも保存
    DataService.autoSaveTransitToFile(toSave);
    window.dispatchEvent(new CustomEvent('taxi-data-changed', { detail: { type: 'transit' } }));
  }, [STORAGE_KEY]);

  // カテゴリ別取得
  const handleFetch = useCallback(async (categoryKey) => {
    if (categoryKey === 'demand') { handleFetchDemandPlan(); return; }
    const cat = categories.find(c => c.key === categoryKey);
    if (!cat || !cat.fetchFn) return;

    setData(prev => ({ ...prev, [categoryKey]: { ...prev[categoryKey], loading: true, error: null } }));

    const result = await cat.fetchFn(geminiApiKey, region);
    const now = new Date().toISOString();

    setData(prev => {
      const updated = {
        ...prev,
        [categoryKey]: {
          loading: false,
          result: result.success ? result.text : prev[categoryKey].result,
          error: result.success ? null : result.error,
          fetchedAt: result.success ? now : prev[categoryKey].fetchedAt,
        }
      };
      if (result.success) saveToStorage(updated);
      return updated;
    });

    // 遅延・トラブル情報取得成功時にプッシュ通知
    if (categoryKey === 'trouble' && result.success && result.text) {
      NotificationService.sendTroubleAlert(result.text);
    }
  }, [geminiApiKey, region, categories, saveToStorage, handleFetchDemandPlan]);

  // 全カテゴリ一括取得
  const handleFetchAll = useCallback(async () => {
    for (const cat of categories) {
      await handleFetch(cat.key);
    }
  }, [categories, handleFetch]);

  // 取得時刻のフォーマット
  const formatTime = (isoStr) => {
    if (!isoStr) return null;
    const d = new Date(isoStr);
    return d.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
  };

  // Geminiテキストを見やすく整形するレンダラー
  const renderFormattedText = (text) => {
    if (!text) return null;

    const lines = text.split('\n');
    const elements = [];

    lines.forEach((line, idx) => {
      const trimmed = line.trim();
      if (!trimmed) {
        elements.push(React.createElement('div', { key: idx, style: { height: '6px' } }));
        return;
      }

      // ### 見出し3
      if (trimmed.startsWith('### ')) {
        elements.push(React.createElement('div', {
          key: idx,
          style: {
            fontSize: '12px', fontWeight: 600, color: 'var(--text-secondary)',
            marginTop: '12px', marginBottom: '4px', paddingBottom: '3px',
            borderBottom: '1px solid rgba(255,255,255,0.06)',
          },
        }, renderInlineFormatting(trimmed.slice(4))));
        return;
      }

      // ## 見出し2
      if (trimmed.startsWith('## ')) {
        elements.push(React.createElement('div', {
          key: idx,
          style: {
            fontSize: '13px', fontWeight: 700, color: 'var(--color-primary-light)',
            marginTop: '14px', marginBottom: '6px', paddingBottom: '4px',
            borderBottom: '1px solid rgba(26,115,232,0.2)',
            display: 'flex', alignItems: 'center', gap: '6px',
          },
        }, renderInlineFormatting(trimmed.slice(3))));
        return;
      }

      // # 見出し1
      if (trimmed.startsWith('# ')) {
        elements.push(React.createElement('div', {
          key: idx,
          style: {
            fontSize: '14px', fontWeight: 700, color: 'var(--text-primary)',
            marginTop: '16px', marginBottom: '8px', paddingBottom: '6px',
            borderBottom: '2px solid rgba(26,115,232,0.3)',
          },
        }, renderInlineFormatting(trimmed.slice(2))));
        return;
      }

      // 【セクション】ヘッダー
      if (trimmed.startsWith('\u3010') && trimmed.includes('\u3011')) {
        elements.push(React.createElement('div', {
          key: idx,
          style: {
            fontSize: '13px', fontWeight: 700, color: 'var(--color-primary-light)',
            marginTop: '14px', marginBottom: '6px', padding: '6px 10px',
            borderRadius: '6px', background: 'rgba(26,115,232,0.08)',
            borderLeft: '3px solid rgba(26,115,232,0.5)',
          },
        }, renderInlineFormatting(trimmed)));
        return;
      }

      // 表区切り線 (|---|---| 形式) - スキップ
      if (/^\|[\s\-:]+\|/.test(trimmed) && !trimmed.replace(/[\|\s\-:]/g, '')) {
        return;
      }

      // テーブル行 (| cell | cell |)
      if (trimmed.startsWith('|') && trimmed.endsWith('|')) {
        const cells = trimmed.split('|').filter(c => c.trim());
        const isHeader = idx + 1 < lines.length && /^\|[\s\-:]+\|/.test(lines[idx + 1]?.trim() || '');
        elements.push(React.createElement('div', {
          key: idx,
          style: {
            display: 'grid',
            gridTemplateColumns: `repeat(${cells.length}, 1fr)`,
            gap: '1px', fontSize: '11px',
            background: 'rgba(255,255,255,0.04)', borderRadius: idx === 0 ? '4px 4px 0 0' : '0',
          },
        },
          cells.map((cell, ci) => React.createElement('div', {
            key: ci,
            style: {
              padding: '5px 8px',
              fontWeight: isHeader ? 700 : 400,
              color: isHeader ? 'var(--text-primary)' : 'var(--text-secondary)',
              background: isHeader ? 'rgba(26,115,232,0.08)' : 'rgba(255,255,255,0.02)',
              borderBottom: '1px solid rgba(255,255,255,0.05)',
              whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis',
            },
          }, renderInlineFormatting(cell.trim())))
        ));
        return;
      }

      // 箇条書き (- / * / ・)
      if (/^[-*\u30FB]/.test(trimmed) && trimmed.length > 1) {
        const content = trimmed.replace(/^[-*\u30FB]\s*/, '');
        elements.push(React.createElement('div', {
          key: idx,
          style: {
            display: 'flex', gap: '6px', fontSize: '12px', color: 'var(--text-primary)',
            padding: '2px 0 2px 8px', lineHeight: 1.6,
          },
        },
          React.createElement('span', { style: { color: 'var(--color-primary-light)', flexShrink: 0, marginTop: '2px', fontSize: '8px' } }, '\u25CF'),
          React.createElement('span', null, renderInlineFormatting(content))
        ));
        return;
      }

      // 番号付きリスト (1. / 2.)
      if (/^\d+[\.\)]\s/.test(trimmed)) {
        const num = trimmed.match(/^(\d+)[\.\)]\s/)[1];
        const content = trimmed.replace(/^\d+[\.\)]\s*/, '');
        elements.push(React.createElement('div', {
          key: idx,
          style: {
            display: 'flex', gap: '6px', fontSize: '12px', color: 'var(--text-primary)',
            padding: '2px 0 2px 4px', lineHeight: 1.6,
          },
        },
          React.createElement('span', {
            style: {
              color: 'var(--color-primary-light)', flexShrink: 0, fontWeight: 600,
              fontSize: '11px', minWidth: '16px', textAlign: 'right',
            },
          }, num + '.'),
          React.createElement('span', null, renderInlineFormatting(content))
        ));
        return;
      }

      // 通常テキスト
      elements.push(React.createElement('div', {
        key: idx,
        style: { fontSize: '12px', color: 'var(--text-primary)', lineHeight: 1.7, padding: '1px 0' },
      }, renderInlineFormatting(trimmed)));
    });

    return elements;
  };

  // インライン書式（太字・強調）
  const renderInlineFormatting = (text) => {
    if (!text) return '';
    // **太字**
    const parts = text.split(/(\*\*[^*]+\*\*)/g);
    if (parts.length <= 1) return text;
    return parts.map((part, i) => {
      if (part.startsWith('**') && part.endsWith('**')) {
        return React.createElement('strong', {
          key: i,
          style: { fontWeight: 700, color: 'var(--text-primary)' },
        }, part.slice(2, -2));
      }
      return part;
    });
  };

  // APIキー未設定時はバスタブをデフォルトにする（バスはAPIキー不要）
  // 他タブ（電車・飛行機・トラブル・需要予測）はAPIキー必要

  const today = new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
  const anyLoading = categories.some(c => data[c.key]?.loading);
  const activeCat = categories.find(c => c.key === activeTab) || { key: 'demand', icon: 'insights', label: '需要予測', color: '124,58,237', fetchFn: null };
  const activeData = data[activeTab] || { loading: false, result: null, error: null, fetchedAt: null };

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'directions_transit'),
      '公共交通機関情報'
    ),

    // 上部: 日付 + 取得ボタン群
    React.createElement(Card, { style: { marginBottom: 'var(--space-md)' } },
      // 日付 + 地域
      React.createElement('div', {
        style: {
          display: 'flex', alignItems: 'center', justifyContent: 'space-between',
          marginBottom: '8px', flexWrap: 'wrap', gap: '8px',
        },
      },
        React.createElement('div', {
          style: { display: 'flex', flexDirection: 'column', gap: '4px' },
        },
          React.createElement('div', {
            style: { display: 'flex', alignItems: 'center', gap: '6px', fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)' },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'today'),
            today
          ),
          React.createElement('div', {
            style: { display: 'flex', alignItems: 'center', gap: '4px', fontSize: '11px', color: 'var(--text-muted)' },
          },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, regionLoading ? 'sync' : 'place'),
            regionLoading ? '地域を検出中...'
              : region ? region
              : 'GPS地域未検出（デフォルト: 東京都内）'
          )
        ),
        React.createElement(Button, {
          variant: 'primary',
          icon: anyLoading ? 'sync' : 'refresh',
          onClick: handleFetchAll,
          disabled: anyLoading,
          style: { fontSize: '11px', padding: '6px 12px' },
        }, anyLoading ? '取得中...' : 'すべて取得')
      ),

      // 個別取得ボタン群
      React.createElement('div', {
        style: { display: 'grid', gridTemplateColumns: 'repeat(5, 1fr)', gap: '4px' },
      },
        categories.map(cat => {
          const catData = cat.key === 'demand' ? { result: demandSchedule.available, loading: demandLoading } : (data[cat.key] || {});
          const hasData = !!catData.result;
          const isLoading = catData.loading;
          return React.createElement('button', {
            key: cat.key,
            onClick: () => { if (!isLoading) handleFetch(cat.key); },
            disabled: isLoading,
            style: {
              display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '4px',
              padding: '10px 4px', borderRadius: '10px', border: 'none',
              background: isLoading ? 'rgba(255,255,255,0.08)' : `rgba(${cat.color}, 0.1)`,
              cursor: isLoading ? 'wait' : 'pointer', transition: 'all 0.15s',
              opacity: isLoading ? 0.7 : 1,
            },
            onMouseEnter: (e) => { if (!isLoading) e.currentTarget.style.background = `rgba(${cat.color}, 0.2)`; },
            onMouseLeave: (e) => { e.currentTarget.style.background = isLoading ? 'rgba(255,255,255,0.08)' : `rgba(${cat.color}, 0.1)`; },
          },
            React.createElement('span', {
              className: 'material-icons-round',
              style: {
                fontSize: '22px', color: `rgb(${cat.color})`,
                animation: isLoading ? 'spin 1s linear infinite' : 'none',
              },
            }, isLoading ? 'sync' : cat.icon),
            React.createElement('span', {
              style: { fontSize: '10px', fontWeight: 600, color: 'var(--text-primary)' },
            }, cat.label),
            // 取得済みマーク or 未取得
            hasData
              ? React.createElement('span', {
                  style: { fontSize: '9px', color: 'var(--text-muted)' },
                }, formatTime(catData.fetchedAt) + ' 取得')
              : React.createElement('span', {
                  style: { fontSize: '9px', color: 'var(--text-muted)', opacity: 0.5 },
                }, '未取得')
          );
        })
      )
    ),

    // タブ切り替え
    React.createElement('div', {
      style: {
        display: 'flex', gap: '2px', marginBottom: 'var(--space-sm)',
        background: 'rgba(255,255,255,0.03)', borderRadius: '10px', padding: '3px',
      },
    },
      categories.map(cat => {
        const isActive = activeTab === cat.key;
        const catData = cat.key === 'demand' ? { result: demandSchedule.available } : (data[cat.key] || {});
        return React.createElement('button', {
          key: cat.key,
          onClick: () => setActiveTab(cat.key),
          style: {
            flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
            padding: '8px 4px', borderRadius: '8px', border: 'none',
            background: isActive ? `rgba(${cat.color}, 0.15)` : 'transparent',
            color: isActive ? `rgb(${cat.color})` : 'var(--text-muted)',
            fontWeight: isActive ? 600 : 400, fontSize: '11px',
            cursor: 'pointer', transition: 'all 0.15s', position: 'relative',
          },
        },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '16px' },
          }, cat.icon),
          // モバイルではラベル非表示
          React.createElement('span', {
            style: { fontSize: '10px' },
            className: 'transit-tab-label',
          }, cat.label),
          // 取得済みドット
          catData.result && React.createElement('span', {
            style: {
              position: 'absolute', top: '4px', right: '4px',
              width: '5px', height: '5px', borderRadius: '50%',
              background: `rgb(${cat.color})`,
            },
          })
        );
      })
    ),

    // 需要予測タブ コンテンツ
    activeTab === 'demand' && React.createElement(Card, {
      style: { marginBottom: 'var(--space-md)' },
    },
      // ヘッダー
      React.createElement('div', {
        style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '12px', paddingBottom: '10px', borderBottom: '1px solid rgba(255,255,255,0.06)' },
      },
        React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '20px', color: '#7c3aed' } }, 'insights'),
          React.createElement('div', null,
            React.createElement('div', { style: { fontWeight: 700, fontSize: '13px' } }, '交通需要予測'),
            React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, 'JR特急・バス到着 + 病院外来ピーク')
          )
        ),
        React.createElement('button', {
          onClick: handleFetchDemandPlan,
          disabled: demandLoading || !geminiApiKey,
          style: {
            display: 'flex', alignItems: 'center', gap: '4px',
            padding: '4px 10px', borderRadius: '6px', border: 'none',
            background: 'rgba(124,58,237,0.15)', color: '#a78bfa',
            fontSize: '11px', fontWeight: 600, cursor: geminiApiKey ? 'pointer' : 'not-allowed',
            opacity: demandLoading ? 0.6 : 1,
          },
        },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '14px', animation: demandLoading ? 'spin 1s linear infinite' : 'none' },
          }, demandLoading ? 'sync' : 'refresh'),
          demandLoading ? '取得中...' : '取得'
        )
      ),

      // APIキー未設定
      !geminiApiKey && React.createElement('div', {
        style: { padding: '16px', textAlign: 'center', color: 'var(--text-muted)', fontSize: 'var(--font-size-xs)' },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '28px', display: 'block', marginBottom: '6px', color: '#7c3aed' } }, 'vpn_key'),
        'Gemini APIキーを設定すると需要予測が利用できます'
      ),

      // ローディング
      demandLoading && !demandSchedule.available && React.createElement('div', {
        style: { padding: '20px', textAlign: 'center', color: 'var(--text-muted)' },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '32px', animation: 'spin 1s linear infinite', display: 'block', marginBottom: '6px' } }, 'sync'),
        'Gemini AIから需要予測データを取得中...'
      ),

      // タイムライン
      demandSchedule.available && demandSchedule.dailyPlan.length > 0 && React.createElement('div', {
        style: { marginBottom: '16px' },
      },
        React.createElement('div', { style: { fontSize: '12px', fontWeight: 600, color: '#7c3aed', marginBottom: '8px' } }, '営業タイムライン'),
        demandSchedule.dailyPlan.map((block, i) => {
          const now = new Date();
          const nowStr = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
          const isCurrent = nowStr >= (block.startTime || '') && nowStr < (block.endTime || '24:00');
          const lc = block.demandLevel === 'high' ? '#ef4444' : block.demandLevel === 'medium' ? '#f59e0b' : '#3b82f6';
          return React.createElement('div', {
            key: i,
            style: {
              display: 'flex', gap: '10px', padding: '8px', borderRadius: '6px', marginBottom: '3px',
              background: isCurrent ? 'rgba(124,58,237,0.12)' : 'transparent',
              border: isCurrent ? '1px solid rgba(124,58,237,0.3)' : '1px solid transparent',
            },
          },
            React.createElement('div', {
              style: { minWidth: '70px', padding: '2px 6px', borderRadius: '4px', background: `${lc}20`, color: lc, fontSize: '11px', fontWeight: 700, textAlign: 'center', borderLeft: `3px solid ${lc}` },
            }, `${block.startTime || ''}`, React.createElement('br'), `〜${block.endTime || ''}`),
            React.createElement('div', { style: { flex: 1 } },
              React.createElement('div', { style: { fontSize: '12px', fontWeight: 600 } }, block.location || ''),
              React.createElement('div', { style: { fontSize: '11px', color: 'var(--text-muted)' } }, block.action || '')
            ),
            isCurrent && React.createElement('span', {
              style: { fontSize: '10px', padding: '2px 6px', borderRadius: '8px', background: '#7c3aed', color: '#fff', alignSelf: 'center', fontWeight: 700 },
            }, 'NOW')
          );
        })
      ),

      // 到着テーブル
      demandSchedule.available && demandSchedule.transitArrivals.length > 0 && React.createElement('div', {
        style: { marginBottom: '16px' },
      },
        React.createElement('div', { style: { fontSize: '12px', fontWeight: 600, color: '#ec4899', marginBottom: '8px' } }, '到着便一覧'),
        React.createElement('div', { style: { borderRadius: '8px', overflow: 'hidden', border: '1px solid rgba(255,255,255,0.06)' } },
          demandSchedule.transitArrivals.map((arr, i) => {
            const now = new Date();
            const nowMin = now.getHours() * 60 + now.getMinutes();
            const p = (arr.arrivalTime || '00:00').split(':');
            const arrMin = parseInt(p[0], 10) * 60 + parseInt(p[1], 10);
            const isPast = arrMin < nowMin;
            return React.createElement('div', {
              key: i,
              style: {
                display: 'flex', justifyContent: 'space-between', alignItems: 'center',
                padding: '8px 10px', fontSize: '12px',
                background: i % 2 === 0 ? 'rgba(255,255,255,0.02)' : 'transparent',
                opacity: isPast ? 0.4 : 1,
              },
            },
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px', color: '#ec4899' } },
                  (arr.type || '').includes('バス') ? 'directions_bus' : 'train'
                ),
                React.createElement('span', { style: { fontWeight: 600 } }, `${arr.type || ''} ${arr.line || ''}`),
                React.createElement('span', { style: { color: 'var(--text-muted)', fontSize: '11px' } }, `(${arr.origin || ''})`)
              ),
              React.createElement('div', { style: { fontWeight: 700, color: isPast ? 'var(--text-muted)' : '#ec4899' } }, arr.arrivalTime || '')
            );
          })
        )
      ),

      // 病院ウィンドウ
      demandSchedule.available && demandSchedule.hospitalWindows.length > 0 && React.createElement('div', null,
        React.createElement('div', { style: { fontSize: '12px', fontWeight: 600, color: '#10b981', marginBottom: '8px' } }, '病院外来ピーク'),
        demandSchedule.hospitalWindows.map((hw, i) =>
          React.createElement('div', {
            key: i,
            style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '6px 0', borderBottom: '1px solid rgba(255,255,255,0.04)' },
          },
            React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px', color: '#10b981' } }, 'local_hospital'),
              React.createElement('span', { style: { fontSize: '12px', fontWeight: 500 } }, hw.name || '')
            ),
            React.createElement('span', { style: { fontSize: '12px', fontWeight: 600, color: '#10b981' } },
              `${hw.peakStart || ''} 〜 ${hw.peakEnd || ''}`
            )
          )
        )
      ),

      // データなし
      geminiApiKey && !demandLoading && !demandSchedule.available && React.createElement('div', {
        style: { padding: '16px', textAlign: 'center', color: 'var(--text-muted)', fontSize: 'var(--font-size-xs)' },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '28px', display: 'block', marginBottom: '6px' } }, 'schedule'),
        '「取得」ボタンを押すと本日の需要予測が表示されます'
      )
    ),

    // 他カテゴリ コンテンツエリア
    activeTab !== 'demand' && (activeData.loading
      ? React.createElement(Card, null,
          React.createElement('div', {
            style: {
              padding: 'var(--space-xl)', textAlign: 'center',
              display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '10px',
            },
          },
            React.createElement('span', {
              className: 'material-icons-round',
              style: { fontSize: '36px', color: activeCat ? `rgb(${activeCat.color})` : '#999', animation: 'spin 1s linear infinite' },
            }, 'sync'),
            React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)' } },
              (activeCat ? activeCat.label : '') + 'の情報を取得中...'
            )
          )
        )
      : activeData.error
        ? React.createElement(Card, null,
            React.createElement('div', {
              style: {
                padding: '12px', borderRadius: '8px',
                background: 'rgba(229,57,53,0.08)', border: '1px solid rgba(229,57,53,0.2)',
                display: 'flex', alignItems: 'center', gap: '8px',
              },
            },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--color-danger)' } }, 'error'),
              React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-danger)' } }, activeData.error)
            )
          )
        : activeData.result
          ? React.createElement(Card, null,
              // ヘッダー: カテゴリ名 + 取得時刻 + 再取得ボタン
              React.createElement('div', {
                style: {
                  display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                  marginBottom: '12px', paddingBottom: '10px',
                  borderBottom: '1px solid rgba(255,255,255,0.06)',
                },
              },
                React.createElement('div', {
                  style: { display: 'flex', alignItems: 'center', gap: '8px' },
                },
                  React.createElement('span', {
                    className: 'material-icons-round',
                    style: { fontSize: '20px', color: `rgb(${activeCat.color})` },
                  }, activeCat.icon),
                  React.createElement('div', null,
                    React.createElement('div', { style: { fontWeight: 700, fontSize: '13px', color: 'var(--text-primary)' } },
                      activeCat.label + ' 運行情報'
                    ),
                    activeData.fetchedAt && React.createElement('div', {
                      style: { fontSize: '10px', color: 'var(--text-muted)', marginTop: '1px' },
                    },
                      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '10px', verticalAlign: 'middle', marginRight: '2px' } }, 'schedule'),
                      formatTime(activeData.fetchedAt) + ' に取得'
                    )
                  )
                ),
                React.createElement('button', {
                  onClick: () => handleFetch(activeTab),
                  style: {
                    display: 'flex', alignItems: 'center', gap: '4px',
                    padding: '4px 10px', borderRadius: '6px', border: 'none',
                    background: `rgba(${activeCat.color}, 0.1)`, color: `rgb(${activeCat.color})`,
                    fontSize: '11px', fontWeight: 600, cursor: 'pointer', transition: 'all 0.15s',
                  },
                  onMouseEnter: (e) => { e.currentTarget.style.background = `rgba(${activeCat.color}, 0.2)`; },
                  onMouseLeave: (e) => { e.currentTarget.style.background = `rgba(${activeCat.color}, 0.1)`; },
                },
                  React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'refresh'),
                  '再取得'
                )
              ),

              // 整形済みコンテンツ
              React.createElement('div', {
                style: { maxHeight: '60vh', overflowY: 'auto', padding: '0 2px' },
              }, renderFormattedText(activeData.result)),

              // 免責事項
              React.createElement('div', {
                style: {
                  marginTop: '12px', paddingTop: '8px',
                  borderTop: '1px solid rgba(255,255,255,0.06)',
                  fontSize: '10px', color: 'var(--text-muted)',
                  display: 'flex', alignItems: 'center', gap: '4px',
                },
              },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px' } }, 'info'),
                activeTab === 'bus'
                  ? '※ 2025年12月改正冬ダイヤ準拠。空港バスは月変動あり。最新は各社HPでご確認ください'
                  : '※ AIによる回答です。最新情報は各交通機関の公式サイトでご確認ください'
              )
            )
          : // 未取得状態
            React.createElement(Card, null,
              React.createElement('div', {
                style: {
                  textAlign: 'center', padding: 'var(--space-xl)',
                  display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '10px',
                },
              },
                React.createElement('span', {
                  className: 'material-icons-round',
                  style: { fontSize: '40px', color: `rgb(${activeCat.color})`, opacity: 0.3 },
                }, activeCat.icon),
                React.createElement('div', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)' } },
                  activeCat.label + 'の情報がありません'
                ),
                React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: '11px', lineHeight: 1.5 } },
                  '上のボタンをタップして情報を取得してください'
                ),
                React.createElement(Button, {
                  variant: 'primary',
                  icon: 'download',
                  onClick: () => handleFetch(activeTab),
                  style: { fontSize: '12px', marginTop: '4px' },
                }, activeCat ? (activeCat.label + 'の情報を取得') : '取得')
              )
            ))
  );
};

})();

// ============================================================
// FILE: src/pages/Calendar.jsx
// ============================================================
(function() {
// Calendar.jsx - カレンダーページ
// 日別売上表示と勤務/休日マーキング機能

window.CalendarPage = () => {
  const { useState, useEffect, useCallback, useMemo } = React;
  const createElement = React.createElement;

  const [currentMonth, setCurrentMonth] = useState(() => {
    const now = new Date();
    return new Date(now.getFullYear(), now.getMonth(), 1);
  });
  const [workStatus, setWorkStatus] = useState(() => {
    try {
      return JSON.parse(localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.WORK_STATUS) || '{}');
    } catch { return {}; }
  });
  const [selectedDate, setSelectedDate] = useState(null);

  // 勤務状態をlocalStorageに保存
  const saveWorkStatus = useCallback((newStatus) => {
    setWorkStatus(newStatus);
    localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.WORK_STATUS, JSON.stringify(newStatus));
  }, []);

  // 売上データを日別に集計
  const dailyRevenue = useMemo(() => {
    const entries = DataService.getEntries();
    const map = {};
    entries.forEach(e => {
      if (!e.date) return;
      if (!map[e.date]) map[e.date] = { total: 0, count: 0 };
      map[e.date].total += (e.amount || 0);
      map[e.date].count += 1;
    });
    return map;
  }, [currentMonth]);

  // シフトデータ
  const shifts = useMemo(() => {
    try {
      return JSON.parse(localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.SHIFTS) || '[]');
    } catch { return []; }
  }, [currentMonth]);

  // カレンダーグリッド生成
  const calendarDays = useMemo(() => {
    const year = currentMonth.getFullYear();
    const month = currentMonth.getMonth();
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startDow = firstDay.getDay(); // 0=日
    const daysInMonth = lastDay.getDate();

    const days = [];
    // 前月の空セル
    for (let i = 0; i < startDow; i++) days.push(null);
    // 当月の日
    for (let d = 1; d <= daysInMonth; d++) {
      const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
      const info = JapaneseHolidays.getDateInfo(dateStr);
      const rev = dailyRevenue[dateStr];
      days.push({
        day: d,
        dateStr,
        dayOfWeek: info.dayOfWeek,
        holiday: info.holiday,
        isHoliday: info.isHoliday,
        isSunday: info.isSunday,
        isSaturday: info.isSaturday,
        revenue: rev ? rev.total : 0,
        count: rev ? rev.count : 0,
        status: workStatus[dateStr] || null,
      });
    }
    return days;
  }, [currentMonth, dailyRevenue, workStatus]);

  // 今日の日付文字列
  const todayStr = useMemo(() => getLocalDateString(), []);

  // 月間サマリー
  const monthlySummary = useMemo(() => {
    let workDays = 0, offDays = 0, totalRevenue = 0, workDayRevenue = 0;
    calendarDays.forEach(d => {
      if (!d) return;
      if (d.status === 'work') {
        workDays++;
        workDayRevenue += d.revenue;
      }
      if (d.status === 'off') offDays++;
      totalRevenue += d.revenue;
    });
    return {
      workDays,
      offDays,
      totalRevenue,
      avgDaily: workDays > 0 ? Math.round(workDayRevenue / workDays) : 0,
    };
  }, [calendarDays]);

  // 選択日の詳細
  const selectedDayData = useMemo(() => {
    if (!selectedDate) return null;
    const day = calendarDays.find(d => d && d.dateStr === selectedDate);
    if (!day) return null;

    // シフト情報
    const dayShifts = shifts.filter(s => {
      if (!s.startTime) return false;
      const sDate = s.startTime.split('T')[0];
      return sDate === selectedDate;
    });

    return { ...day, shifts: dayShifts };
  }, [selectedDate, calendarDays, shifts]);

  // 月切替
  const goMonth = useCallback((delta) => {
    setCurrentMonth(prev => new Date(prev.getFullYear(), prev.getMonth() + delta, 1));
    setSelectedDate(null);
  }, []);

  const goToday = useCallback(() => {
    const now = new Date();
    setCurrentMonth(new Date(now.getFullYear(), now.getMonth(), 1));
    setSelectedDate(todayStr);
  }, [todayStr]);

  // 勤務/休日切替
  const toggleWorkStatus = useCallback((dateStr, status) => {
    const newStatus = { ...workStatus };
    if (newStatus[dateStr] === status) {
      delete newStatus[dateStr];
    } else {
      newStatus[dateStr] = status;
    }
    saveWorkStatus(newStatus);
  }, [workStatus, saveWorkStatus]);

  // 金額短縮表示
  const shortAmount = (n) => {
    if (n === 0) return '';
    if (n >= 10000) return `${Math.floor(n / 10000)}万`;
    if (n >= 1000) return `${Math.floor(n / 1000)}千`;
    return `${n}`;
  };

  const yearMonth = `${currentMonth.getFullYear()}年${currentMonth.getMonth() + 1}月`;
  const dowLabels = ['日', '月', '火', '水', '木', '金', '土'];

  return createElement('div', null,
    // ページタイトル
    createElement('h1', { className: 'page-title' },
      createElement('span', { className: 'material-icons-round' }, 'calendar_month'),
      'カレンダー'
    ),

    // 月ナビゲーション
    createElement('div', {
      style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: 'var(--space-md)', gap: 'var(--space-sm)' }
    },
      createElement('button', {
        className: 'btn btn--secondary',
        onClick: () => goMonth(-1),
        style: { minWidth: 40, padding: '6px 10px' }
      }, createElement('span', { className: 'material-icons-round', style: { fontSize: 20 } }, 'chevron_left')),
      createElement('span', {
        style: { fontWeight: 700, fontSize: 'var(--font-size-lg)' }
      }, yearMonth),
      createElement('button', {
        className: 'btn btn--secondary',
        onClick: () => goMonth(1),
        style: { minWidth: 40, padding: '6px 10px' }
      }, createElement('span', { className: 'material-icons-round', style: { fontSize: 20 } }, 'chevron_right')),
      createElement('button', {
        className: 'btn btn--secondary',
        onClick: goToday,
        style: { padding: '6px 12px', fontSize: 'var(--font-size-sm)' }
      }, '今月')
    ),

    // カレンダーグリッド
    createElement('div', {
      style: {
        display: 'grid',
        gridTemplateColumns: 'repeat(7, 1fr)',
        gap: 1,
        background: 'var(--border-color)',
        borderRadius: 'var(--border-radius)',
        overflow: 'hidden',
        marginBottom: 'var(--space-lg)',
      }
    },
      // 曜日ヘッダー
      ...dowLabels.map((dow, i) =>
        createElement('div', {
          key: 'h' + i,
          style: {
            background: 'var(--bg-card)',
            padding: '6px 2px',
            textAlign: 'center',
            fontWeight: 700,
            fontSize: 'var(--font-size-sm)',
            color: i === 0 ? 'var(--color-error)' : i === 6 ? 'var(--color-info)' : 'var(--text-primary)',
          }
        }, dow)
      ),
      // 日セル
      ...calendarDays.map((d, i) => {
        if (!d) {
          return createElement('div', {
            key: 'e' + i,
            style: { background: 'var(--bg-card)', padding: 4 }
          });
        }
        const isToday = d.dateStr === todayStr;
        const isSelected = d.dateStr === selectedDate;
        return createElement('div', {
          key: d.dateStr,
          onClick: () => setSelectedDate(d.dateStr === selectedDate ? null : d.dateStr),
          style: {
            background: isSelected ? 'rgba(33,150,243,0.15)' : isToday ? 'rgba(0,200,83,0.08)' : 'var(--bg-card)',
            padding: '4px 2px',
            minHeight: 54,
            cursor: 'pointer',
            position: 'relative',
            borderLeft: isToday ? '3px solid var(--color-accent)' : 'none',
          }
        },
          // 日付
          createElement('div', {
            style: {
              fontSize: 'var(--font-size-sm)',
              fontWeight: isToday ? 700 : 400,
              color: d.isHoliday || d.isSunday ? 'var(--color-error)' : d.isSaturday ? 'var(--color-info)' : 'var(--text-primary)',
              marginBottom: 1,
              textAlign: 'center',
            }
          }, d.day),
          // 売上金額
          d.revenue > 0 && createElement('div', {
            style: {
              fontSize: 10,
              color: 'var(--color-accent)',
              textAlign: 'center',
              fontWeight: 600,
              lineHeight: 1.2,
            }
          }, shortAmount(d.revenue)),
          // 勤務/休日マーク
          d.status && createElement('div', {
            style: {
              width: 8, height: 8,
              borderRadius: '50%',
              background: d.status === 'work' ? 'var(--color-accent)' : 'var(--color-warning)',
              margin: '2px auto 0',
            }
          })
        );
      })
    ),

    // 選択日の詳細パネル
    selectedDayData && createElement('div', {
      className: 'card',
      style: { marginBottom: 'var(--space-lg)', padding: 'var(--space-md)' }
    },
      createElement('div', {
        style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 'var(--space-sm)' }
      },
        createElement('div', null,
          createElement('strong', { style: { fontSize: 'var(--font-size-lg)' } },
            `${selectedDayData.day}日（${selectedDayData.dayOfWeek}）`
          ),
          selectedDayData.holiday && createElement('span', {
            style: { marginLeft: 'var(--space-sm)', color: 'var(--color-error)', fontSize: 'var(--font-size-sm)' }
          }, selectedDayData.holiday)
        )
      ),

      // 勤務/休日ボタン
      createElement('div', {
        style: { display: 'flex', gap: 'var(--space-sm)', marginBottom: 'var(--space-md)' }
      },
        createElement('button', {
          className: `btn ${selectedDayData.status === 'work' ? 'btn--primary' : 'btn--secondary'}`,
          onClick: () => toggleWorkStatus(selectedDate, 'work'),
          style: { flex: 1, padding: '8px 12px' }
        },
          createElement('span', { className: 'material-icons-round', style: { fontSize: 16, marginRight: 4 } }, 'work'),
          '勤務'
        ),
        createElement('button', {
          className: `btn ${selectedDayData.status === 'off' ? 'btn--secondary' : 'btn--secondary'}`,
          onClick: () => toggleWorkStatus(selectedDate, 'off'),
          style: Object.assign({ flex: 1, padding: '8px 12px' },
            selectedDayData.status === 'off' ? { background: 'var(--color-warning)', borderColor: 'var(--color-warning)' } : {}
          )
        },
          createElement('span', { className: 'material-icons-round', style: { fontSize: 16, marginRight: 4 } }, 'weekend'),
          '休日'
        )
      ),

      // 売上情報
      createElement('div', {
        style: { display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: 'var(--space-sm)', marginBottom: 'var(--space-sm)' }
      },
        createElement('div', { style: { textAlign: 'center' } },
          createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-muted)' } }, '件数'),
          createElement('div', { style: { fontSize: 'var(--font-size-lg)', fontWeight: 700 } }, selectedDayData.count)
        ),
        createElement('div', { style: { textAlign: 'center' } },
          createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-muted)' } }, '合計'),
          createElement('div', { style: { fontSize: 'var(--font-size-lg)', fontWeight: 700, color: 'var(--color-accent)' } },
            selectedDayData.revenue > 0 ? `${selectedDayData.revenue.toLocaleString()}円` : '−'
          )
        ),
        createElement('div', { style: { textAlign: 'center' } },
          createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-muted)' } }, '平均'),
          createElement('div', { style: { fontSize: 'var(--font-size-lg)', fontWeight: 700 } },
            selectedDayData.count > 0 ? `${Math.round(selectedDayData.revenue / selectedDayData.count).toLocaleString()}円` : '−'
          )
        )
      ),

      // シフト記録
      selectedDayData.shifts.length > 0 && createElement('div', {
        style: { borderTop: '1px solid var(--border-color)', paddingTop: 'var(--space-sm)', marginTop: 'var(--space-sm)' }
      },
        createElement('div', {
          style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-muted)', marginBottom: 4 }
        }, 'シフト記録'),
        ...selectedDayData.shifts.map((s, i) => {
          const start = s.startTime ? new Date(s.startTime).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' }) : '?';
          const end = s.endTime ? new Date(s.endTime).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' }) : '勤務中';
          return createElement('div', {
            key: i,
            style: { fontSize: 'var(--font-size-sm)', padding: '2px 0' }
          },
            createElement('span', { className: 'material-icons-round', style: { fontSize: 14, verticalAlign: 'middle', marginRight: 4 } }, 'schedule'),
            `${start} 〜 ${end}`
          );
        })
      )
    ),

    // 月間サマリーカード
    createElement('div', {
      className: 'card',
      style: { padding: 'var(--space-md)' }
    },
      createElement('div', {
        style: { fontWeight: 700, marginBottom: 'var(--space-sm)', display: 'flex', alignItems: 'center', gap: 'var(--space-xs)' }
      },
        createElement('span', { className: 'material-icons-round', style: { fontSize: 18, color: 'var(--color-secondary)' } }, 'summarize'),
        `${yearMonth} サマリー`
      ),
      createElement('div', {
        style: { display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: 'var(--space-md)' }
      },
        createElement('div', null,
          createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-muted)' } }, '勤務日数'),
          createElement('div', { style: { fontSize: 'var(--font-size-xl)', fontWeight: 700 } }, `${monthlySummary.workDays}日`)
        ),
        createElement('div', null,
          createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-muted)' } }, '休日数'),
          createElement('div', { style: { fontSize: 'var(--font-size-xl)', fontWeight: 700 } }, `${monthlySummary.offDays}日`)
        ),
        createElement('div', null,
          createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-muted)' } }, '月間売上合計'),
          createElement('div', { style: { fontSize: 'var(--font-size-xl)', fontWeight: 700, color: 'var(--color-accent)' } },
            monthlySummary.totalRevenue > 0 ? `${monthlySummary.totalRevenue.toLocaleString()}円` : '−'
          )
        ),
        createElement('div', null,
          createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-muted)' } }, '勤務日平均日収'),
          createElement('div', { style: { fontSize: 'var(--font-size-xl)', fontWeight: 700 } },
            monthlySummary.avgDaily > 0 ? `${monthlySummary.avgDaily.toLocaleString()}円` : '−'
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/Info.jsx
// ============================================================
(function() {
// Info.jsx - 情報ページ（交通機関 + イベント + ホテル統合）

// ホテル混雑状況コンポーネント
window.HotelStatusPage = () => {
  const { useState, useMemo, useEffect, useCallback } = React;
  const createElement = React.createElement;
  const { geminiApiKey } = useAppContext();
  const [now, setNow] = useState(new Date());
  const [priceLoading, setPriceLoading] = useState(false);
  const [priceError, setPriceError] = useState('');
  const [priceAnalysis, setPriceAnalysis] = useState(() => DataService.analyzeHotelPrices());

  // 1分ごとに自動更新
  useEffect(() => {
    const timer = setInterval(() => setNow(new Date()), 60000);
    return () => clearInterval(timer);
  }, []);

  const locs = APP_CONSTANTS.KNOWN_LOCATIONS.asahikawa;
  const hotels = locs.hotels || [];
  const peaks = locs.hotelPeakWindows || {};

  const currentMinutes = now.getHours() * 60 + now.getMinutes();
  const timeStr = now.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });

  function timeToMin(hhmm) {
    const [h, m] = hhmm.split(':').map(Number);
    return h * 60 + m;
  }

  // 各ピーク時間帯のアクティブ状態を算出
  const windowStatus = useMemo(() => {
    return Object.entries(peaks).map(([key, win]) => {
      const startMin = timeToMin(win.start);
      const endMin = timeToMin(win.end);
      const isCurrent = currentMinutes >= startMin && currentMinutes <= endMin;
      const isSoon = !isCurrent && currentMinutes >= startMin - 30 && currentMinutes < startMin;
      const isPast = currentMinutes > endMin + 15;
      let progress = 0;
      if (isCurrent) progress = Math.min(1, (currentMinutes - startMin) / (endMin - startMin));
      return { key, ...win, isCurrent, isSoon, isPast, progress };
    });
  }, [currentMinutes]);

  // 各ホテルの現在の需要レベルを算出
  const hotelStatus = useMemo(() => {
    const maxRooms = 355;
    return hotels.map(hotel => {
      let totalWeight = 0;
      let activeWindow = null;
      Object.values(peaks).forEach(win => {
        const startMin = timeToMin(win.start);
        const endMin = timeToMin(win.end);
        let tw = 0;
        if (currentMinutes >= startMin && currentMinutes <= endMin) tw = 1.0;
        else if (currentMinutes >= startMin - 30 && currentMinutes < startMin) tw = (currentMinutes - (startMin - 30)) / 30;
        else if (currentMinutes > endMin && currentMinutes <= endMin + 30) tw = 1.0 - (currentMinutes - endMin) / 30;
        if (tw > 0) {
          const distFactor = hotel.distKm >= 0.8 ? 1.0 : hotel.distKm >= 0.4 ? 0.6 : 0.3;
          const roomFactor = hotel.rooms / maxRooms;
          const w = win.weight * tw * distFactor * roomFactor;
          if (w > totalWeight) {
            totalWeight = w;
            activeWindow = win.label;
          }
        }
      });
      const score = Math.min(100, Math.round(totalWeight * 100));
      return { ...hotel, score, activeWindow };
    }).sort((a, b) => b.score - a.score);
  }, [currentMinutes]);

  // 価格分析データとホテル需要をマージ
  const hotelWithPrices = useMemo(() => {
    if (!priceAnalysis.hasData) return hotelStatus;
    const priceMap = {};
    priceAnalysis.hotels.forEach(p => { priceMap[p.name] = p; });
    return hotelStatus.map(h => ({
      ...h,
      priceInfo: priceMap[h.name] || null,
    }));
  }, [hotelStatus, priceAnalysis]);

  // 一括取得ハンドラー
  const handleFetchPrices = useCallback(async () => {
    if (!geminiApiKey) { setPriceError('Gemini APIキーを設定してください'); return; }
    setPriceLoading(true);
    setPriceError('');
    try {
      const result = await GeminiService.fetchHotelPrices(geminiApiKey, hotels);
      if (!result.success) { setPriceError(result.error); return; }
      DataService.saveHotelPrices(result.prices);
      setPriceAnalysis(DataService.analyzeHotelPrices());
    } catch (e) {
      setPriceError(`取得エラー: ${e.message}`);
    } finally {
      setPriceLoading(false);
    }
  }, [geminiApiKey, hotels]);

  const levelConfig = {
    very_high: { label: '非常に高い', color: '#ef4444', bg: 'rgba(239,68,68,0.12)' },
    high: { label: '高い', color: '#f59e0b', bg: 'rgba(245,158,11,0.12)' },
    medium: { label: '中程度', color: '#3b82f6', bg: 'rgba(59,130,246,0.12)' },
    low: { label: '低い', color: '#6b7280', bg: 'rgba(107,114,128,0.12)' },
  };

  const trendConfig = {
    high: { icon: 'trending_up', label: '高騰', color: '#ef4444' },
    rising: { icon: 'trending_up', label: 'やや高い', color: '#f59e0b' },
    stable: { icon: 'trending_flat', label: '通常', color: '#3b82f6' },
    falling: { icon: 'trending_down', label: 'やや安い', color: '#22c55e' },
    low: { icon: 'trending_down', label: '安い', color: '#22c55e' },
  };

  const occupancyConfig = {
    very_high: { label: '非常に高い', color: '#ef4444' },
    high: { label: '高い', color: '#f59e0b' },
    normal: { label: '通常', color: '#3b82f6' },
    low: { label: '低い', color: '#22c55e' },
    unknown: { label: '不明', color: '#6b7280' },
  };

  const activeWindows = windowStatus.filter(w => w.isCurrent || w.isSoon);
  const activeHotels = hotelStatus.filter(h => h.score > 0);

  // 高稼働ホテル数
  const highOccupancyCount = priceAnalysis.hasData
    ? priceAnalysis.hotels.filter(h => h.occupancyEstimate === 'high' || h.occupancyEstimate === 'very_high').length : 0;

  return createElement('div', null,
    createElement('h1', { className: 'page-title' },
      createElement('span', { className: 'material-icons-round' }, 'hotel'),
      'ホテル混雑状況'
    ),

    // 現在時刻カード
    createElement('div', {
      className: 'card',
      style: { padding: 'var(--space-md)', marginBottom: 'var(--space-md)', textAlign: 'center' },
    },
      createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-muted)', marginBottom: 4 } }, '現在時刻'),
      createElement('div', { style: { fontSize: 'var(--font-size-xl)', fontWeight: 700 } }, timeStr),
      createElement('div', {
        style: { marginTop: 6, fontSize: 'var(--font-size-sm)', color: activeWindows.length > 0 ? '#ef4444' : 'var(--text-muted)' },
      },
        activeWindows.length > 0
          ? `${activeWindows.map(w => `${w.label}${w.isCurrent ? '（進行中）' : '（まもなく）'}`).join('、')}`
          : '現在アクティブなピーク時間帯はありません'
      )
    ),

    // ホテル価格取得カード
    createElement('div', {
      className: 'card',
      style: { padding: 'var(--space-md)', marginBottom: 'var(--space-md)' },
    },
      createElement('div', {
        style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: 'var(--space-sm)' },
      },
        createElement('div', { style: { display: 'flex', alignItems: 'center', gap: 'var(--space-xs)', fontWeight: 700 } },
          createElement('span', { className: 'material-icons-round', style: { fontSize: 18, color: '#a78bfa' } }, 'payments'),
          '料金情報'
        ),
        createElement('button', {
          className: `btn btn--primary`,
          onClick: handleFetchPrices,
          disabled: priceLoading || !geminiApiKey,
          style: { padding: '6px 14px', fontSize: 'var(--font-size-xs)', display: 'flex', alignItems: 'center', gap: 4 },
        },
          priceLoading && createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: 14, animation: 'spin 1s linear infinite' },
          }, 'sync'),
          priceLoading ? '取得中...' : '一括取得'
        )
      ),
      priceError && createElement('div', {
        style: { fontSize: 'var(--font-size-xs)', color: '#ef4444', marginBottom: 'var(--space-xs)', padding: '4px 8px', background: 'rgba(239,68,68,0.1)', borderRadius: 4 },
      }, priceError),
      !geminiApiKey && createElement('div', {
        style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', padding: '4px 0' },
      }, 'Gemini APIキーを設定画面で入力してください'),
      priceAnalysis.hasData && createElement('div', {
        style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', display: 'flex', gap: 12, flexWrap: 'wrap' },
      },
        createElement('span', null, `蓄積: ${priceAnalysis.recordCount}回`),
        createElement('span', null, `最終: ${priceAnalysis.latestFetch ? new Date(priceAnalysis.latestFetch).toLocaleString('ja-JP', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) : '-'}`),
        highOccupancyCount > 0 && createElement('span', { style: { color: '#ef4444', fontWeight: 600 } }, `高稼働: ${highOccupancyCount}件`)
      )
    ),

    // 稼働率分析サマリー（価格データあり時のみ表示）
    priceAnalysis.hasData && priceAnalysis.recordCount >= 2 && createElement('div', {
      className: 'card',
      style: { padding: 'var(--space-md)', marginBottom: 'var(--space-md)', borderLeft: '3px solid #a78bfa' },
    },
      createElement('div', {
        style: { fontWeight: 700, marginBottom: 'var(--space-sm)', display: 'flex', alignItems: 'center', gap: 'var(--space-xs)' },
      },
        createElement('span', { className: 'material-icons-round', style: { fontSize: 18, color: '#a78bfa' } }, 'analytics'),
        '稼働率分析'
      ),
      createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-muted)', marginBottom: 8 } },
        '料金変動から推定した稼働率（料金高騰 = 高稼働 = タクシー需要増）'
      ),
      ...priceAnalysis.hotels.filter(h => h.occupancyEstimate !== 'normal' && h.occupancyEstimate !== 'unknown').slice(0, 5).map(h => {
        const oc = occupancyConfig[h.occupancyEstimate] || occupancyConfig.unknown;
        const tc = trendConfig[h.trend] || trendConfig.stable;
        return createElement('div', {
          key: h.name,
          style: { display: 'flex', alignItems: 'center', gap: 8, padding: '6px 0', borderBottom: '1px solid var(--border-color)' },
        },
          createElement('span', { className: 'material-icons-round', style: { fontSize: 16, color: tc.color } }, tc.icon),
          createElement('div', { style: { flex: 1, minWidth: 0 } },
            createElement('div', {
              style: { fontSize: 'var(--font-size-sm)', fontWeight: 600, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' },
            }, h.name),
            createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } },
              `${h.latest ? h.latest.toLocaleString() + '円' : '-'} (平均: ${h.avg ? h.avg.toLocaleString() + '円' : '-'})`
            )
          ),
          createElement('div', { style: { textAlign: 'right' } },
            createElement('div', { style: { fontSize: 'var(--font-size-xs)', fontWeight: 700, color: oc.color } }, `稼働: ${oc.label}`),
            createElement('div', { style: { fontSize: 10, color: tc.color } }, tc.label)
          )
        );
      }),
      priceAnalysis.hotels.filter(h => h.occupancyEstimate !== 'normal' && h.occupancyEstimate !== 'unknown').length === 0 &&
        createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-muted)', padding: '8px 0' } },
          '全ホテルが通常稼働率です。料金データが蓄積されると変動が表示されます。'
        )
    ),

    // ピーク時間帯タイムライン
    createElement('div', {
      className: 'card',
      style: { padding: 'var(--space-md)', marginBottom: 'var(--space-md)' },
    },
      createElement('div', {
        style: { fontWeight: 700, marginBottom: 'var(--space-sm)', display: 'flex', alignItems: 'center', gap: 'var(--space-xs)' },
      },
        createElement('span', { className: 'material-icons-round', style: { fontSize: 18, color: 'var(--color-secondary)' } }, 'schedule'),
        'ピーク時間帯'
      ),
      ...windowStatus.map(w =>
        createElement('div', {
          key: w.key,
          style: {
            display: 'flex', alignItems: 'center', gap: 10, padding: '8px 0',
            borderBottom: '1px solid var(--border-color)', opacity: w.isPast ? 0.4 : 1,
          },
        },
          createElement('div', {
            style: {
              minWidth: 52, textAlign: 'center', fontSize: 10, fontWeight: 700, padding: '3px 6px', borderRadius: 4,
              background: w.isCurrent ? 'rgba(239,68,68,0.15)' : w.isSoon ? 'rgba(245,158,11,0.15)' : w.isPast ? 'rgba(107,114,128,0.1)' : 'rgba(59,130,246,0.1)',
              color: w.isCurrent ? '#ef4444' : w.isSoon ? '#f59e0b' : w.isPast ? '#6b7280' : '#3b82f6',
            },
          }, w.isCurrent ? 'NOW' : w.isSoon ? 'SOON' : w.isPast ? '終了' : '待機'),
          createElement('div', { style: { flex: 1 } },
            createElement('div', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)' } }, w.label),
            createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, `${w.start} 〜 ${w.end}`)
          ),
          w.isCurrent && createElement('div', {
            style: { width: 60, height: 6, borderRadius: 3, background: 'rgba(255,255,255,0.1)', overflow: 'hidden' },
          },
            createElement('div', {
              style: { width: `${Math.round(w.progress * 100)}%`, height: '100%', background: '#ef4444', borderRadius: 3, transition: 'width 0.5s' },
            })
          )
        )
      )
    ),

    // ホテル一覧（価格情報付き）
    createElement('div', {
      className: 'card',
      style: { padding: 'var(--space-md)' },
    },
      createElement('div', {
        style: { fontWeight: 700, marginBottom: 'var(--space-sm)', display: 'flex', alignItems: 'center', justifyContent: 'space-between' },
      },
        createElement('div', { style: { display: 'flex', alignItems: 'center', gap: 'var(--space-xs)' } },
          createElement('span', { className: 'material-icons-round', style: { fontSize: 18, color: 'var(--color-secondary)' } }, 'apartment'),
          `ホテル一覧（${hotels.length}件）`
        ),
        createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } },
          `タクシー需要あり: ${activeHotels.length}件`
        )
      ),
      ...hotelWithPrices.map(h => {
        const lc = levelConfig[h.demandLevel] || levelConfig.low;
        const barWidth = Math.max(2, h.score);
        const pi = h.priceInfo;
        const tc = pi ? (trendConfig[pi.trend] || trendConfig.stable) : null;
        return createElement('div', {
          key: h.name,
          style: {
            display: 'flex', alignItems: 'center', gap: 10, padding: '8px 0',
            borderBottom: '1px solid var(--border-color)',
          },
        },
          // 需要レベルバッジ
          createElement('div', {
            style: {
              minWidth: 28, height: 28, display: 'flex', alignItems: 'center', justifyContent: 'center',
              borderRadius: 6, background: lc.bg, fontSize: 14,
            },
          },
            createElement('span', { className: 'material-icons-round', style: { fontSize: 18, color: lc.color } }, 'hotel')
          ),
          // ホテル情報
          createElement('div', { style: { flex: 1, minWidth: 0 } },
            createElement('div', {
              style: { fontWeight: 600, fontSize: 'var(--font-size-sm)', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' },
            }, h.name),
            createElement('div', {
              style: { display: 'flex', gap: 8, fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: 2, flexWrap: 'wrap' },
            },
              createElement('span', null, `${h.rooms}室`),
              createElement('span', null, `駅${h.distKm}km`),
              createElement('span', { style: { color: lc.color } }, lc.label),
              h.activeWindow && createElement('span', { style: { color: '#ef4444', fontWeight: 600 } }, h.activeWindow),
              pi && pi.latest > 0 && createElement('span', { style: { color: tc.color, fontWeight: 600 } },
                `${pi.latest.toLocaleString()}円`,
                pi.trend !== 'stable' ? ` ${tc.label}` : ''
              )
            )
          ),
          // スコアバー
          createElement('div', { style: { width: 60, textAlign: 'right' } },
            createElement('div', {
              style: { width: 60, height: 6, borderRadius: 3, background: 'rgba(255,255,255,0.08)', overflow: 'hidden', marginBottom: 2 },
            },
              createElement('div', {
                style: { width: `${barWidth}%`, height: '100%', borderRadius: 3, background: h.score > 50 ? '#ef4444' : h.score > 20 ? '#f59e0b' : h.score > 0 ? '#3b82f6' : '#6b7280', transition: 'width 0.5s' },
              })
            ),
            h.score > 0 && createElement('div', {
              style: { fontSize: 10, fontWeight: 700, color: h.score > 50 ? '#ef4444' : h.score > 20 ? '#f59e0b' : '#3b82f6' },
            }, `${h.score}`)
          )
        );
      })
    )
  );
};

window.InfoPage = () => {
  const { useState } = React;
  const createElement = React.createElement;
  const [tab, setTab] = useState('transit');

  const tabs = [
    { id: 'transit', label: '交通機関', icon: 'directions_transit' },
    { id: 'hotel', label: 'ホテル', icon: 'hotel' },
    { id: 'events', label: 'イベント', icon: 'event' },
  ];

  return createElement('div', null,
    createElement('h1', { className: 'page-title' },
      createElement('span', { className: 'material-icons-round' }, 'info'),
      '情報'
    ),
    // タブバー
    createElement('div', {
      style: {
        display: 'flex',
        gap: 'var(--space-xs)',
        marginBottom: 'var(--space-lg)',
        background: 'var(--bg-card)',
        borderRadius: 'var(--border-radius)',
        padding: 4,
      }
    },
      ...tabs.map(t =>
        createElement('button', {
          key: t.id,
          className: `btn ${tab === t.id ? 'btn--primary' : 'btn--ghost'}`,
          onClick: () => setTab(t.id),
          style: { flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 4, padding: '8px 10px', fontSize: '13px' }
        },
          createElement('span', { className: 'material-icons-round', style: { fontSize: 17 } }, t.icon),
          t.label
        )
      )
    ),
    // 子ページ（タイトルは非表示）
    createElement('div', { className: 'info-page-content' },
      tab === 'transit'
        ? createElement(TransitInfoPage)
        : tab === 'hotel'
        ? createElement(HotelStatusPage)
        : createElement(EventsPage)
    )
  );
};

})();

// ============================================================
// FILE: src/pages/Events.jsx
// ============================================================
(function() {
// Events.jsx - イベント記録ページ
// 周辺イベントの記録CRUD（RivalRide.jsx パターン踏襲）
window.EventsPage = () => {
  const { useState, useEffect, useCallback, useRef, useMemo } = React;

  const todayDefault = getLocalDateString();

  const getNowTime = TaxiApp.utils.getNowTime;

  const [refreshKey, setRefreshKey] = useState(0);
  const [form, setForm] = useState({
    name: '', date: todayDefault, startTime: '', endTime: '',
    location: '', locationCoords: null, scale: '', impact: '', memo: '',
  });
  const [errors, setErrors] = useState([]);
  const [saved, setSaved] = useState(false);
  const [gpsLoading, setGpsLoading] = useState(false);
  const [gpsInfo, setGpsInfo] = useState(null);

  const { apiKey, geminiApiKey } = useAppContext();

  // Gemini イベント検索
  const [geminiQuery, setGeminiQuery] = useState('');
  const [geminiArea, setGeminiArea] = useState('');
  const [geminiLoading, setGeminiLoading] = useState(false);
  const [geminiResult, setGeminiResult] = useState(null);
  const [geminiError, setGeminiError] = useState(null);

  const handleGeminiSearch = useCallback(async () => {
    if (!geminiQuery.trim()) return;
    setGeminiLoading(true);
    setGeminiError(null);
    setGeminiResult(null);
    const result = await GeminiService.searchEvents(geminiApiKey, geminiQuery.trim(), geminiArea.trim());
    setGeminiLoading(false);
    if (result.success) {
      setGeminiResult(result.text);
    } else {
      setGeminiError(result.error);
    }
  }, [geminiApiKey, geminiQuery, geminiArea]);

  const quickEventQueries = [
    '今週末の東京都内のイベント',
    '本日のコンサート・ライブ情報',
    '今月の大規模スポーツイベント',
    '近日中の花火大会・お祭り',
  ];

  const entries = useMemo(() => DataService.getEvents(), [refreshKey]);

  // localStorage変更の監視
  useEffect(() => {
    const handleStorage = (e) => {
      if (e.key === APP_CONSTANTS.STORAGE_KEYS.EVENTS) {
        setRefreshKey(k => k + 1);
      }
    };
    window.addEventListener('storage', handleStorage);
    const handleVisibility = () => {
      if (!document.hidden) setRefreshKey(k => k + 1);
    };
    document.addEventListener('visibilitychange', handleVisibility);
    const handleDataChanged = () => setRefreshKey(k => k + 1);
    window.addEventListener('taxi-data-changed', handleDataChanged);
    return () => {
      window.removeEventListener('storage', handleStorage);
      document.removeEventListener('visibilitychange', handleVisibility);
      window.removeEventListener('taxi-data-changed', handleDataChanged);
    };
  }, []);

  // GPS逆ジオコーディング
  const getGpsLocation = useCallback(() => {
    if (!navigator.geolocation) {
      setErrors(['このブラウザではGPS機能が使えません']);
      return;
    }
    setGpsLoading(true);
    setErrors([]);
    getAccuratePosition({ accuracyThreshold: 50, timeout: 20000, maxWaitAfterFix: 8000 })
      .then((position) => {
        reverseGeocode(position.coords.latitude, position.coords.longitude);
      })
      .catch((error) => {
        setGpsLoading(false);
        const messages = {
          1: 'GPS使用が許可されていません。ブラウザの設定を確認してください。',
          2: '現在地を取得できませんでした。',
          3: 'GPS取得がタイムアウトしました。',
        };
        setErrors([messages[error.code] || 'GPS取得に失敗しました']);
      });
  }, [apiKey]);

  const reverseGeocode = (lat, lng) => {
    if (apiKey && window.google && window.google.maps) {
      const geocoder = new google.maps.Geocoder();
      geocoder.geocode({ location: { lat, lng } }, (results, status) => {
        setGpsLoading(false);
        if (status === 'OK' && results[0]) {
          const address = formatAddress(results[0]);
          setForm(prev => ({ ...prev, location: address, locationCoords: { lat, lng } }));
          setGpsInfo({ lat, lng, address: results[0].formatted_address.replace(/、日本$/, '').replace(/^日本、/, '') });
        } else {
          nominatimFallback(lat, lng);
        }
      });
    } else {
      nominatimFallback(lat, lng);
    }
  };

  const nominatimFallback = (lat, lng) => {
    const nomUrl = TaxiApp.utils.nominatimUrl(lat, lng, 18);
    fetch(nomUrl)
      .then(res => res.json())
      .then(data => {
        setGpsLoading(false);
        if (data && data.address) {
          const a = data.address;
          const parts = [a.city || a.town || a.village || a.county || '', a.suburb || a.neighbourhood || a.quarter || '', a.road || ''].filter(Boolean);
          const shortAddr = parts.join(' ') || data.display_name.split(',').slice(0, 3).join(' ');
          setForm(prev => ({ ...prev, location: shortAddr, locationCoords: { lat, lng } }));
          setGpsInfo({ lat, lng, address: data.display_name || shortAddr });
        } else {
          const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
          setForm(prev => ({ ...prev, location: coordStr, locationCoords: { lat, lng } }));
          setGpsInfo({ lat, lng, address: null });
        }
      })
      .catch(() => {
        setGpsLoading(false);
        const coordStr = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
        setForm(prev => ({ ...prev, location: coordStr, locationCoords: { lat, lng } }));
        setGpsInfo({ lat, lng, address: null });
      });
  };

  function formatAddress(result) {
    const comps = result.address_components;
    let prefecture = '', city = '', ward = '', town = '', sublocality = '';
    for (const c of comps) {
      if (c.types.includes('administrative_area_level_1')) prefecture = c.long_name;
      if (c.types.includes('locality')) city = c.long_name;
      if (c.types.includes('sublocality_level_1') || c.types.includes('ward')) ward = c.long_name;
      if (c.types.includes('sublocality_level_2')) town = c.long_name;
      if (c.types.includes('sublocality_level_3')) sublocality = c.long_name;
    }
    const parts = [ward || city || prefecture, town, sublocality].filter(Boolean);
    if (parts.length > 0) return parts.join(' ');
    return result.formatted_address.replace(/、日本$/, '').replace(/^日本、/, '');
  }

  const handleSubmit = (e) => {
    e.preventDefault();
    setErrors([]);
    const result = DataService.addEvent(form);
    if (!result.success) {
      setErrors(result.errors);
      return;
    }
    setForm({
      name: '', date: getLocalDateString(), startTime: '', endTime: '',
      location: '', locationCoords: null, scale: '', impact: '', memo: '',
    });
    setGpsInfo(null);
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
    setRefreshKey(k => k + 1);
  };

  const handleDelete = useCallback((id) => {
    DataService.deleteEvent(id);
    setRefreshKey(k => k + 1);
  }, []);

  const handleClearAll = () => {
    if (entries.length === 0) return;
    DataService.clearAllEvents();
    setRefreshKey(k => k + 1);
  };

  const scaleOptions = [
    { value: '小', label: '小', desc: '〜100人' },
    { value: '中', label: '中', desc: '100〜1000人' },
    { value: '大', label: '大', desc: '1000〜10000人' },
    { value: '特大', label: '特大', desc: '10000人〜' },
  ];

  const impactOptions = [
    { value: '需要増', icon: 'trending_up', color: 'var(--color-accent)' },
    { value: '需要減', icon: 'trending_down', color: 'var(--color-danger)' },
    { value: '不明', icon: 'help_outline', color: 'var(--text-muted)' },
  ];

  const gpsButtonStyle = (loading) => ({
    display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '4px',
    padding: '8px 12px', borderRadius: '6px',
    fontSize: '11px', fontWeight: '600',
    color: loading ? 'var(--color-secondary)' : '#fff',
    cursor: loading ? 'wait' : 'pointer',
    border: '1px solid rgba(255,255,255,0.15)',
    background: loading ? 'rgba(249,168,37,0.15)' : 'rgba(26,115,232,0.2)',
    transition: 'all 0.2s ease',
    whiteSpace: 'nowrap', minWidth: '0', flex: '0 0 auto',
  });

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'event'),
      'イベント記録'
    ),

    // 記録件数
    React.createElement(Card, { style: { marginBottom: 'var(--space-lg)', textAlign: 'center' } },
      React.createElement('div', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)' } }, 'イベント記録'),
      React.createElement('div', {
        style: { fontSize: 'var(--font-size-2xl)', fontWeight: 700, color: 'var(--color-primary-light)', margin: '8px 0' },
      }, `${entries.length} 件`),
      React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-xs)' } },
        entries.length > 0 ? `最新: ${entries[0].name} (${entries[0].date})` : 'まだ記録がありません'
      )
    ),

    // Gemini AIイベント検索
    geminiApiKey ? React.createElement(Card, {
      title: 'AIイベント検索（Gemini）',
      style: { marginBottom: 'var(--space-lg)' },
    },
      React.createElement('div', { style: { marginBottom: 'var(--space-md)' } },
        React.createElement('div', { style: { display: 'flex', gap: '8px', alignItems: 'stretch', marginBottom: '8px' } },
          React.createElement('input', {
            className: 'form-input',
            type: 'text',
            placeholder: '例: 今週末のイベント、コンサート情報...',
            value: geminiQuery,
            onChange: (e) => setGeminiQuery(e.target.value),
            onKeyDown: (e) => { if (e.key === 'Enter' && !geminiLoading) handleGeminiSearch(); },
            style: { flex: 1 },
          }),
          React.createElement(Button, {
            variant: 'primary',
            icon: geminiLoading ? 'sync' : 'search',
            onClick: handleGeminiSearch,
            disabled: geminiLoading || !geminiQuery.trim(),
            style: { whiteSpace: 'nowrap' },
          }, geminiLoading ? '検索中...' : 'AI検索')
        ),
        React.createElement('input', {
          className: 'form-input',
          type: 'text',
          placeholder: 'エリア（任意）: 渋谷、新宿、東京駅周辺...',
          value: geminiArea,
          onChange: (e) => setGeminiArea(e.target.value),
          style: { marginBottom: '8px' },
        }),
        React.createElement('div', {
          style: { display: 'flex', gap: '6px', flexWrap: 'wrap' },
        },
          quickEventQueries.map(q =>
            React.createElement('button', {
              key: q,
              onClick: () => { setGeminiQuery(q); },
              style: {
                padding: '4px 10px', borderRadius: '12px', fontSize: '11px',
                border: '1px solid rgba(255,255,255,0.12)', background: 'rgba(255,255,255,0.05)',
                color: 'var(--text-secondary)', cursor: 'pointer', transition: 'all 0.15s',
              },
              onMouseEnter: (e) => { e.currentTarget.style.background = 'rgba(249,168,37,0.15)'; e.currentTarget.style.color = 'var(--color-secondary)'; },
              onMouseLeave: (e) => { e.currentTarget.style.background = 'rgba(255,255,255,0.05)'; e.currentTarget.style.color = 'var(--text-secondary)'; },
            }, q)
          )
        )
      ),
      geminiError && React.createElement('div', {
        style: {
          padding: '10px 14px', borderRadius: '8px', marginBottom: 'var(--space-md)',
          background: 'rgba(229,57,53,0.1)', border: '1px solid rgba(229,57,53,0.3)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--color-danger)' } }, 'error'),
        React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-danger)' } }, geminiError)
      ),
      geminiLoading && React.createElement('div', {
        style: {
          padding: 'var(--space-lg)', textAlign: 'center',
          display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '32px', color: 'var(--color-secondary)', animation: 'spin 1s linear infinite' },
        }, 'sync'),
        React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)' } }, 'Gemini AIが検索中...')
      ),
      geminiResult && React.createElement('div', {
        style: {
          padding: 'var(--space-md)', borderRadius: '8px',
          background: 'rgba(249,168,37,0.06)', border: '1px solid rgba(249,168,37,0.15)',
        },
      },
        React.createElement('div', {
          style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '10px' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--color-secondary)' } }, 'smart_toy'),
          React.createElement('span', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)', color: 'var(--color-secondary)' } }, 'Gemini AI回答')
        ),
        React.createElement('div', {
          style: {
            fontSize: 'var(--font-size-sm)', color: 'var(--text-primary)',
            lineHeight: 1.8, whiteSpace: 'pre-wrap', wordBreak: 'break-word',
          },
        }, geminiResult),
        React.createElement('div', {
          style: { marginTop: '10px', fontSize: '10px', color: 'var(--text-muted)', display: 'flex', alignItems: 'center', gap: '4px' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px' } }, 'info'),
          '※ AIによる回答です。イベント情報は公式サイトで最終確認をお勧めします'
        )
      )
    ) : React.createElement(Card, { style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('div', {
        style: {
          textAlign: 'center', padding: 'var(--space-lg)',
          display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '10px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '36px', color: 'var(--color-secondary)', opacity: 0.5 },
        }, 'smart_toy'),
        React.createElement('div', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)' } }, 'AIイベント検索'),
        React.createElement('div', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-xs)', lineHeight: 1.6 } },
          'Gemini APIキーを設定すると、AIでイベント情報を検索できます'
        ),
        React.createElement(Button, {
          variant: 'secondary',
          icon: 'settings',
          onClick: () => document.dispatchEvent(new CustomEvent('navigate', { detail: 'settings' })),
          style: { fontSize: '12px' },
        }, '設定ページへ')
      )
    ),

    // 入力フォーム
    React.createElement(Card, { title: 'イベントを記録', style: { marginBottom: 'var(--space-lg)' } },
      // エラー表示
      errors.length > 0 && React.createElement('div', {
        style: {
          background: 'rgba(229,57,53,0.1)', border: '1px solid rgba(229,57,53,0.3)',
          borderRadius: '8px', padding: '8px 12px', marginBottom: 'var(--space-md)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: 'var(--color-danger)' },
        }, 'error'),
        React.createElement('div', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-danger)' } },
          errors.join('、')
        )
      ),

      // 保存成功メッセージ
      saved && React.createElement('div', {
        style: {
          background: 'rgba(0,200,83,0.1)', border: '1px solid rgba(0,200,83,0.3)',
          borderRadius: '8px', padding: '8px 12px', marginBottom: 'var(--space-md)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: 'var(--color-accent)' },
        }, 'check_circle'),
        React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-accent)' } },
          'イベントを記録しました'
        )
      ),

      React.createElement('form', { onSubmit: handleSubmit },
        React.createElement('div', { className: 'grid grid--2' },

          // イベント名（必須）
          React.createElement('div', { className: 'form-group', style: { gridColumn: '1 / -1' } },
            React.createElement('label', { className: 'form-label' }, 'イベント名 *'),
            React.createElement('input', {
              className: 'form-input',
              type: 'text',
              placeholder: '例: 東京マラソン、花火大会、コンサート',
              value: form.name,
              onChange: (e) => setForm({ ...form, name: e.target.value }),
              required: true,
            })
          ),

          // 日付
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '日付',
              React.createElement('span', {
                style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: '400', padding: '1px 6px', borderRadius: '3px', background: 'rgba(0,200,83,0.1)' },
              }, '自動')
            ),
            React.createElement('input', {
              className: 'form-input',
              type: 'date',
              value: form.date,
              onChange: (e) => setForm({ ...form, date: e.target.value }),
              style: { colorScheme: 'dark' },
            }),
            form.date && (() => {
              const info = JapaneseHolidays.getDateInfo(form.date);
              const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-secondary)';
              return React.createElement('div', {
                style: { marginTop: '6px', display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' },
              },
                React.createElement('span', {
                  style: {
                    fontSize: '13px', fontWeight: '600', color: dayColor,
                    padding: '2px 10px', borderRadius: '4px',
                    background: info.isSunday || info.isHoliday ? 'rgba(239,68,68,0.12)' : info.isSaturday ? 'rgba(59,130,246,0.12)' : 'rgba(255,255,255,0.06)',
                  },
                }, `${info.dayOfWeek}曜日`),
                info.holiday && React.createElement('span', {
                  style: {
                    fontSize: '12px', fontWeight: '600', color: '#ef4444',
                    padding: '2px 10px', borderRadius: '4px',
                    background: 'rgba(239,68,68,0.12)',
                    display: 'flex', alignItems: 'center', gap: '4px',
                  },
                },
                  React.createElement('span', { style: { fontSize: '13px' } }, '\u{1F38C}'),
                  info.holiday
                )
              );
            })()
          ),

          // 時間帯
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '時間帯'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'center' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'time',
                value: form.startTime,
                onChange: (e) => setForm({ ...form, startTime: e.target.value }),
                style: { flex: 1, minWidth: 0, colorScheme: 'dark' },
                placeholder: '開始',
              }),
              React.createElement('span', { style: { color: 'var(--text-muted)', fontSize: '14px' } }, '\u301C'),
              React.createElement('input', {
                className: 'form-input',
                type: 'time',
                value: form.endTime,
                onChange: (e) => setForm({ ...form, endTime: e.target.value }),
                style: { flex: 1, minWidth: 0, colorScheme: 'dark' },
                placeholder: '終了',
              })
            )
          ),

          // 場所（GPS付き）
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label', style: { display: 'flex', alignItems: 'center', gap: '6px' } },
              '場所',
              gpsLoading && React.createElement('span', {
                style: { fontSize: '11px', color: 'var(--color-secondary)', fontWeight: '400', animation: 'pulse 1.5s ease-in-out infinite' },
              }, '取得中...')
            ),
            React.createElement('div', { style: { display: 'flex', gap: '6px', alignItems: 'stretch' } },
              React.createElement('input', {
                className: 'form-input',
                type: 'text',
                placeholder: '東京ドーム、渋谷駅前 等',
                value: form.location,
                onChange: (e) => { setForm({ ...form, location: e.target.value }); if (!e.target.value) setGpsInfo(null); },
                style: { flex: 1, minWidth: 0 },
              }),
              React.createElement('button', {
                type: 'button',
                onClick: getGpsLocation,
                disabled: gpsLoading,
                style: gpsButtonStyle(gpsLoading),
                title: 'GPSで現在地を取得',
              },
                React.createElement('span', {
                  className: 'material-icons-round',
                  style: { fontSize: '16px', animation: gpsLoading ? 'spin 1s linear infinite' : 'none' },
                }, gpsLoading ? 'sync' : 'my_location'),
                gpsLoading ? '取得中' : 'GPS'
              )
            ),
            gpsInfo && React.createElement('div', {
              style: {
                marginTop: '6px', padding: '6px 10px', borderRadius: '6px',
                background: 'rgba(26,115,232,0.08)', border: '1px solid rgba(26,115,232,0.15)',
                fontSize: '11px', color: 'var(--text-secondary)', lineHeight: '1.5',
              },
            },
              gpsInfo.address && React.createElement('div', { style: { display: 'flex', alignItems: 'flex-start', gap: '4px', marginBottom: '3px' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '13px', color: 'var(--color-primary-light)', marginTop: '1px', flexShrink: 0 } }, 'place'),
                React.createElement('span', { style: { fontWeight: '600', color: 'var(--color-primary-light)', wordBreak: 'break-all' } }, gpsInfo.address)
              ),
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '4px', color: 'var(--text-muted)', fontSize: '10px' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px', flexShrink: 0 } }, 'gps_fixed'),
                `${gpsInfo.lat.toFixed(6)}, ${gpsInfo.lng.toFixed(6)}`
              )
            )
          ),

          // 規模
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '規模'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              scaleOptions.map(s =>
                React.createElement('button', {
                  key: s.value,
                  type: 'button',
                  onClick: () => setForm({ ...form, scale: form.scale === s.value ? '' : s.value }),
                  style: {
                    display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px',
                    padding: '8px 14px', borderRadius: '8px',
                    fontSize: '13px', fontWeight: form.scale === s.value ? '700' : '400',
                    cursor: 'pointer',
                    border: form.scale === s.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.scale === s.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.scale === s.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', null, s.label),
                  React.createElement('span', { style: { fontSize: '9px', color: 'var(--text-muted)' } }, s.desc)
                )
              )
            )
          ),

          // 予想影響
          React.createElement('div', { className: 'form-group' },
            React.createElement('label', { className: 'form-label' }, '予想影響'),
            React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
              impactOptions.map(opt =>
                React.createElement('button', {
                  key: opt.value,
                  type: 'button',
                  onClick: () => setForm({ ...form, impact: form.impact === opt.value ? '' : opt.value }),
                  style: {
                    display: 'flex', alignItems: 'center', gap: '6px',
                    padding: '8px 14px', borderRadius: '8px',
                    fontSize: '13px', fontWeight: form.impact === opt.value ? '700' : '400',
                    cursor: 'pointer',
                    border: form.impact === opt.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                    background: form.impact === opt.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                    color: form.impact === opt.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                    transition: 'all 0.15s ease',
                  },
                },
                  React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: opt.color } }, opt.icon),
                  opt.value
                )
              )
            )
          ),

          // メモ
          React.createElement('div', { className: 'form-group', style: { gridColumn: '1 / -1' } },
            React.createElement('label', { className: 'form-label' }, 'メモ'),
            React.createElement('input', {
              className: 'form-input',
              type: 'text',
              placeholder: '任意のメモ（集客予想、注意点など）',
              value: form.memo,
              onChange: (e) => setForm({ ...form, memo: e.target.value }),
            })
          )
        ),
        React.createElement(Button, {
          variant: 'primary',
          icon: 'add',
          style: { marginTop: 'var(--space-sm)' },
        }, 'イベントを記録')
      )
    ),

    // データ管理ツールバー
    entries.length > 0 && React.createElement(Card, { style: { marginBottom: 'var(--space-md)' } },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '10px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--color-primary-light)' } }, 'folder'),
        React.createElement('span', { style: { fontSize: '13px', fontWeight: '600', color: 'var(--text-primary)' } }, 'データ管理'),
        React.createElement('span', { style: { fontSize: '11px', color: 'var(--text-muted)', marginLeft: 'auto' } },
          `全 ${entries.length} 件の記録`
        )
      ),
      React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
        React.createElement(Button, {
          variant: 'danger',
          icon: 'delete_forever',
          onClick: () => { if (confirm('全てのイベント記録を削除しますか？この操作は取り消せません。')) handleClearAll(); },
          style: { padding: '6px 12px', fontSize: '11px' },
        }, '全削除')
      )
    ),

    // 記録一覧
    entries.length > 0 && React.createElement(Card, { title: `記録一覧（${entries.length}件）` },
      entries.map(entry =>
        React.createElement('div', {
          key: entry.id,
          style: {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'flex-start',
            padding: '12px 0',
            borderBottom: '1px solid rgba(255,255,255,0.06)',
          },
        },
          React.createElement('div', { style: { flex: 1 } },
            React.createElement('div', { style: { fontWeight: 600, display: 'flex', alignItems: 'center', gap: '6px', flexWrap: 'wrap' } },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: 'var(--color-secondary)' } }, 'event'),
              React.createElement('span', null, entry.name)
            ),
            React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', display: 'flex', flexWrap: 'wrap', alignItems: 'center', gap: '4px', marginTop: '4px' } },
              (() => {
                const info = entry.dayOfWeek ? { dayOfWeek: entry.dayOfWeek, holiday: entry.holiday, isSunday: entry.dayOfWeek === '日', isSaturday: entry.dayOfWeek === '土', isHoliday: !!entry.holiday } : JapaneseHolidays.getDateInfo(entry.date);
                const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-muted)';
                return React.createElement(React.Fragment, null,
                  React.createElement('span', null, entry.date),
                  React.createElement('span', { style: { color: dayColor, fontWeight: '600' } }, `(${info.dayOfWeek})`),
                  info.holiday && React.createElement('span', {
                    style: { color: '#ef4444', fontSize: '10px', padding: '1px 6px', borderRadius: '3px', background: 'rgba(239,68,68,0.1)' },
                  }, info.holiday),
                  (entry.startTime || entry.endTime) && React.createElement('span', {
                    style: { fontSize: '11px', color: 'var(--color-primary-light)', fontWeight: '600', padding: '1px 6px', borderRadius: '3px', background: 'rgba(26,115,232,0.12)' },
                  }, `${entry.startTime || '?'}\u301C${entry.endTime || '?'}`),
                  entry.location && React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '2px' } },
                    React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px' } }, 'place'),
                    entry.location
                  )
                );
              })()
            ),
            (entry.scale || entry.impact) && React.createElement('div', {
              style: { fontSize: '11px', color: 'var(--text-secondary)', marginTop: '4px', display: 'flex', gap: '6px', flexWrap: 'wrap' },
            },
              entry.scale && React.createElement('span', {
                style: { padding: '1px 8px', borderRadius: '3px', background: 'rgba(249,168,37,0.12)', color: 'var(--color-secondary)', fontWeight: '600' },
              }, `規模: ${entry.scale}`),
              entry.impact && React.createElement('span', {
                style: {
                  padding: '1px 8px', borderRadius: '3px', fontWeight: '600',
                  background: entry.impact === '需要増' ? 'rgba(0,200,83,0.12)' : entry.impact === '需要減' ? 'rgba(229,57,53,0.12)' : 'rgba(255,255,255,0.06)',
                  color: entry.impact === '需要増' ? 'var(--color-accent)' : entry.impact === '需要減' ? 'var(--color-danger)' : 'var(--text-muted)',
                },
              }, `影響: ${entry.impact}`)
            ),
            entry.memo && React.createElement('div', {
              style: { fontSize: '11px', color: 'var(--text-muted)', marginTop: '2px' },
            }, `${entry.memo}`)
          ),
          React.createElement('button', {
            onClick: () => handleDelete(entry.id),
            style: {
              background: 'none', border: 'none', cursor: 'pointer',
              color: 'var(--text-muted)', padding: '4px',
              borderRadius: '4px', transition: 'color 0.2s',
              marginTop: '4px',
            },
            title: '削除',
          },
            React.createElement('span', {
              className: 'material-icons-round',
              style: { fontSize: '18px' },
            }, 'delete_outline')
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/Analytics.jsx
// ============================================================
(function() {
// Analytics.jsx - 売上分析ページ（DataServiceによるリアルデータ分析）
// v0.3.1: useMemoの依存配列修正 — データ追加後に分析結果が更新されるようにrefreshKeyを導入

// バーチャートコンポーネント（ページ外定義で毎レンダー再生成を防止）
const BarChart = ({ data, valueKey, labelKey, color, maxBars = 30, height = 200, prefix = '¥', showLabels = false, labelInterval = 5 }) => {
  const [activeIdx, setActiveIdx] = React.useState(null);
  const maxVal = Math.max(...data.map(d => d[valueKey]), 1);
  const barData = data.slice(-maxBars);

  const formatLabel = (label) => {
    if (!label) return '';
    if (/^\d{4}-\d{2}-\d{2}$/.test(label)) {
      const parts = label.split('-');
      return `${parseInt(parts[1])}/${parseInt(parts[2])}`;
    }
    return label;
  };

  return React.createElement('div', { style: { position: 'relative' } },
    activeIdx !== null && barData[activeIdx] && React.createElement('div', {
      style: {
        position: 'absolute', top: '-8px', left: '50%', transform: 'translateX(-50%)',
        background: 'rgba(0,0,0,0.85)', color: '#fff', padding: '6px 12px',
        borderRadius: '8px', fontSize: '13px', fontWeight: 600,
        whiteSpace: 'nowrap', zIndex: 10, pointerEvents: 'none',
        boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
      },
    }, `${formatLabel(barData[activeIdx][labelKey])}  ${prefix}${barData[activeIdx][valueKey].toLocaleString()}`),
    React.createElement('div', {
      style: { display: 'flex', alignItems: 'flex-end', gap: '2px', height: `${height}px`, padding: '0 4px' },
      onMouseLeave: () => setActiveIdx(null),
    },
      barData.map((d, i) => {
        const pct = (d[valueKey] / maxVal) * 100;
        const isActive = activeIdx === i;
        return React.createElement('div', {
          key: i,
          style: { flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', height: '100%', justifyContent: 'flex-end', cursor: 'pointer' },
          onMouseEnter: () => setActiveIdx(i),
          onClick: () => setActiveIdx(isActive ? null : i),
        },
          React.createElement('div', {
            style: {
              width: '100%', minHeight: '2px',
              height: `${Math.max(pct, 1)}%`,
              background: d[valueKey] === 0 ? 'rgba(255,255,255,0.05)' : isActive ? '#fff' : color,
              borderRadius: '3px 3px 0 0',
              transition: 'height 0.3s ease, background 0.15s ease',
              opacity: activeIdx !== null && !isActive ? 0.5 : 1,
            },
          })
        );
      })
    ),
    React.createElement('div', {
      style: { display: 'flex', gap: '2px', padding: '4px 4px 0', marginTop: '2px' },
    },
      barData.map((d, i) => {
        const label = formatLabel(d[labelKey]);
        const show = i === 0 || i === barData.length - 1 || (i % labelInterval === 0);
        return React.createElement('div', {
          key: i,
          style: { flex: 1, textAlign: 'center', fontSize: '9px', color: 'var(--text-muted)', overflow: 'hidden', whiteSpace: 'nowrap' },
        }, show ? label : '');
      })
    )
  );
};

const HBarChart = ({ data, nameKey, valueKey, color, prefix = '¥' }) => {
  const maxVal = Math.max(...data.map(d => d[valueKey]), 1);
  return React.createElement('div', { style: { display: 'grid', gap: '6px' } },
    data.map((d, i) => {
      const pct = (d[valueKey] / maxVal) * 100;
      return React.createElement('div', { key: i },
        React.createElement('div', {
          style: { display: 'flex', justifyContent: 'space-between', fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)', marginBottom: '2px' },
        },
          React.createElement('span', null, d[nameKey]),
          React.createElement('span', { style: { fontWeight: 500, color: 'var(--text-primary)' } }, `${prefix}${d[valueKey].toLocaleString()}`)
        ),
        React.createElement('div', {
          style: { background: 'rgba(255,255,255,0.06)', borderRadius: '4px', height: '8px', overflow: 'hidden' },
        },
          React.createElement('div', {
            style: { width: `${pct}%`, height: '100%', background: color, borderRadius: '4px', transition: 'width 0.3s ease' },
          })
        )
      );
    })
  );
};
window.AnalyticsPage = () => {
  const { useState, useEffect, useMemo } = React;
  const [tab, setTab] = useState('daily');
  const [refreshKey, setRefreshKey] = useState(0);

  // localStorageの変更を監視して自動更新（Dashboardと同じパターン）
  useEffect(() => {
    const handleStorage = (e) => {
      if (e.key === APP_CONSTANTS.STORAGE_KEYS.REVENUE_DATA || e.key === APP_CONSTANTS.STORAGE_KEYS.RIVAL_RIDES) {
        setRefreshKey(k => k + 1);
      }
    };
    window.addEventListener('storage', handleStorage);

    // 画面に戻った時も更新
    const handleVisibility = () => {
      if (!document.hidden) setRefreshKey(k => k + 1);
    };
    document.addEventListener('visibilitychange', handleVisibility);

    const handleDataChanged = () => setRefreshKey(k => k + 1);
    window.addEventListener('taxi-data-changed', handleDataChanged);

    return () => {
      window.removeEventListener('storage', handleStorage);
      document.removeEventListener('visibilitychange', handleVisibility);
      window.removeEventListener('taxi-data-changed', handleDataChanged);
    };
  }, []);

  // 常に必要なデータ
  const overall = useMemo(() => DataService.getOverallSummary(), [refreshKey]);

  // アクティブタブのデータのみ計算（遅延評価）
  const daily = useMemo(() => tab === 'daily' ? DataService.getDailyBreakdown(30) : [], [refreshKey, tab]);
  const monthly = useMemo(() => tab === 'daily' ? DataService.getMonthlyBreakdown() : [], [refreshKey, tab]);
  const dayOfWeek = useMemo(() => tab === 'dayOfWeek' ? DataService.getDayOfWeekBreakdown() : [], [refreshKey, tab]);
  const hourly = useMemo(() => tab === 'hourly' ? DataService.getHourlyBreakdown() : [], [refreshKey, tab]);
  const areas = useMemo(() => tab === 'area' ? DataService.getAreaBreakdown() : { pickups: [], dropoffs: [] }, [refreshKey, tab]);
  const weather = useMemo(() => tab === 'weather' ? DataService.getWeatherBreakdown() : [], [refreshKey, tab]);

  const rivalHourly = useMemo(() => tab === 'rival' ? DataService.getRivalHourlyBreakdown() : [], [refreshKey, tab]);
  const rivalDow = useMemo(() => tab === 'rival' ? DataService.getRivalDayOfWeekBreakdown() : [], [refreshKey, tab]);
  const rivalLocs = useMemo(() => tab === 'rival' ? DataService.getRivalLocationBreakdown() : [], [refreshKey, tab]);
  const rivalWeather = useMemo(() => tab === 'rival' ? DataService.getRivalWeatherBreakdown() : [], [refreshKey, tab]);
  const rivalTotal = useMemo(() => tab === 'rival' ? DataService.getRivalEntries().length : 0, [refreshKey, tab]);

  const sourceData = useMemo(() => (tab === 'area' || tab === 'forecast') ? DataService.getSourceBreakdown() : [], [refreshKey, tab]);
  const purposeData = useMemo(() => (tab === 'area' || tab === 'forecast') ? DataService.getPurposeBreakdown() : [], [refreshKey, tab]);
  const areaTime = useMemo(() => (tab === 'area' || tab === 'forecast') ? DataService.getAreaTimeBreakdown() : [], [refreshKey, tab]);
  const unitPrice = useMemo(() => (tab === 'area' || tab === 'forecast') ? DataService.getUnitPriceAnalysis() : null, [refreshKey, tab]);
  const recommendation = useMemo(() => DataService.getBusinessRecommendation(), [refreshKey]);
  const sourceAreaPrice = useMemo(() => (tab === 'area' || tab === 'forecast') ? DataService.getSourceAreaPriceBreakdown() : null, [refreshKey, tab]);
  const purposeDay = useMemo(() => (tab === 'purposeDay' || tab === 'forecast') ? DataService.getPurposeDayAnalysis() : null, [refreshKey, tab]);

  const hasData = overall.rideCount > 0;

  // データなし画面
  if (!hasData) {
    return React.createElement('div', null,
      React.createElement('h1', { className: 'page-title' },
        React.createElement('span', { className: 'material-icons-round' }, 'analytics'),
        '売上分析'
      ),
      React.createElement(Card, { style: { textAlign: 'center', padding: 'var(--space-2xl)' } },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '64px', color: 'var(--text-muted)', marginBottom: '16px' },
        }, 'bar_chart'),
        React.createElement('h3', { style: { marginBottom: '8px' } }, 'まだデータがありません'),
        React.createElement('p', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)' } },
          '売上記録ページからデータを追加すると、ここに分析結果が表示されます。'
        )
      )
    );
  }

  const tabs = [
    { id: 'daily', label: '日別', icon: 'calendar_today' },
    { id: 'dayOfWeek', label: '曜日別', icon: 'date_range' },
    { id: 'hourly', label: '時間帯別', icon: 'schedule' },
    { id: 'area', label: 'エリア別', icon: 'place' },
    { id: 'weather', label: '天候別', icon: 'cloud' },
    { id: 'purposeDay', label: '用途別', icon: 'category' },
    { id: 'rival', label: '他社分析', icon: 'local_taxi' },
    { id: 'forecast', label: '業務予測', icon: 'tips_and_updates' },
  ];

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'analytics'),
      '売上分析'
    ),

    // サマリーカード
    React.createElement('div', { className: 'grid grid--4', style: { marginBottom: 'var(--space-lg)' } },
      [
        { label: '累計売上（税込）', value: `¥${overall.totalAmount.toLocaleString()}`, sub: `税抜¥${Math.floor(overall.totalAmount / 1.1).toLocaleString()} 税¥${(overall.totalAmount - Math.floor(overall.totalAmount / 1.1)).toLocaleString()}`, icon: 'payments', color: 'var(--color-secondary)' },
        { label: '累計乗車', value: `${overall.rideCount}回`, icon: 'people', color: 'var(--color-primary-light)' },
        { label: '平均単価（税込）', value: `¥${overall.avgAmount.toLocaleString()}`, sub: `税抜¥${Math.floor(overall.avgAmount / 1.1).toLocaleString()} 税¥${(overall.avgAmount - Math.floor(overall.avgAmount / 1.1)).toLocaleString()}`, icon: 'price_check', color: 'var(--color-accent)' },
        { label: '日平均（税込）', value: `¥${overall.dailyAvg.toLocaleString()}`, sub: `税抜¥${Math.floor(overall.dailyAvg / 1.1).toLocaleString()} 税¥${(overall.dailyAvg - Math.floor(overall.dailyAvg / 1.1)).toLocaleString()}`, icon: 'trending_up', color: 'var(--color-warning)' },
      ].map((s, i) =>
        React.createElement(Card, { key: i, className: 'stat-card' },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '28px', color: s.color, marginBottom: '4px' },
          }, s.icon),
          React.createElement('div', { className: 'stat-card__value', style: { fontSize: 'var(--font-size-xl)' } }, s.value),
          s.sub && React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)', marginTop: '2px' } }, s.sub),
          React.createElement('div', { className: 'stat-card__label' }, s.label)
        )
      )
    ),

    // 当月合計
    (() => {
      const now = new Date();
      const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
      const cm = monthly.find(m => m.month === currentMonth);
      const amt = cm ? cm.amount : 0;
      const cnt = cm ? cm.count : 0;
      const taxExcl = Math.floor(amt / 1.1);
      const tax = amt - taxExcl;
      return React.createElement('div', {
        style: { background: 'linear-gradient(135deg, rgba(26,115,232,0.15), rgba(255,167,38,0.10))', border: '1px solid rgba(26,115,232,0.3)', borderRadius: '12px', padding: '16px 20px', marginBottom: 'var(--space-lg)', display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexWrap: 'wrap', gap: '12px' },
      },
        React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '10px' } },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '24px', color: 'var(--color-primary-light)' } }, 'calendar_month'),
          React.createElement('div', null,
            React.createElement('div', { style: { fontSize: '12px', color: 'var(--text-secondary)' } }, `${now.getFullYear()}年${now.getMonth() + 1}月の売上合計`),
            React.createElement('div', { style: { fontSize: '11px', color: 'var(--text-muted)', marginTop: '2px' } }, `${cnt}回乗車`)
          )
        ),
        React.createElement('div', { style: { textAlign: 'right' } },
          React.createElement('div', { style: { fontSize: '24px', fontWeight: 800, color: 'var(--color-secondary)' } }, `¥${amt.toLocaleString()}`),
          React.createElement('div', { style: { fontSize: '11px', color: 'var(--text-muted)', marginTop: '2px' } }, `税抜¥${taxExcl.toLocaleString()}　税¥${tax.toLocaleString()}`)
        )
      );
    })(),

    // タブ切り替え
    React.createElement('div', {
      style: { display: 'flex', gap: '4px', marginBottom: 'var(--space-lg)', flexWrap: 'wrap' },
    },
      tabs.map(t =>
        React.createElement('button', {
          key: t.id,
          onClick: () => setTab(t.id),
          style: {
            display: 'flex', alignItems: 'center', gap: '6px',
            padding: '8px 16px', border: 'none', borderRadius: '20px', cursor: 'pointer',
            fontSize: 'var(--font-size-sm)', fontFamily: 'var(--font-family)',
            background: tab === t.id ? 'rgba(26,115,232,0.2)' : 'rgba(255,255,255,0.04)',
            color: tab === t.id ? 'var(--color-primary-light)' : 'var(--text-secondary)',
            transition: 'all 0.2s ease',
          },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, t.icon),
          t.label
        )
      )
    ),

    // 日別タブ
    tab === 'daily' && React.createElement(React.Fragment, null,
      React.createElement(Card, { title: '過去30日間の売上推移', style: { marginBottom: 'var(--space-lg)' } },
        React.createElement(BarChart, { data: daily, valueKey: 'amount', labelKey: 'date', color: 'var(--color-primary-light)', height: 180, showLabels: true, labelInterval: 5 })
      ),
      monthly.length > 0 && React.createElement(Card, { title: '月別集計', style: { marginBottom: 'var(--space-lg)' } },
        monthly.map((m, i) =>
          React.createElement('div', {
            key: i,
            style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '10px 0', borderBottom: '1px solid rgba(255,255,255,0.06)' },
          },
            React.createElement('span', { style: { fontWeight: 500 } }, m.month),
            React.createElement('div', { style: { textAlign: 'right' } },
              React.createElement('div', { style: { display: 'flex', gap: '16px', alignItems: 'center', justifyContent: 'flex-end' } },
                React.createElement('span', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)' } }, `${m.count}回`),
                React.createElement('span', { style: { fontWeight: 700, color: 'var(--color-secondary)' } }, `¥${m.amount.toLocaleString()}`)
              ),
              React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(m.amount / 1.1).toLocaleString()} 税¥${(m.amount - Math.floor(m.amount / 1.1)).toLocaleString()}`)
            )
          )
        )
      )
    ),

    // 曜日別タブ
    tab === 'dayOfWeek' && React.createElement(React.Fragment, null,
      React.createElement(Card, { title: '曜日別売上合計', style: { marginBottom: 'var(--space-lg)' } },
        React.createElement(BarChart, { data: dayOfWeek, valueKey: 'amount', labelKey: 'name', color: 'var(--color-accent)', height: 160, showLabels: true, labelInterval: 1 })
      ),
      React.createElement(Card, { title: '曜日別詳細' },
        dayOfWeek.map((d, i) =>
          React.createElement('div', {
            key: i,
            style: { display: 'grid', gridTemplateColumns: '40px 1fr 80px 80px', gap: '8px', alignItems: 'center', padding: '8px 0', borderBottom: '1px solid rgba(255,255,255,0.06)' },
          },
            React.createElement('span', {
              style: { fontWeight: 700, color: (d.index === 0 || d.index === 6) ? 'var(--color-danger)' : 'var(--text-primary)' },
            }, d.name),
            React.createElement('div', {
              style: { background: 'rgba(255,255,255,0.06)', borderRadius: '4px', height: '6px', overflow: 'hidden' },
            },
              React.createElement('div', {
                style: { width: `${d.count > 0 ? (d.amount / Math.max(...dayOfWeek.map(x => x.amount), 1)) * 100 : 0}%`, height: '100%', background: 'var(--color-accent)', borderRadius: '4px' },
              })
            ),
            React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', textAlign: 'right' } }, `${d.count}回`),
            React.createElement('div', { style: { textAlign: 'right' } },
              React.createElement('div', { style: { fontSize: 'var(--font-size-sm)', fontWeight: 500 } }, `¥${d.amount.toLocaleString()}`),
              React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(d.amount / 1.1).toLocaleString()} 税¥${(d.amount - Math.floor(d.amount / 1.1)).toLocaleString()}`)
            )
          )
        )
      )
    ),

    // 時間帯別タブ
    tab === 'hourly' && React.createElement(React.Fragment, null,
      React.createElement(Card, { title: '時間帯別売上平均', subtitle: '各時間帯の平均売上額', style: { marginBottom: 'var(--space-lg)' } },
        React.createElement(BarChart, { data: hourly, valueKey: 'avg', labelKey: 'label', color: 'var(--color-warning)', height: 160, maxBars: 24, showLabels: true, labelInterval: 3 })
      ),
      React.createElement(Card, { title: '売上上位の時間帯' },
        (() => {
          const sorted = [...hourly].filter(h => h.count > 0).sort((a, b) => b.amount - a.amount).slice(0, 5);
          return sorted.length > 0
            ? React.createElement(HBarChart, { data: sorted, nameKey: 'label', valueKey: 'amount', color: 'var(--color-warning)' })
            : React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-sm)' } }, 'データなし');
        })()
      )
    ),

    // エリア別タブ
    tab === 'area' && React.createElement('div', { className: 'grid grid--2', style: { gap: 'var(--space-lg)' } },
      // 乗車地
      React.createElement(Card, { title: '乗車地ランキング', subtitle: `上位 ${Math.min(areas.pickups.length, 10)} 件` },
        areas.pickups.length === 0
          ? React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-sm)' } }, '乗車地データなし')
          : areas.pickups.map((p, i) =>
              React.createElement('div', {
                key: i,
                style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '8px 0', borderBottom: '1px solid rgba(255,255,255,0.06)' },
              },
                React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
                  React.createElement('span', {
                    style: {
                      width: '24px', height: '24px', borderRadius: '50%',
                      background: i < 3 ? 'var(--color-secondary)' : 'rgba(255,255,255,0.1)',
                      color: i < 3 ? 'var(--text-dark)' : 'var(--text-secondary)',
                      display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: 'var(--font-size-xs)', fontWeight: 700,
                    },
                  }, `${i + 1}`),
                  React.createElement('span', { style: { fontSize: 'var(--font-size-sm)' } }, p.name)
                ),
                React.createElement('div', { style: { textAlign: 'right' } },
                  React.createElement('div', { style: { fontSize: 'var(--font-size-sm)', fontWeight: 500 } }, `${p.count}回`),
                  React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--color-secondary)' } }, `¥${p.amount.toLocaleString()}`),
                  React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(p.amount / 1.1).toLocaleString()} 税¥${(p.amount - Math.floor(p.amount / 1.1)).toLocaleString()}`)
                )
              )
            )
      ),
      // 降車地
      React.createElement(Card, { title: '降車地ランキング', subtitle: `上位 ${Math.min(areas.dropoffs.length, 10)} 件` },
        areas.dropoffs.length === 0
          ? React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-sm)' } }, '降車地データなし')
          : areas.dropoffs.map((p, i) =>
              React.createElement('div', {
                key: i,
                style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '8px 0', borderBottom: '1px solid rgba(255,255,255,0.06)' },
              },
                React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
                  React.createElement('span', {
                    style: {
                      width: '24px', height: '24px', borderRadius: '50%',
                      background: i < 3 ? 'var(--color-accent)' : 'rgba(255,255,255,0.1)',
                      color: i < 3 ? '#fff' : 'var(--text-secondary)',
                      display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: 'var(--font-size-xs)', fontWeight: 700,
                    },
                  }, `${i + 1}`),
                  React.createElement('span', { style: { fontSize: 'var(--font-size-sm)' } }, p.name)
                ),
                React.createElement('div', { style: { textAlign: 'right' } },
                  React.createElement('div', { style: { fontSize: 'var(--font-size-sm)', fontWeight: 500 } }, `${p.count}回`),
                  React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--color-accent)' } }, `¥${p.amount.toLocaleString()}`),
                  React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(p.amount / 1.1).toLocaleString()} 税¥${(p.amount - Math.floor(p.amount / 1.1)).toLocaleString()}`)
                )
              )
            )
      )
    ),

    // 天候別タブ
    tab === 'weather' && React.createElement(React.Fragment, null,
      React.createElement(Card, { title: '天候別 平均売上', style: { marginBottom: 'var(--space-lg)' } },
        (() => {
          const withData = weather.filter(w => w.count > 0);
          return withData.length > 0
            ? React.createElement(BarChart, { data: withData, valueKey: 'avg', labelKey: 'name', color: 'var(--color-primary-light)', height: 160 })
            : React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-sm)' } }, 'データなし');
        })(),
        React.createElement('div', {
          style: { display: 'flex', justifyContent: 'space-around', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '6px' },
        }, weather.filter(w => w.count > 0).map(w => React.createElement('span', { key: w.name, style: { display: 'flex', alignItems: 'center', gap: '2px' } },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } },
            w.name === '晴れ' ? 'wb_sunny' : w.name === '曇り' ? 'cloud' : w.name === '雨' ? 'water_drop' : w.name === '雪' ? 'ac_unit' : 'help_outline'
          ), w.name
        )))
      ),
      React.createElement(Card, { title: '天候別 合計売上', style: { marginBottom: 'var(--space-lg)' } },
        (() => {
          const withData = weather.filter(w => w.count > 0);
          return withData.length > 0
            ? React.createElement(HBarChart, { data: withData, nameKey: 'name', valueKey: 'amount', color: 'var(--color-primary-light)' })
            : React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-sm)' } }, 'データなし');
        })()
      ),
      React.createElement(Card, { title: '天候別 詳細' },
        weather.map((w, i) =>
          React.createElement('div', {
            key: i,
            style: { display: 'grid', gridTemplateColumns: '80px 1fr 60px 80px 80px', gap: '8px', alignItems: 'center', padding: '8px 0', borderBottom: '1px solid rgba(255,255,255,0.06)' },
          },
            React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '4px', fontWeight: 500 } },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } },
                w.name === '晴れ' ? 'wb_sunny' : w.name === '曇り' ? 'cloud' : w.name === '雨' ? 'water_drop' : w.name === '雪' ? 'ac_unit' : 'help_outline'
              ), w.name
            ),
            React.createElement('div', {
              style: { background: 'rgba(255,255,255,0.06)', borderRadius: '4px', height: '6px', overflow: 'hidden' },
            },
              React.createElement('div', {
                style: { width: `${w.count > 0 ? (w.amount / Math.max(...weather.map(x => x.amount), 1)) * 100 : 0}%`, height: '100%', background: 'var(--color-primary-light)', borderRadius: '4px' },
              })
            ),
            React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', textAlign: 'right' } }, `${w.count}回`),
            React.createElement('div', { style: { textAlign: 'right' } },
              React.createElement('div', { style: { fontSize: 'var(--font-size-sm)' } }, `¥${w.avg.toLocaleString()}`),
              React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(w.avg / 1.1).toLocaleString()}`)
            ),
            React.createElement('div', { style: { textAlign: 'right' } },
              React.createElement('div', { style: { fontSize: 'var(--font-size-sm)', fontWeight: 500, color: 'var(--color-secondary)' } }, `¥${w.amount.toLocaleString()}`),
              React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(w.amount / 1.1).toLocaleString()} 税¥${(w.amount - Math.floor(w.amount / 1.1)).toLocaleString()}`)
            )
          )
        )
      )
    ),

    // 他社分析タブ
    tab === 'rival' && React.createElement(React.Fragment, null,
      // サマリー
      React.createElement(Card, {
        style: { marginBottom: 'var(--space-lg)', textAlign: 'center', padding: 'var(--space-lg)' },
      },
        React.createElement('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', marginBottom: '4px' } },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '28px', color: 'var(--color-warning)' } }, 'local_taxi'),
          React.createElement('span', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } }, '他社乗車記録数')
        ),
        React.createElement('div', { style: { fontSize: '2rem', fontWeight: 700 } }, `${rivalTotal}件`)
      ),

      rivalTotal === 0 && React.createElement(Card, { style: { textAlign: 'center', padding: 'var(--space-2xl)' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '48px', color: 'var(--text-muted)', marginBottom: '12px' } }, 'info'),
        React.createElement('p', { style: { color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)' } }, '他社乗車データを記録すると、ここに分析結果が表示されます。')
      ),

      // 時間帯別
      rivalTotal > 0 && React.createElement(Card, { title: '時間帯別 他社乗車件数', style: { marginBottom: 'var(--space-lg)' } },
        React.createElement(BarChart, { data: rivalHourly, valueKey: 'count', labelKey: 'label', color: 'var(--color-warning)', height: 140, maxBars: 24, prefix: '' }),
        React.createElement('div', {
          style: { display: 'flex', justifyContent: 'space-between', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '6px', padding: '0 4px' },
        },
          React.createElement('span', null, '0時'),
          React.createElement('span', null, '6時'),
          React.createElement('span', null, '12時'),
          React.createElement('span', null, '18時'),
          React.createElement('span', null, '23時')
        )
      ),

      // 曜日別
      rivalTotal > 0 && React.createElement(Card, { title: '曜日別 他社乗車件数', style: { marginBottom: 'var(--space-lg)' } },
        React.createElement(BarChart, { data: rivalDow, valueKey: 'count', labelKey: 'name', color: 'var(--color-accent)', height: 140, prefix: '' }),
        React.createElement('div', {
          style: { display: 'flex', justifyContent: 'space-around', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '6px' },
        }, rivalDow.map(d => React.createElement('span', { key: d.name }, d.name)))
      ),

      // 場所ランキング
      rivalTotal > 0 && rivalLocs.length > 0 && React.createElement(Card, { title: '乗車場所ランキング TOP10', style: { marginBottom: 'var(--space-lg)' } },
        React.createElement(HBarChart, { data: rivalLocs, nameKey: 'name', valueKey: 'count', color: 'var(--color-warning)', prefix: '' })
      ),

      // 天候別
      rivalTotal > 0 && React.createElement(Card, { title: '天候別 他社乗車件数' },
        React.createElement(HBarChart, { data: rivalWeather.filter(w => w.count > 0), nameKey: 'name', valueKey: 'count', color: 'var(--color-primary-light)', prefix: '' })
      )
    ),

    // 用途別分析タブ
    tab === 'purposeDay' && React.createElement(React.Fragment, null,

      // A. 用途×曜日ヒートマップ
      React.createElement(Card, {
        title: '用途×曜日 乗車パターン',
        subtitle: '各曜日にどの用途が多いか',
        style: { marginBottom: 'var(--space-lg)' },
      },
        React.createElement('div', { style: { overflowX: 'auto' } },
          React.createElement('table', {
            style: { width: '100%', borderCollapse: 'collapse', fontSize: 'var(--font-size-sm)' },
          },
            React.createElement('thead', null,
              React.createElement('tr', null,
                React.createElement('th', { style: { padding: '8px 6px', textAlign: 'left', color: 'var(--text-secondary)', fontWeight: 500, borderBottom: '1px solid rgba(255,255,255,0.1)' } }, '用途'),
                ...purposeDay.dayNames.map(d =>
                  React.createElement('th', {
                    key: d,
                    style: { padding: '8px 4px', textAlign: 'center', color: (d === '日' ? '#ef4444' : d === '土' ? '#3b82f6' : 'var(--text-secondary)'), fontWeight: 600, borderBottom: '1px solid rgba(255,255,255,0.1)', minWidth: '36px' },
                  }, d)
                )
              )
            ),
            React.createElement('tbody', null,
              (() => {
                const allCounts = purposeDay.purposes.flatMap(p => purposeDay.dayNames.map(d => purposeDay.matrix[p][d].count));
                const maxCount = Math.max(...allCounts, 1);
                return purposeDay.purposes.map(p => {
                  const rowTotal = purposeDay.dayNames.reduce((s, d) => s + purposeDay.matrix[p][d].count, 0);
                  if (rowTotal === 0) return null;
                  return React.createElement('tr', { key: p },
                    React.createElement('td', {
                      style: { padding: '6px', fontWeight: 500, whiteSpace: 'nowrap', borderBottom: '1px solid rgba(255,255,255,0.05)' },
                    }, p),
                    ...purposeDay.dayNames.map(d => {
                      const c = purposeDay.matrix[p][d].count;
                      const intensity = c / maxCount;
                      return React.createElement('td', {
                        key: d,
                        style: {
                          padding: '6px 4px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)',
                          background: c > 0 ? `rgba(26,115,232,${0.1 + intensity * 0.6})` : 'transparent',
                          color: c > 0 ? '#fff' : 'var(--text-muted)',
                          fontWeight: c > 0 ? 600 : 400, borderRadius: '4px',
                        },
                        title: `${p} ${d}曜: ${c}件 ¥${purposeDay.matrix[p][d].amount.toLocaleString()}`,
                      }, c > 0 ? c : '-');
                    })
                  );
                });
              })()
            )
          )
        )
      ),

      // B. 日種別（平日/休日/大型連休）分析
      React.createElement(Card, {
        title: '日種別×用途 分析',
        subtitle: '平日・休日・大型連休での乗車傾向',
        style: { marginBottom: 'var(--space-lg)' },
      },
        React.createElement('div', {
          style: { display: 'flex', gap: '12px', flexWrap: 'wrap', marginBottom: 'var(--space-md)', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' },
        },
          React.createElement('span', null, `平日: ${purposeDay.dayTypeCounts.weekday}日分`),
          React.createElement('span', null, `休日: ${purposeDay.dayTypeCounts.holiday}日分`),
          React.createElement('span', null, `大型連休: ${purposeDay.dayTypeCounts.longHoliday}日分`)
        ),
        React.createElement('div', { style: { display: 'grid', gap: 'var(--space-md)' } },
          [
            { key: 'weekday', label: '平日', color: 'rgba(26,115,232,0.7)', icon: 'work' },
            { key: 'holiday', label: '休日', color: 'rgba(76,175,80,0.7)', icon: 'weekend' },
            { key: 'longHoliday', label: '大型連休', color: 'rgba(255,152,0,0.7)', icon: 'celebration' },
          ].map(dt => {
            const sorted = purposeDay.purposes
              .map(p => ({ name: p, count: purposeDay.typeMatrix[p][dt.key].count, amount: purposeDay.typeMatrix[p][dt.key].amount }))
              .filter(x => x.count > 0)
              .sort((a, b) => b.count - a.count);
            if (sorted.length === 0) return null;
            const totalCount = sorted.reduce((s, x) => s + x.count, 0);
            return React.createElement('div', { key: dt.key },
              React.createElement('div', {
                style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' },
              },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: dt.color } }, dt.icon),
                React.createElement('span', { style: { fontWeight: 600 } }, dt.label),
                React.createElement('span', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, `(${totalCount}件)`)
              ),
              // 積み上げバー
              React.createElement('div', {
                style: { display: 'flex', height: '24px', borderRadius: '6px', overflow: 'hidden', background: 'rgba(255,255,255,0.06)', marginBottom: '6px' },
              },
                ...sorted.slice(0, 5).map((s, i) => {
                  const pct = (s.count / totalCount) * 100;
                  const colors = ['rgba(26,115,232,0.8)', 'rgba(76,175,80,0.8)', 'rgba(255,193,7,0.8)', 'rgba(244,67,54,0.8)', 'rgba(156,39,176,0.8)'];
                  return React.createElement('div', {
                    key: s.name,
                    style: {
                      width: pct + '%', background: colors[i % colors.length],
                      display: 'flex', alignItems: 'center', justifyContent: 'center',
                      fontSize: '10px', fontWeight: 600, color: '#fff', whiteSpace: 'nowrap',
                    },
                    title: `${s.name}: ${s.count}件 (${Math.round(pct)}%) ¥${s.amount.toLocaleString()}`,
                  }, pct >= 12 ? s.name : '');
                })
              ),
              // ラベル行
              React.createElement('div', {
                style: { display: 'flex', flexWrap: 'wrap', gap: '8px', fontSize: '11px', color: 'var(--text-secondary)' },
              },
                ...sorted.slice(0, 5).map((s, i) => {
                  const colors = ['#1a73e8', '#4caf50', '#ffc107', '#f44336', '#9c27b0'];
                  return React.createElement('span', {
                    key: s.name,
                    style: { display: 'flex', alignItems: 'center', gap: '4px' },
                  },
                    React.createElement('span', { style: { width: '8px', height: '8px', borderRadius: '50%', background: colors[i % colors.length], display: 'inline-block' } }),
                    `${s.name} ${s.count}件`
                  );
                })
              )
            );
          })
        )
      ),

      // C. 今後30日の用途予測
      React.createElement(Card, {
        title: '今後30日間の用途予測',
        subtitle: '過去データから予測される乗車用途',
        style: { marginBottom: 'var(--space-lg)' },
      },
        purposeDay.predictions.length === 0
          ? React.createElement('div', { style: { textAlign: 'center', color: 'var(--text-muted)', padding: 'var(--space-lg)' } }, 'データが不足しています')
          : React.createElement('div', { style: { display: 'grid', gap: '4px' } },
              purposeDay.predictions.map(pred => {
                const dayTypeLabel = pred.dayType === 'weekday' ? '平日' : pred.dayType === 'holiday' ? '休日' : '大型連休';
                const dayTypeColor = pred.dayType === 'weekday' ? 'rgba(26,115,232,0.15)' : pred.dayType === 'holiday' ? 'rgba(76,175,80,0.15)' : 'rgba(255,152,0,0.15)';
                const dowColor = pred.dayOfWeek === '日' ? '#ef4444' : pred.dayOfWeek === '土' ? '#3b82f6' : 'var(--text-primary)';
                // 日付をM/D形式に
                const parts = pred.date.split('-');
                const dateLabel = `${parseInt(parts[1])}/${parseInt(parts[2])}`;
                return React.createElement('div', {
                  key: pred.date,
                  style: {
                    display: 'grid', gridTemplateColumns: '60px 30px 60px 1fr', gap: '8px', alignItems: 'center',
                    padding: '8px 10px', borderRadius: '6px', background: dayTypeColor,
                  },
                },
                  React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', fontWeight: 600 } }, dateLabel),
                  React.createElement('span', { style: { fontSize: 'var(--font-size-sm)', fontWeight: 600, color: dowColor } }, `(${pred.dayOfWeek})`),
                  React.createElement('span', {
                    style: { fontSize: '10px', padding: '2px 6px', borderRadius: '10px', textAlign: 'center',
                      background: pred.dayType === 'weekday' ? 'rgba(26,115,232,0.3)' : pred.dayType === 'holiday' ? 'rgba(76,175,80,0.3)' : 'rgba(255,152,0,0.3)',
                      color: '#fff', fontWeight: 500 },
                  }, dayTypeLabel),
                  React.createElement('div', {
                    style: { display: 'flex', gap: '6px', flexWrap: 'wrap' },
                  },
                    ...pred.topPurposes.map((tp, i) =>
                      React.createElement('span', {
                        key: tp.purpose,
                        style: {
                          fontSize: '11px', padding: '2px 8px', borderRadius: '12px',
                          background: i === 0 ? 'rgba(255,255,255,0.15)' : 'rgba(255,255,255,0.06)',
                          color: i === 0 ? '#fff' : 'var(--text-secondary)',
                          fontWeight: i === 0 ? 600 : 400,
                        },
                        title: `曜日実績: ${tp.dowCount}件 / 日種別実績: ${tp.typeCount}件`,
                      }, tp.purpose)
                    ),
                    pred.holiday && React.createElement('span', {
                      style: { fontSize: '10px', color: '#ef4444', fontWeight: 500 },
                    }, pred.holiday)
                  )
                );
              })
            )
      ),

      // D. 月別トレンド
      Object.keys(purposeDay.monthPurpose).length > 0 && React.createElement(Card, {
        title: '月別 用途トレンド',
        subtitle: '月ごとの用途別乗車件数推移',
        style: { marginBottom: 'var(--space-lg)' },
      },
        React.createElement('div', { style: { overflowX: 'auto' } },
          React.createElement('table', {
            style: { width: '100%', borderCollapse: 'collapse', fontSize: 'var(--font-size-xs)' },
          },
            React.createElement('thead', null,
              React.createElement('tr', null,
                React.createElement('th', { style: { padding: '6px', textAlign: 'left', color: 'var(--text-secondary)', borderBottom: '1px solid rgba(255,255,255,0.1)' } }, '月'),
                ...purposeDay.purposes.filter(p => {
                  return Object.values(purposeDay.monthPurpose).some(mp => mp[p] > 0);
                }).map(p =>
                  React.createElement('th', { key: p, style: { padding: '6px 4px', textAlign: 'center', color: 'var(--text-secondary)', borderBottom: '1px solid rgba(255,255,255,0.1)', minWidth: '40px' } }, p)
                )
              )
            ),
            React.createElement('tbody', null,
              ...Object.entries(purposeDay.monthPurpose)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .map(([month, data]) => {
                  const activePurposes = purposeDay.purposes.filter(p => Object.values(purposeDay.monthPurpose).some(mp => mp[p] > 0));
                  const maxInRow = Math.max(...activePurposes.map(p => data[p] || 0), 1);
                  // YYYY-MM → YYYY年M月
                  const [y, m] = month.split('-');
                  const monthLabel = `${y}年${parseInt(m)}月`;
                  return React.createElement('tr', { key: month },
                    React.createElement('td', {
                      style: { padding: '6px', fontWeight: 500, whiteSpace: 'nowrap', borderBottom: '1px solid rgba(255,255,255,0.05)' },
                    }, monthLabel),
                    ...activePurposes.map(p => {
                      const cnt = data[p] || 0;
                      const allMonthMax = Math.max(...Object.values(purposeDay.monthPurpose).map(mp => mp[p] || 0), 1);
                      const intensity = cnt / allMonthMax;
                      return React.createElement('td', {
                        key: p,
                        style: {
                          padding: '6px 4px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.05)',
                          background: cnt > 0 ? `rgba(76,175,80,${0.1 + intensity * 0.5})` : 'transparent',
                          color: cnt > 0 ? '#fff' : 'var(--text-muted)', fontWeight: cnt > 0 ? 600 : 400, borderRadius: '3px',
                        },
                      }, cnt > 0 ? cnt : '-');
                    })
                  );
                })
            )
          )
        )
      )
    ),

    // 業務予測タブ
    tab === 'forecast' && React.createElement(React.Fragment, null,

      // A. 今日のおすすめカード
      recommendation && React.createElement(Card, {
        style: { marginBottom: 'var(--space-lg)', padding: 'var(--space-lg)' },
      },
        React.createElement('div', {
          style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: 'var(--space-md)' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '28px', color: 'var(--color-accent)' } }, 'tips_and_updates'),
          React.createElement('h3', { style: { margin: 0 } }, '今日のおすすめ')
        ),
        React.createElement('div', {
          style: { display: 'flex', gap: '12px', flexWrap: 'wrap', marginBottom: 'var(--space-md)', fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)' },
        },
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '4px' } },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'calendar_today'),
            recommendation.currentCondition.dayOfWeek + '曜日'
          ),
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '4px' } },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'schedule'),
            recommendation.currentCondition.hour + '時台'
          )
        ),

        // 推定客単価
        React.createElement('div', {
          style: {
            textAlign: 'center', padding: 'var(--space-lg)', marginBottom: 'var(--space-md)',
            background: 'rgba(0,200,83,0.08)', borderRadius: '12px', border: '1px solid rgba(0,200,83,0.2)',
          },
        },
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)', marginBottom: '4px' } }, '推定客単価'),
          React.createElement('div', { style: { fontSize: '2rem', fontWeight: 700, color: 'var(--color-accent)' } },
            recommendation.estimatedUnitPrice > 0 ? '¥' + recommendation.estimatedUnitPrice.toLocaleString() : 'データ不足'
          ),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '4px' } },
            recommendation.currentCondition.dayOfWeek + '曜 ' + recommendation.currentCondition.hour + '時台の平均'
          )
        ),

        // TOP3エリア & 時間帯を横並び
        React.createElement('div', {
          style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 'var(--space-md)' },
        },
          // 売上が高いエリアTOP3
          React.createElement('div', null,
            React.createElement('div', {
              style: { fontSize: 'var(--font-size-sm)', fontWeight: 600, marginBottom: '8px', display: 'flex', alignItems: 'center', gap: '4px' },
            },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: 'var(--color-primary-light)' } }, 'place'),
              '売上が高いエリア'
            ),
            recommendation.topAreas.length > 0
              ? recommendation.topAreas.map((a, i) =>
                  React.createElement('div', {
                    key: i,
                    style: { display: 'flex', justifyContent: 'space-between', padding: '6px 0', borderBottom: '1px solid rgba(255,255,255,0.06)', fontSize: 'var(--font-size-sm)' },
                  },
                    React.createElement('span', null, (i + 1) + '. ' + a.name),
                    React.createElement('span', { style: { fontWeight: 500, color: 'var(--color-secondary)' } }, '¥' + a.amount.toLocaleString())
                  )
                )
              : React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, 'この時間帯のデータなし')
          ),

          // 単価が高い時間帯TOP3
          React.createElement('div', null,
            React.createElement('div', {
              style: { fontSize: 'var(--font-size-sm)', fontWeight: 600, marginBottom: '8px', display: 'flex', alignItems: 'center', gap: '4px' },
            },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: 'var(--color-warning)' } }, 'schedule'),
              '単価が高い時間帯'
            ),
            recommendation.topHours.length > 0
              ? recommendation.topHours.map((h, i) =>
                  React.createElement('div', {
                    key: i,
                    style: { display: 'flex', justifyContent: 'space-between', padding: '6px 0', borderBottom: '1px solid rgba(255,255,255,0.06)', fontSize: 'var(--font-size-sm)' },
                  },
                    React.createElement('span', null, (i + 1) + '. ' + h.name),
                    React.createElement('span', { style: { fontWeight: 500, color: 'var(--color-secondary)' } }, '¥' + h.avg.toLocaleString())
                  )
                )
              : React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' } }, 'この曜日のデータなし')
          )
        )
      ),

      // B. エリア×時間帯クロス分析
      areaTime.length > 0 && React.createElement(Card, { title: 'エリア×時間帯クロス分析', style: { marginBottom: 'var(--space-lg)' } },
        React.createElement('div', { style: { overflowX: 'auto' } },
          React.createElement('div', {
            style: {
              display: 'grid',
              gridTemplateColumns: '120px repeat(6, 1fr)',
              gap: '2px',
              fontSize: 'var(--font-size-xs)',
              minWidth: '500px',
            },
          },
            // ヘッダー行
            React.createElement('div', { style: { padding: '6px 4px', fontWeight: 600, color: 'var(--text-secondary)' } }, 'エリア'),
            ...['0-3', '4-7', '8-11', '12-15', '16-19', '20-23'].map(label =>
              React.createElement('div', { key: label, style: { padding: '6px 4px', textAlign: 'center', fontWeight: 600, color: 'var(--text-secondary)' } }, label + '時')
            ),

            // データ行（上位5エリア）
            ...areaTime.slice(0, 5).flatMap((a) => {
              const timeSlots = [
                { start: 0, end: 3 }, { start: 4, end: 7 }, { start: 8, end: 11 },
                { start: 12, end: 15 }, { start: 16, end: 19 }, { start: 20, end: 23 },
              ];
              const slotData = timeSlots.map(slot => {
                let count = 0, amount = 0;
                for (let h = slot.start; h <= slot.end; h++) {
                  count += a.hours[h].count;
                  amount += a.hours[h].amount;
                }
                return { count, amount };
              });
              const maxCount = Math.max(...slotData.map(s => s.count), 1);

              return [
                React.createElement('div', {
                  key: a.area + '-label',
                  style: { padding: '8px 4px', fontWeight: 500, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', borderBottom: '1px solid rgba(255,255,255,0.06)' },
                  title: a.area,
                }, a.area.length > 10 ? a.area.slice(0, 10) + '…' : a.area),
                ...slotData.map((s, si) => {
                  const intensity = s.count > 0 ? Math.max(0.1, s.count / maxCount) : 0;
                  return React.createElement('div', {
                    key: a.area + '-' + si,
                    style: {
                      padding: '8px 4px', textAlign: 'center', borderRadius: '4px',
                      background: intensity > 0 ? 'rgba(26,115,232,' + (intensity * 0.5) + ')' : 'transparent',
                      borderBottom: '1px solid rgba(255,255,255,0.06)',
                      color: intensity > 0.5 ? '#fff' : 'var(--text-secondary)',
                    },
                    title: a.area + ' ' + ['0-3', '4-7', '8-11', '12-15', '16-19', '20-23'][si] + '時: ' + s.count + '件 ¥' + s.amount.toLocaleString(),
                  }, s.count > 0 ? s.count + '件' : '-');
                })
              ];
            })
          )
        ),
        React.createElement('div', {
          style: { marginTop: '8px', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', display: 'flex', alignItems: 'center', gap: '8px' },
        },
          React.createElement('span', null, '色の濃さ = 件数の多さ'),
          React.createElement('span', null, '|'),
          React.createElement('span', null, 'セルをタップで詳細表示')
        )
      ),

      // C. 客単価分析
      unitPrice && React.createElement(Card, { title: '客単価分析', style: { marginBottom: 'var(--space-lg)' } },
        // 曜日別
        React.createElement('div', { style: { marginBottom: 'var(--space-lg)' } },
          React.createElement('h4', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' } }, '曜日別 平均客単価'),
          React.createElement(BarChart, {
            data: unitPrice.byDayOfWeek, valueKey: 'avg', labelKey: 'name', color: 'var(--color-primary-light)', height: 140,
          }),
          React.createElement('div', {
            style: { display: 'flex', justifyContent: 'space-around', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '6px' },
          }, unitPrice.byDayOfWeek.map(d => React.createElement('span', { key: d.name }, d.name)))
        ),

        // 時間帯別
        React.createElement('div', { style: { marginBottom: 'var(--space-lg)' } },
          React.createElement('h4', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' } }, '時間帯別 平均客単価'),
          React.createElement(BarChart, {
            data: unitPrice.byHour, valueKey: 'avg', labelKey: 'name', color: 'var(--color-accent)', height: 140, maxBars: 24,
          }),
          React.createElement('div', {
            style: { display: 'flex', justifyContent: 'space-between', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)', marginTop: '6px', padding: '0 4px' },
          },
            React.createElement('span', null, '0時'),
            React.createElement('span', null, '6時'),
            React.createElement('span', null, '12時'),
            React.createElement('span', null, '18時'),
            React.createElement('span', null, '23時')
          )
        ),

        // 用途別
        React.createElement('div', { style: { marginBottom: 'var(--space-lg)' } },
          React.createElement('h4', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' } }, '用途別 平均客単価'),
          React.createElement(HBarChart, {
            data: unitPrice.byPurpose.filter(p => p.count > 0), nameKey: 'name', valueKey: 'avg', color: 'var(--color-warning)',
          })
        ),

        // 人数別
        React.createElement('div', null,
          React.createElement('h4', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' } }, '人数別 平均客単価'),
          React.createElement(HBarChart, {
            data: unitPrice.byPassengers.filter(p => p.count > 0), nameKey: 'name', valueKey: 'avg', color: 'var(--color-secondary)',
          })
        )
      ),

      // D. 配車方法・用途分析
      sourceData.length > 0 && React.createElement(Card, { title: '配車方法・用途分析' },
        // 配車方法別
        React.createElement('div', { style: { marginBottom: 'var(--space-lg)' } },
          React.createElement('h4', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' } }, '配車方法別'),
          React.createElement('div', { style: { marginBottom: '12px' } },
            React.createElement(HBarChart, {
              data: sourceData.filter(s => s.count > 0), nameKey: 'name', valueKey: 'amount', color: 'var(--color-primary-light)',
            })
          ),
          React.createElement('div', {
            style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(140px, 1fr))', gap: '8px' },
          },
            sourceData.filter(s => s.count > 0).map((s, i) =>
              React.createElement('div', {
                key: i,
                style: {
                  padding: '8px', borderRadius: '8px', background: 'rgba(255,255,255,0.04)',
                  fontSize: 'var(--font-size-xs)', textAlign: 'center',
                },
              },
                React.createElement('div', { style: { fontWeight: 600, marginBottom: '2px' } }, s.name),
                React.createElement('div', { style: { color: 'var(--text-secondary)' } }, s.count + '件'),
                React.createElement('div', { style: { color: 'var(--color-secondary)', fontWeight: 500 } }, '平均¥' + s.avg.toLocaleString())
              )
            )
          )
        ),

        // 用途別
        React.createElement('div', null,
          React.createElement('h4', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' } }, '用途別'),
          React.createElement('div', { style: { marginBottom: '12px' } },
            React.createElement(HBarChart, {
              data: purposeData.filter(p => p.count > 0), nameKey: 'name', valueKey: 'amount', color: 'var(--color-accent)',
            })
          ),
          React.createElement('div', {
            style: { display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(140px, 1fr))', gap: '8px' },
          },
            purposeData.filter(p => p.count > 0).map((p, i) =>
              React.createElement('div', {
                key: i,
                style: {
                  padding: '8px', borderRadius: '8px', background: 'rgba(255,255,255,0.04)',
                  fontSize: 'var(--font-size-xs)', textAlign: 'center',
                },
              },
                React.createElement('div', { style: { fontWeight: 600, marginBottom: '2px' } }, p.name),
                React.createElement('div', { style: { color: 'var(--text-secondary)' } }, p.count + '件'),
                React.createElement('div', { style: { color: 'var(--color-secondary)', fontWeight: 500 } }, '平均¥' + p.avg.toLocaleString())
              )
            )
          )
        )
      ),

      // E. 配車方法×エリア×単価ランク クロス分析
      sourceAreaPrice && sourceAreaPrice.matrixData && sourceAreaPrice.matrixData.length > 0 && React.createElement(Card, {
        title: '配車方法×エリア×単価 クロス分析',
        style: { marginBottom: 'var(--space-lg)' },
      },
        // 凡例
        React.createElement('div', {
          style: { display: 'flex', gap: '12px', marginBottom: 'var(--space-md)', fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)', flexWrap: 'wrap' },
        },
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '4px' } },
            React.createElement('span', { style: { width: '10px', height: '10px', borderRadius: '2px', background: 'rgba(244,67,54,0.6)', display: 'inline-block' } }),
            '¥2,000以上'
          ),
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '4px' } },
            React.createElement('span', { style: { width: '10px', height: '10px', borderRadius: '2px', background: 'rgba(255,193,7,0.6)', display: 'inline-block' } }),
            '¥1,001〜1,999'
          ),
          React.createElement('span', { style: { display: 'flex', alignItems: 'center', gap: '4px' } },
            React.createElement('span', { style: { width: '10px', height: '10px', borderRadius: '2px', background: 'rgba(76,175,80,0.6)', display: 'inline-block' } }),
            '¥1,000以下'
          )
        ),

        // エリア×配車方法マトリクス（平均単価 + 単価ランク内訳バー）
        React.createElement('div', { style: { overflowX: 'auto' } },
          React.createElement('div', {
            style: {
              display: 'grid',
              gridTemplateColumns: '100px repeat(5, 1fr)',
              gap: '2px',
              fontSize: 'var(--font-size-xs)',
              minWidth: '480px',
            },
          },
            // ヘッダー
            React.createElement('div', { style: { padding: '8px 4px', fontWeight: 600, color: 'var(--text-secondary)' } }, 'エリア'),
            ...sourceAreaPrice.sources.map(s =>
              React.createElement('div', { key: s, style: { padding: '8px 4px', textAlign: 'center', fontWeight: 600, color: 'var(--text-secondary)' } }, s)
            ),

            // データ行
            ...sourceAreaPrice.matrixData.flatMap(row => [
              React.createElement('div', {
                key: row.area + '-lbl',
                style: { padding: '8px 4px', fontWeight: 500, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', borderBottom: '1px solid rgba(255,255,255,0.06)', display: 'flex', alignItems: 'center' },
                title: row.area,
              }, row.area.length > 8 ? row.area.slice(0, 8) + '…' : row.area),

              ...sourceAreaPrice.sources.map(src => {
                const d = row[src];
                if (d.count === 0) {
                  return React.createElement('div', {
                    key: row.area + '-' + src,
                    style: { padding: '8px 4px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.06)', color: 'var(--text-muted)' },
                  }, '-');
                }
                const total = d.tiers.short + d.tiers.mid + d.tiers.long;
                const pctS = total > 0 ? (d.tiers.short / total) * 100 : 0;
                const pctM = total > 0 ? (d.tiers.mid / total) * 100 : 0;
                const pctL = total > 0 ? (d.tiers.long / total) * 100 : 0;
                return React.createElement('div', {
                  key: row.area + '-' + src,
                  style: { padding: '6px 4px', borderBottom: '1px solid rgba(255,255,255,0.06)', textAlign: 'center' },
                  title: row.area + ' × ' + src + ': ' + d.count + '件 平均¥' + d.avg.toLocaleString() + ' (短' + d.tiers.short + '/中' + d.tiers.mid + '/長' + d.tiers.long + ')',
                },
                  React.createElement('div', { style: { fontWeight: 600, marginBottom: '3px' } }, '¥' + d.avg.toLocaleString()),
                  React.createElement('div', { style: { fontSize: '9px', color: 'var(--text-muted)', marginBottom: '3px' } }, d.count + '件'),
                  // 単価ランク内訳バー
                  React.createElement('div', {
                    style: { display: 'flex', height: '4px', borderRadius: '2px', overflow: 'hidden', background: 'rgba(255,255,255,0.06)' },
                  },
                    pctS > 0 && React.createElement('div', { style: { width: pctS + '%', background: 'rgba(76,175,80,0.7)' } }),
                    pctM > 0 && React.createElement('div', { style: { width: pctM + '%', background: 'rgba(255,193,7,0.7)' } }),
                    pctL > 0 && React.createElement('div', { style: { width: pctL + '%', background: 'rgba(244,67,54,0.7)' } })
                  )
                );
              })
            ])
          )
        ),

        React.createElement('div', {
          style: { marginTop: '8px', fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' },
        }, 'セルをタップで詳細表示 | バー: 緑=短距離 黄=中距離 赤=長距離')
      ),

      // 配車方法別 単価ランク構成
      sourceAreaPrice && sourceAreaPrice.sourceTierList && sourceAreaPrice.sourceTierList.some(s => s.totalCount > 0) && React.createElement(Card, {
        title: '配車方法別 単価ランク構成',
        style: { marginBottom: 'var(--space-lg)' },
      },
        React.createElement('div', { style: { display: 'grid', gap: 'var(--space-md)' } },
          sourceAreaPrice.sourceTierList.filter(s => s.totalCount > 0).map(s =>
            React.createElement('div', { key: s.source },
              React.createElement('div', {
                style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '4px' },
              },
                React.createElement('span', { style: { fontWeight: 600, fontSize: 'var(--font-size-sm)' } }, s.source),
                React.createElement('span', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } }, s.totalCount + '件')
              ),
              // 積み上げバー
              React.createElement('div', {
                style: { display: 'flex', height: '20px', borderRadius: '4px', overflow: 'hidden', background: 'rgba(255,255,255,0.06)' },
              },
                ...s.tiers.map(t => {
                  const pct = s.totalCount > 0 ? (t.count / s.totalCount) * 100 : 0;
                  if (pct === 0) return null;
                  const colors = { short: 'rgba(76,175,80,0.7)', mid: 'rgba(255,193,7,0.7)', long: 'rgba(244,67,54,0.7)' };
                  return React.createElement('div', {
                    key: t.key,
                    style: {
                      width: pct + '%', background: colors[t.key],
                      display: 'flex', alignItems: 'center', justifyContent: 'center',
                      fontSize: '9px', fontWeight: 600, color: '#fff', whiteSpace: 'nowrap',
                      minWidth: pct > 8 ? 'auto' : '0',
                    },
                    title: t.label + ': ' + t.count + '件 平均¥' + t.avg.toLocaleString(),
                  }, pct >= 15 ? Math.round(pct) + '%' : '');
                })
              ),
              // ラベル
              React.createElement('div', {
                style: { display: 'flex', justifyContent: 'space-between', marginTop: '3px', fontSize: '10px', color: 'var(--text-muted)' },
              },
                ...s.tiers.filter(t => t.count > 0).map(t =>
                  React.createElement('span', { key: t.key }, t.label + ' ' + t.count + '件 avg¥' + t.avg.toLocaleString())
                )
              )
            )
          )
        )
      ),

      // エリア別 単価ランク構成
      sourceAreaPrice && sourceAreaPrice.areaTierList && sourceAreaPrice.areaTierList.length > 0 && React.createElement(Card, {
        title: 'エリア別 単価ランク構成',
        style: { marginBottom: 'var(--space-lg)' },
      },
        React.createElement('div', { style: { display: 'grid', gap: 'var(--space-md)' } },
          sourceAreaPrice.areaTierList.map(a =>
            React.createElement('div', { key: a.area },
              React.createElement('div', {
                style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '4px' },
              },
                React.createElement('span', {
                  style: { fontWeight: 600, fontSize: 'var(--font-size-sm)', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', maxWidth: '60%' },
                  title: a.area,
                }, a.area),
                React.createElement('span', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } }, a.total + '件')
              ),
              // 積み上げバー
              React.createElement('div', {
                style: { display: 'flex', height: '16px', borderRadius: '4px', overflow: 'hidden', background: 'rgba(255,255,255,0.06)' },
              },
                ...a.tiers.map(t => {
                  if (t.pct === 0) return null;
                  const colors = { short: 'rgba(76,175,80,0.7)', mid: 'rgba(255,193,7,0.7)', long: 'rgba(244,67,54,0.7)' };
                  return React.createElement('div', {
                    key: t.key,
                    style: {
                      width: t.pct + '%', background: colors[t.key],
                      display: 'flex', alignItems: 'center', justifyContent: 'center',
                      fontSize: '9px', fontWeight: 600, color: '#fff',
                    },
                    title: t.label + ': ' + t.count + '件 (' + t.pct + '%)',
                  }, t.pct >= 15 ? t.pct + '%' : '');
                })
              )
            )
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/Settings.jsx
// ============================================================
(function() {
// Settings.jsx - 設定ページ
window.SettingsPage = () => {
  const { useState } = React;
  const { apiKey, setApiKey, geminiApiKey, setGeminiApiKey } = useAppContext();
  const [inputKey, setInputKey] = useState(apiKey);
  const [saved, setSaved] = useState(false);
  const [geminiInputKey, setGeminiInputKey] = useState(geminiApiKey);
  const [geminiSaved, setGeminiSaved] = useState(false);
  const [geminiTesting, setGeminiTesting] = useState(false);
  const [geminiTestResult, setGeminiTestResult] = useState(null);

  // クラウド同期
  const [syncSecret, setSyncSecret] = useState(localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.SYNC_SECRET) || '');
  const [syncSaved, setSyncSaved] = useState(false);
  const [syncTesting, setSyncTesting] = useState(false);
  const [syncTestResult, setSyncTestResult] = useState(null);
  const [syncStatus, setSyncStatus] = useState(null);
  const [refreshKey, setRefreshKey] = useState(0);

  const [dailyGoal, setDailyGoal] = useState(() => {
    const s = JSON.parse(localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.SETTINGS) || '{}');
    return s.dailyGoal || '';
  });
  const [goalSaved, setGoalSaved] = useState(false);

  const handleSave = () => {
    setApiKey(inputKey.trim());
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
  };

  const handleClear = () => {
    setApiKey('');
    setInputKey('');
    window._gmapLoader.reset();
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
  };

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'settings'),
      '設定'
    ),

    // Google Maps API キー
    React.createElement(Card, { title: 'Google Maps API キー', style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('p', {
        style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: 'var(--space-md)' },
      }, 'Google Maps を表示するにはAPIキーが必要です。'),

      React.createElement('div', { className: 'form-group' },
        React.createElement('label', { className: 'form-label' }, 'APIキー'),
        React.createElement('input', {
          className: 'form-input',
          type: 'password',
          placeholder: 'AIzaSy...',
          value: inputKey,
          onChange: (e) => setInputKey(e.target.value),
          style: { fontFamily: 'monospace' },
        })
      ),

      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap' } },
        React.createElement(Button, {
          variant: 'primary',
          icon: 'save',
          onClick: handleSave,
        }, '保存'),
        inputKey && React.createElement(Button, {
          variant: 'secondary',
          icon: 'delete',
          onClick: handleClear,
        }, 'クリア'),
        saved && React.createElement('span', {
          style: { color: 'var(--color-accent)', fontSize: 'var(--font-size-sm)', display: 'flex', alignItems: 'center', gap: '4px' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'check_circle'),
          '保存しました'
        ),
        apiKey && React.createElement('span', { className: 'badge badge--success' }, 'APIキー設定済み'),
        !apiKey && React.createElement('span', { className: 'badge badge--warning' }, 'デモモード')
      ),

      // トラブルシューティング
      apiKey && React.createElement('div', {
        style: {
          marginTop: 'var(--space-md)', padding: 'var(--space-md)',
          background: 'rgba(249, 168, 37, 0.08)', borderRadius: '8px', border: '1px solid rgba(249, 168, 37, 0.2)',
        },
      },
        React.createElement('div', {
          style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--color-secondary)' } }, 'info'),
          React.createElement('strong', { style: { fontSize: 'var(--font-size-sm)', color: 'var(--color-secondary)' } }, '地図が正しく表示されない場合')
        ),
        React.createElement('div', {
          style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)', lineHeight: 1.8 },
        },
          React.createElement('p', { style: { margin: '4px 0' } }, '「For development purposes only」と表示される場合：'),
          React.createElement('p', { style: { margin: '2px 0', paddingLeft: '12px' } }, '① Google Cloud Console で請求先アカウント（Billing）を有効にしてください'),
          React.createElement('p', { style: { margin: '2px 0', paddingLeft: '12px' } }, '② 「Maps JavaScript API」が有効になっていることを確認してください'),
          React.createElement('p', { style: { margin: '4px 0', marginTop: '8px' } }, '地図が全く表示されない場合：'),
          React.createElement('p', { style: { margin: '2px 0', paddingLeft: '12px' } }, '③ APIキーの「アプリケーションの制限」で HTTP リファラーを「なし」に設定してください'),
          React.createElement('p', { style: { margin: '2px 0', paddingLeft: '12px' } }, '④ ローカルファイルから開く場合、リファラー制限があると動作しません')
        )
      ),

      // 取得手順
      React.createElement('details', {
        style: { marginTop: 'var(--space-md)', cursor: 'pointer' },
      },
        React.createElement('summary', {
          style: { color: 'var(--color-primary-light)', fontSize: 'var(--font-size-sm)' },
        }, 'APIキーの取得方法（初めての方）'),
        React.createElement('div', {
          style: { padding: 'var(--space-md)', color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)', lineHeight: 1.8 },
        },
          React.createElement('p', null, '1. Google Cloud Console（https://console.cloud.google.com）にアクセス'),
          React.createElement('p', null, '2. プロジェクトを作成または選択'),
          React.createElement('p', { style: { color: 'var(--color-warning)' } }, '3. 「お支払い」から請求先アカウントを設定（月$200分の無料枠あり）'),
          React.createElement('p', null, '4. 「APIとサービス」→「ライブラリ」から「Maps JavaScript API」を有効化'),
          React.createElement('p', null, '5. 「認証情報」→「認証情報を作成」→「APIキー」を選択'),
          React.createElement('p', { style: { color: 'var(--color-warning)' } }, '6. APIキーの「アプリケーションの制限」は「なし」に設定'),
          React.createElement('p', null, '7. 上のフォームにAPIキーを貼り付けて保存'),
          React.createElement('p', {
            style: { marginTop: '8px', padding: '8px 12px', background: 'rgba(0,200,83,0.08)', borderRadius: '6px', color: 'var(--color-accent)' },
          }, '※ 月$200の無料クレジットがあるため、個人利用では通常料金はかかりません。')
        )
      )
    ),

    // Gemini API キー
    React.createElement(Card, { title: 'Gemini API キー（AI検索）', style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('p', {
        style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: 'var(--space-md)' },
      }, 'Google Gemini を使用して公共交通機関情報やイベント情報をAI検索できます。'),

      React.createElement('div', { className: 'form-group' },
        React.createElement('label', { className: 'form-label' }, 'Gemini APIキー'),
        React.createElement('input', {
          className: 'form-input',
          type: 'password',
          placeholder: 'AIzaSy...',
          value: geminiInputKey,
          onChange: (e) => setGeminiInputKey(e.target.value),
          style: { fontFamily: 'monospace' },
        })
      ),

      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap' } },
        React.createElement(Button, {
          variant: 'primary',
          icon: 'save',
          onClick: () => {
            setGeminiApiKey(geminiInputKey.trim());
            setGeminiSaved(true);
            setGeminiTestResult(null);
            setTimeout(() => setGeminiSaved(false), 2000);
          },
        }, '保存'),
        geminiInputKey && React.createElement(Button, {
          variant: 'secondary',
          icon: 'delete',
          onClick: () => {
            setGeminiApiKey('');
            setGeminiInputKey('');
            setGeminiTestResult(null);
            setGeminiSaved(true);
            setTimeout(() => setGeminiSaved(false), 2000);
          },
        }, 'クリア'),
        geminiInputKey && React.createElement(Button, {
          variant: 'secondary',
          icon: geminiTesting ? 'sync' : 'network_check',
          onClick: async () => {
            setGeminiTesting(true);
            setGeminiTestResult(null);
            const result = await GeminiService.testConnection(geminiInputKey.trim());
            setGeminiTesting(false);
            setGeminiTestResult(result.success ? 'success' : result.error);
          },
          disabled: geminiTesting,
        }, geminiTesting ? 'テスト中...' : '接続テスト'),
        geminiSaved && React.createElement('span', {
          style: { color: 'var(--color-accent)', fontSize: 'var(--font-size-sm)', display: 'flex', alignItems: 'center', gap: '4px' },
        },
          React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'check_circle'),
          '保存しました'
        ),
        geminiApiKey && React.createElement('span', { className: 'badge badge--success' }, 'APIキー設定済み'),
        !geminiApiKey && React.createElement('span', { className: 'badge badge--warning' }, '未設定')
      ),

      geminiTestResult && React.createElement('div', {
        style: {
          marginTop: 'var(--space-md)', padding: '8px 12px', borderRadius: '8px',
          background: geminiTestResult === 'success' ? 'rgba(0,200,83,0.1)' : 'rgba(229,57,53,0.1)',
          border: `1px solid ${geminiTestResult === 'success' ? 'rgba(0,200,83,0.3)' : 'rgba(229,57,53,0.3)'}`,
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: geminiTestResult === 'success' ? 'var(--color-accent)' : 'var(--color-danger)' },
        }, geminiTestResult === 'success' ? 'check_circle' : 'error'),
        React.createElement('span', {
          style: { fontSize: 'var(--font-size-sm)', color: geminiTestResult === 'success' ? 'var(--color-accent)' : 'var(--color-danger)' },
        }, geminiTestResult === 'success' ? 'Gemini APIに正常に接続できました' : geminiTestResult)
      ),

      React.createElement('details', {
        style: { marginTop: 'var(--space-md)', cursor: 'pointer' },
      },
        React.createElement('summary', {
          style: { color: 'var(--color-primary-light)', fontSize: 'var(--font-size-sm)' },
        }, 'Gemini APIキーの取得方法'),
        React.createElement('div', {
          style: { padding: 'var(--space-md)', color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)', lineHeight: 1.8 },
        },
          React.createElement('p', null, '1. Google AI Studio（https://aistudio.google.com）にアクセス'),
          React.createElement('p', null, '2. Googleアカウントでログイン'),
          React.createElement('p', null, '3. 「Get API Key」→「Create API key」をクリック'),
          React.createElement('p', null, '4. 生成されたAPIキーをコピー'),
          React.createElement('p', null, '5. 上のフォームに貼り付けて保存'),
          React.createElement('p', {
            style: { marginTop: '8px', padding: '8px 12px', background: 'rgba(0,200,83,0.08)', borderRadius: '6px', color: 'var(--color-accent)' },
          }, '※ 無料枠: 15リクエスト/分、1,500リクエスト/日（Gemini 2.0 Flash）')
        )
      )
    ),

    // クラウド同期
    React.createElement(Card, { title: 'クラウド同期', style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('p', {
        style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: 'var(--space-md)' },
      }, 'Vercel Blob Storageを使用してデータをクラウドに保存・同期します。記録追加時に自動的にクラウドへ保存されます。'),

      React.createElement('div', { className: 'form-group', style: { marginBottom: 'var(--space-md)' } },
        React.createElement('label', { className: 'form-label' }, '同期シークレット'),
        React.createElement('input', {
          className: 'form-input',
          type: 'password',
          placeholder: 'Vercel環境変数のSYNC_SECRETと同じ値',
          value: syncSecret,
          onChange: (e) => setSyncSecret(e.target.value),
          style: { fontFamily: 'monospace' },
        }),
        React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginTop: '8px' } },
          React.createElement(Button, {
            variant: 'primary',
            icon: 'save',
            onClick: () => {
              localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.SYNC_SECRET, syncSecret.trim());
              setSyncStatus('シークレットを保存しました');
              setTimeout(() => setSyncStatus(null), 2000);
            },
          }, '保存'),
          React.createElement('span', {
            style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-muted)' },
          }, '※ Vercelダッシュボードの環境変数SYNC_SECRETと同じ値を設定')
        )
      ),

      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap', marginBottom: 'var(--space-md)' } },
        React.createElement(Button, {
          variant: 'secondary',
          icon: syncTesting ? 'sync' : 'network_check',
          onClick: async () => {
            setSyncTesting(true);
            setSyncTestResult(null);
            try {
              const res = await fetch('/api/data?type=revenue');
              if (res.ok) {
                setSyncTestResult('success');
              } else {
                let detail = '';
                try { const j = await res.json(); detail = j.detail || j.error || ''; } catch {}
                setSyncTestResult(`エラー: ${res.status}${detail ? ' - ' + detail : ''}`);
              }
            } catch (e) {
              setSyncTestResult('接続エラー: ' + e.message);
            }
            setSyncTesting(false);
          },
          disabled: syncTesting,
        }, syncTesting ? 'テスト中...' : '接続テスト')
      ),

      // 接続テスト結果
      syncTestResult && React.createElement('div', {
        style: {
          marginBottom: 'var(--space-md)', padding: '8px 12px', borderRadius: '8px',
          background: syncTestResult === 'success' ? 'rgba(0,200,83,0.1)' : 'rgba(229,57,53,0.1)',
          border: `1px solid ${syncTestResult === 'success' ? 'rgba(0,200,83,0.3)' : 'rgba(229,57,53,0.3)'}`,
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '18px', color: syncTestResult === 'success' ? 'var(--color-accent)' : 'var(--color-danger)' },
        }, syncTestResult === 'success' ? 'check_circle' : 'error'),
        React.createElement('span', {
          style: { fontSize: 'var(--font-size-sm)', color: syncTestResult === 'success' ? 'var(--color-accent)' : 'var(--color-danger)' },
        }, syncTestResult === 'success' ? 'クラウドに正常に接続できました' : syncTestResult)
      ),

      // 自動同期ステータス
      React.createElement('div', {
        style: {
          padding: '8px 12px', borderRadius: '8px', marginBottom: 'var(--space-md)',
          background: syncSecret ? 'rgba(0, 200, 83, 0.1)' : 'rgba(255, 152, 0, 0.1)',
          border: `1px solid ${syncSecret ? 'rgba(0, 200, 83, 0.3)' : 'rgba(255, 152, 0, 0.3)'}`,
          display: 'flex', alignItems: 'center', gap: '8px',
          fontSize: 'var(--font-size-sm)',
          color: syncSecret ? 'var(--color-accent)' : 'var(--color-warning)',
        },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, syncSecret ? 'sync' : 'sync_disabled'),
        syncSecret ? '自動同期: 有効（起動時・タブ復帰時・5分間隔）' : '自動同期: SYNC_SECRET未設定のため無効'
      ),

      // 手動同期ボタン
      React.createElement('div', {
        style: { display: 'flex', gap: '12px', flexWrap: 'wrap', marginBottom: 'var(--space-md)' },
      },
        React.createElement(Button, {
          variant: 'primary',
          icon: 'cloud_upload',
          onClick: async () => {
            setSyncStatus('送信中...');
            try {
              const revenueEntries = DataService.getEntries();
              const rivalEntries = DataService.getRivalEntries();
              const secret = (localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.SYNC_SECRET) || '').trim();
              const headers = { 'Content-Type': 'application/json', ...(secret ? { 'Authorization': `Bearer ${secret}` } : {}) };
              const [r1, r2] = await Promise.all([
                fetch('/api/data?type=revenue', { method: 'POST', headers, body: JSON.stringify({ version: APP_CONSTANTS.VERSION, syncedAt: new Date().toISOString(), count: revenueEntries.length, entries: revenueEntries }) }),
                fetch('/api/data?type=rival', { method: 'POST', headers, body: JSON.stringify({ version: APP_CONSTANTS.VERSION, syncedAt: new Date().toISOString(), count: rivalEntries.length, entries: rivalEntries }) }),
              ]);
              if (r1.ok && r2.ok) {
                setSyncStatus(`送信完了: 売上${revenueEntries.length}件, 他社${rivalEntries.length}件`);
              } else {
                let d1 = '', d2 = '';
                try { const j = await r1.json(); d1 = j.detail || j.error || ''; } catch {}
                try { const j = await r2.json(); d2 = j.detail || j.error || ''; } catch {}
                setSyncStatus(`送信エラー: revenue=${r1.status}${d1 ? '(' + d1 + ')' : ''}, rival=${r2.status}${d2 ? '(' + d2 + ')' : ''}`);
              }
            } catch (e) {
              setSyncStatus('送信エラー: ' + e.message);
            }
          },
        }, 'クラウドに送信'),
        React.createElement(Button, {
          variant: 'secondary',
          icon: 'cloud_download',
          onClick: async () => {
            setSyncStatus('取得中...');
            try {
              const [r1, r2] = await Promise.all([
                DataService.syncFromCloud('revenue'),
                DataService.syncFromCloud('rival'),
              ]);
              setSyncStatus(`取得完了: 売上+${r1.merged}件, 他社+${r2.merged}件`);
            } catch (e) {
              setSyncStatus('取得エラー: ' + e.message);
            }
          },
        }, 'クラウドから取得')
      ),

      // 同期状態表示
      syncStatus && React.createElement('div', {
        style: {
          padding: '8px 12px', borderRadius: '8px',
          background: 'rgba(66, 165, 245, 0.1)', border: '1px solid rgba(66, 165, 245, 0.3)',
          fontSize: 'var(--font-size-sm)', color: 'var(--color-primary-light)',
          display: 'flex', alignItems: 'center', gap: '8px',
        },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, 'cloud_sync'),
        syncStatus
      )
    ),

    // プッシュ通知設定
    React.createElement(Card, { title: 'プッシュ通知', style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('p', {
        style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: 'var(--space-md)' },
      }, '交通機関の遅延・トラブル情報をブラウザ通知でお知らせします。'),
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between' } },
        React.createElement('div', null,
          React.createElement('div', { style: { fontWeight: 500, fontSize: 'var(--font-size-sm)' } }, '通知'),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } },
            !NotificationService.isSupported() ? 'このブラウザは通知に対応していません'
              : NotificationService.getPermission() === 'denied' ? 'ブラウザの通知が拒否されています。ブラウザ設定から許可してください'
              : '遅延・運休・事故などの交通情報を自動通知'
          )
        ),
        React.createElement('button', {
          onClick: async () => {
            if (!NotificationService.isSupported()) return;
            if (NotificationService.isEnabled()) {
              NotificationService.setEnabled(false);
              setRefreshKey(k => k + 1);
            } else {
              const perm = await NotificationService.requestPermission();
              if (perm === 'granted') {
                NotificationService.setEnabled(true);
                NotificationService.send('通知テスト', { body: '通知が有効になりました' });
              }
              setRefreshKey(k => k + 1);
            }
          },
          disabled: !NotificationService.isSupported() || NotificationService.getPermission() === 'denied',
          style: {
            padding: '8px 20px', borderRadius: '20px', border: 'none', cursor: 'pointer',
            fontWeight: 700, fontSize: 'var(--font-size-sm)', fontFamily: 'var(--font-family)',
            background: NotificationService.isEnabled() ? 'var(--color-accent)' : 'rgba(255,255,255,0.1)',
            color: NotificationService.isEnabled() ? '#fff' : 'var(--text-secondary)',
            opacity: (!NotificationService.isSupported() || NotificationService.getPermission() === 'denied') ? 0.5 : 1,
            transition: 'all 0.2s ease',
          },
        }, NotificationService.isEnabled() ? 'ON' : 'OFF')
      )
    ),

    // 日額目標金額設定
    React.createElement(Card, { title: '日額目標金額', style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('p', {
        style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: 'var(--space-md)' },
      }, '1日の売上目標金額を設定します。月間目標は日額×稼働日数で自動計算されます。'),
      React.createElement('div', { style: { display: 'flex', gap: '8px', alignItems: 'center' } },
        React.createElement('span', { style: { color: 'var(--text-secondary)', fontWeight: 500 } }, '¥'),
        React.createElement('input', {
          type: 'number',
          value: dailyGoal,
          onChange: (e) => setDailyGoal(e.target.value),
          placeholder: '例: 50000',
          style: {
            flex: 1, padding: '10px 12px', borderRadius: '8px',
            border: '1px solid rgba(255,255,255,0.15)',
            background: 'rgba(255,255,255,0.06)',
            color: 'var(--text-primary)',
            fontSize: 'var(--font-size-md)',
            fontFamily: 'var(--font-family)',
          },
        }),
        React.createElement(Button, {
          variant: 'primary',
          onClick: () => {
            const settings = JSON.parse(localStorage.getItem(APP_CONSTANTS.STORAGE_KEYS.SETTINGS) || '{}');
            settings.dailyGoal = Number(dailyGoal) || 0;
            localStorage.setItem(APP_CONSTANTS.STORAGE_KEYS.SETTINGS, JSON.stringify(settings));
            setGoalSaved(true);
            setTimeout(() => setGoalSaved(false), 2000);
          },
        }, goalSaved ? '保存済み' : '保存')
      )
    ),

    // GPS設定
    React.createElement(Card, { title: 'GPS設定', style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '8px 0' } },
        React.createElement('div', null,
          React.createElement('div', { style: { fontWeight: 500, fontSize: 'var(--font-size-sm)' } }, '高精度モード'),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } }, 'GPSの精度を最大にする（バッテリー消費が増えます）')
        ),
        React.createElement('span', { className: 'badge badge--success' }, '有効')
      ),
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '8px 0' } },
        React.createElement('div', null,
          React.createElement('div', { style: { fontWeight: 500, fontSize: 'var(--font-size-sm)' } }, 'バックグラウンド追跡'),
          React.createElement('div', { style: { fontSize: 'var(--font-size-xs)', color: 'var(--text-secondary)' } }, 'アプリがバックグラウンドでも位置を追跡')
        ),
        React.createElement('span', { className: 'badge badge--warning' }, 'PWA必要')
      )
    ),

    // アプリをインストール（PWA）
    React.createElement(Card, { title: 'アプリをインストール', style: { marginBottom: 'var(--space-lg)' } },
      React.createElement('div', { style: { display: 'flex', alignItems: 'flex-start', gap: '12px' } },
        React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '36px', color: 'var(--color-primary-light)' },
        }, 'install_mobile'),
        React.createElement('div', { style: { flex: 1 } },
          React.createElement('div', { style: { fontWeight: 600, marginBottom: '4px' } }, 'ホーム画面に追加'),
          React.createElement('div', {
            style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', lineHeight: 1.6, marginBottom: '12px' },
          }, 'このアプリをスマートフォンのホーム画面に追加すると、ネイティブアプリのように使えます。オフラインでも基本機能が利用可能です。')
        )
      ),
      React.createElement(Button, {
        variant: 'primary',
        icon: 'download',
        onClick: async () => {
          const result = await window.triggerPwaInstall();
          if (!result.success && result.reason === 'prompt_not_available') {
            alert('手動インストール方法:\n\n【Android Chrome】\nメニュー（⋮）→「ホーム画面に追加」\n\n【iPhone Safari】\n共有ボタン（□↑）→「ホーム画面に追加」');
          }
        },
      }, 'インストール'),
      React.createElement('details', {
        style: { marginTop: 'var(--space-md)', cursor: 'pointer' },
      },
        React.createElement('summary', {
          style: { color: 'var(--color-primary-light)', fontSize: 'var(--font-size-sm)' },
        }, '手動インストール方法'),
        React.createElement('div', {
          style: { padding: 'var(--space-md)', color: 'var(--text-secondary)', fontSize: 'var(--font-size-sm)', lineHeight: 1.8 },
        },
          React.createElement('div', { style: { fontWeight: 600, marginBottom: '4px' } }, 'Android（Chrome）:'),
          React.createElement('p', null, '1. Chrome でこのページを開く'),
          React.createElement('p', null, '2. 右上の メニュー（⋮）をタップ'),
          React.createElement('p', null, '3.「ホーム画面に追加」または「アプリをインストール」をタップ'),
          React.createElement('div', { style: { fontWeight: 600, marginTop: '12px', marginBottom: '4px' } }, 'iPhone（Safari）:'),
          React.createElement('p', null, '1. Safari でこのページを開く'),
          React.createElement('p', null, '2. 下部の 共有ボタン（□↑）をタップ'),
          React.createElement('p', null, '3.「ホーム画面に追加」をタップ')
        )
      )
    ),

    // アプリ情報
    React.createElement(Card, { title: 'アプリ情報' },
      React.createElement('div', { style: { display: 'grid', gap: '8px', fontSize: 'var(--font-size-sm)' } },
        React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between' } },
          React.createElement('span', { style: { color: 'var(--text-secondary)' } }, 'バージョン'),
          React.createElement('span', null, APP_CONSTANTS.VERSION)
        ),
        React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between' } },
          React.createElement('span', { style: { color: 'var(--text-secondary)' } }, 'ビルド'),
          React.createElement('span', null, 'CDN (開発版)')
        ),
        React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between' } },
          React.createElement('span', { style: { color: 'var(--text-secondary)' } }, 'React'),
          React.createElement('span', null, React.version)
        )
      )
    )
  );
};

})();


// ============================================================
// FILE: src/pages/DataManage.jsx
// ============================================================
(function() {
// DataManage.jsx - データ管理ページ（売上・他社・交通情報の編集・削除）
window.DataManagePage = () => {
  const { useState, useEffect, useCallback, useMemo } = React;
  const [tab, setTab] = useState('revenue');
  const [refreshKey, setRefreshKey] = useState(0);
  const [editingId, setEditingId] = useState(null);
  const [editForm, setEditForm] = useState({});
  const [errors, setErrors] = useState([]);
  const [saved, setSaved] = useState(false);
  const [confirmDelete, setConfirmDelete] = useState(null);
  const [search, setSearch] = useState('');
  const [showAddForm, setShowAddForm] = useState(false);
  const todayDefault = getLocalDateString();
  const [addForm, setAddForm] = useState({ date: todayDefault, weather: '', amount: '', pickup: '', pickupTime: '', dropoff: '', dropoffTime: '', passengers: '1', gender: '', purpose: '', memo: '', source: '' });
  const [addErrors, setAddErrors] = useState([]);
  const [mapPickerField, setMapPickerField] = useState(null); // 'pickup' | 'dropoff' | null
  const [addCoords, setAddCoords] = useState({ pickupCoords: null, dropoffCoords: null });
  const mapPickerRef = React.useRef(null);
  const mapPickerInstanceRef = React.useRef(null);
  const mapPickerMarkerRef = React.useRef(null);
  const [editMapPickerField, setEditMapPickerField] = useState(null); // 'pickup' | 'dropoff' | null
  const editMapPickerRef = React.useRef(null);
  const editMapPickerInstanceRef = React.useRef(null);
  const editMapPickerMarkerRef = React.useRef(null);
  const { apiKey } = useAppContext();

  const tabs = [
    { id: 'revenue', label: '売上記録', icon: 'receipt_long' },
    { id: 'rival', label: '他社記録', icon: 'local_taxi' },
    { id: 'transit', label: '交通情報', icon: 'directions_transit' },
  ];

  // データ読み込み
  const revenueEntries = useMemo(() => DataService.getEntries(), [refreshKey]);
  const rivalEntries = useMemo(() => DataService.getRivalEntries(), [refreshKey]);
  const transitData = useMemo(() => {
    try {
      const saved = AppStorage.get(APP_CONSTANTS.STORAGE_KEYS.TRANSIT_INFO, {});
      return saved;
    } catch { return {}; }
  }, [refreshKey]);

  // storage変更を監視
  useEffect(() => {
    const handleStorage = (e) => {
      if ([APP_CONSTANTS.STORAGE_KEYS.REVENUE_DATA, APP_CONSTANTS.STORAGE_KEYS.RIVAL_RIDES, APP_CONSTANTS.STORAGE_KEYS.TRANSIT_INFO].includes(e.key)) {
        setRefreshKey(k => k + 1);
      }
    };
    window.addEventListener('storage', handleStorage);
    const handleVisibility = () => {
      if (!document.hidden) setRefreshKey(k => k + 1);
    };
    document.addEventListener('visibilitychange', handleVisibility);
    const handleDataChanged = () => setRefreshKey(k => k + 1);
    window.addEventListener('taxi-data-changed', handleDataChanged);
    return () => {
      window.removeEventListener('storage', handleStorage);
      document.removeEventListener('visibilitychange', handleVisibility);
      window.removeEventListener('taxi-data-changed', handleDataChanged);
    };
  }, []);

  // 編集開始
  const startEdit = useCallback((entry, type) => {
    setEditingId(entry.id);
    setEditForm(type === 'revenue'
      ? { amount: String(entry.amount), date: entry.date || '', weather: entry.weather || '', pickup: entry.pickup || '', pickupTime: entry.pickupTime || '', dropoff: entry.dropoff || '', dropoffTime: entry.dropoffTime || '', passengers: entry.passengers || '', gender: entry.gender || '', purpose: entry.purpose || '', memo: entry.memo || '', source: entry.source || '' }
      : { date: entry.date || '', time: entry.time || '', weather: entry.weather || '', location: entry.location || '', memo: entry.memo || '' }
    );
    setErrors([]);
  }, []);

  // 編集保存
  const saveEdit = useCallback(() => {
    setErrors([]);
    let result;
    if (tab === 'revenue') {
      result = DataService.updateEntry(editingId, editForm);
    } else if (tab === 'rival') {
      result = DataService.updateRivalEntry(editingId, editForm);
    } else {
      setErrors(['このタブでは編集できません']);
      return;
    }
    if (!result || !result.success) { setErrors((result && result.errors) || ['保存に失敗しました']); return; }
    setEditingId(null);
    setEditForm({});
    setEditMapPickerField(null);
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
    setRefreshKey(k => k + 1);
  }, [tab, editingId, editForm]);

  // 削除確認→実行
  const handleDelete = useCallback((id) => {
    if (confirmDelete === id) {
      if (tab === 'revenue') DataService.deleteEntry(id);
      else if (tab === 'rival') DataService.deleteRivalEntry(id);
      setConfirmDelete(null);
      setRefreshKey(k => k + 1);
    } else {
      setConfirmDelete(id);
      setTimeout(() => setConfirmDelete(null), 3000);
    }
  }, [tab, confirmDelete]);

  // 交通情報の個別カテゴリ削除
  const deleteTransitCategory = useCallback((key) => {
    const current = AppStorage.get(APP_CONSTANTS.STORAGE_KEYS.TRANSIT_INFO, {});
    delete current[key];
    AppStorage.set(APP_CONSTANTS.STORAGE_KEYS.TRANSIT_INFO, current);
    setRefreshKey(k => k + 1);
  }, []);

  // マップピッカーの初期化・クリックハンドラ
  useEffect(() => {
    if (!mapPickerField || !mapPickerRef.current || !window.google || !window.google.maps) return;
    setTimeout(() => { mapPickerRef.current && mapPickerRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' }); }, 100);
    const center = APP_CONSTANTS.DEFAULT_MAP_CENTER;
    const map = new google.maps.Map(mapPickerRef.current, {
      center, zoom: 13, mapTypeId: 'roadmap', disableDefaultUI: true,
      zoomControl: true, fullscreenControl: false, mapTypeControl: false,
    });
    mapPickerInstanceRef.current = map;
    const marker = new google.maps.Marker({ map, position: center, visible: false });
    mapPickerMarkerRef.current = marker;

    // GPS現在地を取得してマップの中心に設定
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const currentPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
          map.setCenter(currentPos);
          map.setZoom(13);
          new google.maps.Marker({ map, position: currentPos, icon: { path: google.maps.SymbolPath.CIRCLE, scale: 8, fillColor: '#4285F4', fillOpacity: 1, strokeColor: '#fff', strokeWeight: 2 }, title: '現在地', clickable: false });
        },
        () => {},
        { enableHighAccuracy: true, timeout: 5000, maximumAge: 10000 }
      );
    }

    const _extractAddress = TaxiApp.utils.extractAddress;

    map.addListener('click', (e) => {
      const lat = e.latLng.lat();
      const lng = e.latLng.lng();
      marker.setPosition(e.latLng);
      marker.setVisible(true);

      // 逆ジオコーディング
      const geocoder = new google.maps.Geocoder();
      geocoder.geocode({ location: { lat, lng } }, (results, status) => {
        if (status === 'OK' && results && results.length > 0) {
          // 最も詳細な結果を選択（street_address > route > sublocality > locality）
          const preferred = results.find(r => r.types.includes('street_address'))
            || results.find(r => r.types.includes('premise'))
            || results.find(r => r.types.includes('sublocality_level_3') || r.types.includes('sublocality_level_2'))
            || results.find(r => r.types.includes('route'))
            || results[0];
          const addr = _extractAddress(preferred);
          const coordsKey = mapPickerField === 'pickup' ? 'pickupCoords' : 'dropoffCoords';
          setAddForm(f => ({ ...f, [mapPickerField]: addr }));
          setAddCoords(c => ({ ...c, [coordsKey]: { lat, lng } }));
        } else {
          // Nominatimフォールバック
          fetch(TaxiApp.utils.nominatimUrl(lat, lng, 18))
            .then(r => r.json()).then(data => {
              const a = data.address || {};
              const parts = [a.city || a.town || a.village || '', a.suburb || a.neighbourhood || a.quarter || '', a.road || '', a.house_number || ''].filter(Boolean);
              const addr = parts.join(' ') || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
              const coordsKey = mapPickerField === 'pickup' ? 'pickupCoords' : 'dropoffCoords';
              setAddForm(f => ({ ...f, [mapPickerField]: addr }));
              setAddCoords(c => ({ ...c, [coordsKey]: { lat, lng } }));
            }).catch(() => {
              const coordsKey = mapPickerField === 'pickup' ? 'pickupCoords' : 'dropoffCoords';
              setAddForm(f => ({ ...f, [mapPickerField]: `${lat.toFixed(6)}, ${lng.toFixed(6)}` }));
              setAddCoords(c => ({ ...c, [coordsKey]: { lat, lng } }));
            });
        }
      });
    });

    return () => { mapPickerInstanceRef.current = null; mapPickerMarkerRef.current = null; };
  }, [mapPickerField]);

  // 編集用マップピッカーの初期化・クリックハンドラ
  useEffect(() => {
    if (!editMapPickerField || !editMapPickerRef.current || !window.google || !window.google.maps) return;
    setTimeout(() => { editMapPickerRef.current && editMapPickerRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' }); }, 100);
    const center = APP_CONSTANTS.DEFAULT_MAP_CENTER;
    const map = new google.maps.Map(editMapPickerRef.current, {
      center, zoom: 13, mapTypeId: 'roadmap', disableDefaultUI: true,
      zoomControl: true, fullscreenControl: false, mapTypeControl: false,
    });
    editMapPickerInstanceRef.current = map;
    const marker = new google.maps.Marker({ map, position: center, visible: false });
    editMapPickerMarkerRef.current = marker;

    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const currentPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
          map.setCenter(currentPos);
          map.setZoom(13);
          new google.maps.Marker({ map, position: currentPos, icon: { path: google.maps.SymbolPath.CIRCLE, scale: 8, fillColor: '#4285F4', fillOpacity: 1, strokeColor: '#fff', strokeWeight: 2 }, title: '現在地', clickable: false });
        },
        () => {},
        { enableHighAccuracy: true, timeout: 5000, maximumAge: 10000 }
      );
    }

    const _extractAddress = TaxiApp.utils.extractAddress;

    map.addListener('click', (e) => {
      const lat = e.latLng.lat();
      const lng = e.latLng.lng();
      marker.setPosition(e.latLng);
      marker.setVisible(true);

      const geocoder = new google.maps.Geocoder();
      geocoder.geocode({ location: { lat, lng } }, (results, status) => {
        if (status === 'OK' && results && results.length > 0) {
          const preferred = results.find(r => r.types.includes('street_address'))
            || results.find(r => r.types.includes('premise'))
            || results.find(r => r.types.includes('sublocality_level_3') || r.types.includes('sublocality_level_2'))
            || results.find(r => r.types.includes('route'))
            || results[0];
          const addr = _extractAddress(preferred);
          const targetField = editMapPickerField === 'dropoff' ? 'dropoff' : 'pickup';
          setEditForm(f => ({ ...f, [targetField]: addr }));
        } else {
          fetch(TaxiApp.utils.nominatimUrl(lat, lng, 18))
            .then(r => r.json()).then(data => {
              const a = data.address || {};
              const parts = [a.city || a.town || a.village || '', a.suburb || a.neighbourhood || a.quarter || '', a.road || '', a.house_number || ''].filter(Boolean);
              const addr = parts.join(' ') || `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
              const targetField = editMapPickerField === 'dropoff' ? 'dropoff' : 'pickup';
              setEditForm(f => ({ ...f, [targetField]: addr }));
            }).catch(() => {
              const targetField = editMapPickerField === 'dropoff' ? 'dropoff' : 'pickup';
              setEditForm(f => ({ ...f, [targetField]: `${lat.toFixed(6)}, ${lng.toFixed(6)}` }));
            });
        }
      });
    });

    return () => { editMapPickerInstanceRef.current = null; editMapPickerMarkerRef.current = null; };
  }, [editMapPickerField]);

  // 手動追加
  const handleManualAdd = useCallback(() => {
    setAddErrors([]);
    const formWithCoords = { ...addForm, pickupCoords: addCoords.pickupCoords, dropoffCoords: addCoords.dropoffCoords };
    const result = DataService.addEntry(formWithCoords);
    if (!result.success) { setAddErrors(result.errors); return; }
    setAddForm({ date: getLocalDateString(), weather: addForm.weather, amount: '', pickup: '', pickupTime: '', dropoff: '', dropoffTime: '', passengers: '1', gender: '', purpose: '', memo: '', source: '' });
    setAddCoords({ pickupCoords: null, dropoffCoords: null });
    setMapPickerField(null);
    setShowAddForm(false);
    setSaved(true);
    setTimeout(() => setSaved(false), 2000);
    setRefreshKey(k => k + 1);
  }, [addForm, addCoords, todayDefault]);

  // 検索フィルター
  const filteredRevenue = useMemo(() => {
    if (!search) return revenueEntries;
    const q = search.toLowerCase();
    return revenueEntries.filter(e =>
      (e.pickup || '').toLowerCase().includes(q) || (e.dropoff || '').toLowerCase().includes(q) ||
      (e.date || '').includes(q) || (e.memo || '').toLowerCase().includes(q) ||
      String(e.amount).includes(q)
    );
  }, [revenueEntries, search]);

  const filteredRival = useMemo(() => {
    if (!search) return rivalEntries;
    const q = search.toLowerCase();
    return rivalEntries.filter(e =>
      (e.location || '').toLowerCase().includes(q) || (e.date || '').includes(q) ||
      (e.memo || '').toLowerCase().includes(q)
    );
  }, [rivalEntries, search]);

  // 天候選択肢
  const weatherOptions = ['', '晴れ', '曇り', '雨', '雪'];

  // 共通入力フィールド生成
  const field = (label, key, type, opts) => {
    const val = editForm[key] || '';
    return React.createElement('div', { key, style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '6px' } },
      React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', minWidth: '56px', textAlign: 'right' } }, label),
      type === 'select'
        ? React.createElement('select', {
            value: val,
            onChange: e => setEditForm(f => ({ ...f, [key]: e.target.value })),
            style: { flex: 1, padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px' },
          }, (opts || []).map(o => React.createElement('option', { key: o, value: o }, o || '未設定')))
        : React.createElement('input', {
            type: type || 'text',
            value: val,
            onChange: e => setEditForm(f => ({ ...f, [key]: e.target.value })),
            style: { flex: 1, padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px' },
          })
    );
  };

  // 編集フォーム
  const editPanel = (type) => {
    if (!editingId) return null;
    return React.createElement('div', {
      style: { background: 'rgba(26,115,232,0.08)', border: '1px solid rgba(26,115,232,0.3)', borderRadius: '10px', padding: '14px', marginBottom: '12px' },
    },
      React.createElement('div', { style: { fontWeight: 600, fontSize: '13px', marginBottom: '10px', display: 'flex', alignItems: 'center', gap: '6px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: 'var(--color-primary-light)' } }, 'edit'),
        'データ編集'
      ),
      type === 'revenue' ? React.createElement(React.Fragment, null,
        field('金額', 'amount', 'number'),
        field('日付', 'date', 'date'),
        field('天候', 'weather', 'select', weatherOptions),
        React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '6px' } },
          React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', minWidth: '56px', textAlign: 'right' } }, '乗車地'),
          React.createElement('div', { style: { flex: 1 } },
            React.createElement('div', { style: { display: 'flex', gap: '4px' } },
              React.createElement('input', { type: 'text', value: editForm.pickup || '', onChange: e => setEditForm(f => ({ ...f, pickup: e.target.value })), style: { flex: 1, padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px' } }),
              React.createElement('button', {
                onClick: () => setEditMapPickerField(editMapPickerField === 'pickup' ? null : 'pickup'),
                style: { padding: '6px 10px', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '12px', fontWeight: 600, display: 'flex', alignItems: 'center', gap: '3px', background: editMapPickerField === 'pickup' ? 'var(--color-primary)' : 'var(--bg-tertiary)', color: editMapPickerField === 'pickup' ? '#fff' : 'var(--text-secondary)', whiteSpace: 'nowrap' },
              }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'map'), '地図')
            ),
            editMapPickerField === 'pickup' && React.createElement('div', { style: { marginTop: '6px' } },
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '4px', fontSize: '11px', color: 'var(--color-primary-light)' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'touch_app'),
                '地図をタップして乗車地を選択'
              ),
              (window.google && window.google.maps)
                ? React.createElement('div', { ref: editMapPickerRef, style: { width: '100%', height: '660px', borderRadius: '8px', border: '2px solid var(--color-primary)', overflow: 'hidden' } })
                : React.createElement('div', { style: { padding: '20px', textAlign: 'center', color: 'var(--text-muted)', fontSize: '12px', background: 'var(--bg-tertiary)', borderRadius: '8px' } }, 'Google Maps APIキーを設定してください')
            )
          )
        ),
        field('乗車時刻', 'pickupTime', 'time'),
        React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '6px' } },
          React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', minWidth: '56px', textAlign: 'right' } }, '降車地'),
          React.createElement('div', { style: { flex: 1 } },
            React.createElement('div', { style: { display: 'flex', gap: '4px' } },
              React.createElement('input', { type: 'text', value: editForm.dropoff || '', onChange: e => setEditForm(f => ({ ...f, dropoff: e.target.value })), style: { flex: 1, padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px' } }),
              React.createElement('button', {
                onClick: () => setEditMapPickerField(editMapPickerField === 'dropoff' ? null : 'dropoff'),
                style: { padding: '6px 10px', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '12px', fontWeight: 600, display: 'flex', alignItems: 'center', gap: '3px', background: editMapPickerField === 'dropoff' ? 'var(--color-secondary)' : 'var(--bg-tertiary)', color: editMapPickerField === 'dropoff' ? '#fff' : 'var(--text-secondary)', whiteSpace: 'nowrap' },
              }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'map'), '地図')
            ),
            editMapPickerField === 'dropoff' && React.createElement('div', { style: { marginTop: '6px' } },
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '4px', fontSize: '11px', color: 'var(--color-secondary)' } },
                React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'touch_app'),
                '地図をタップして降車地を選択'
              ),
              (window.google && window.google.maps)
                ? React.createElement('div', { ref: editMapPickerRef, style: { width: '100%', height: '660px', borderRadius: '8px', border: '2px solid var(--color-secondary)', overflow: 'hidden' } })
                : React.createElement('div', { style: { padding: '20px', textAlign: 'center', color: 'var(--text-muted)', fontSize: '12px', background: 'var(--bg-tertiary)', borderRadius: '8px' } }, 'Google Maps APIキーを設定してください')
            )
          )
        ),
        field('降車時刻', 'dropoffTime', 'time'),
        field('人数', 'passengers', 'number'),
        field('性別', 'gender', 'select', ['', '男性', '女性', 'その他']),
        field('用途', 'purpose', 'select', ['', '通勤', '通院', '買物', '観光', '出張', '送迎', '空港', '飲食', 'パチンコ']),
        field('配車方法', 'source', 'select', ['', 'Go', 'Uber', 'DIDI', '電話', '流し']),
        field('メモ', 'memo', 'text')
      ) : React.createElement(React.Fragment, null,
        field('日付', 'date', 'date'),
        field('時刻', 'time', 'time'),
        field('天候', 'weather', 'select', weatherOptions),
        field('場所', 'location', 'text'),
        field('メモ', 'memo', 'text')
      ),
      errors.length > 0 && React.createElement('div', { style: { color: 'var(--color-danger)', fontSize: '12px', marginTop: '6px' } },
        errors.join(', ')
      ),
      React.createElement('div', { style: { display: 'flex', gap: '8px', marginTop: '10px', justifyContent: 'flex-end' } },
        React.createElement(Button, { variant: 'ghost', onClick: () => { setEditingId(null); setErrors([]); setEditMapPickerField(null); } }, 'キャンセル'),
        React.createElement(Button, { icon: 'save', onClick: saveEdit }, '保存')
      )
    );
  };

  // 売上エントリ行
  const revenueRow = (entry) => {
    const isEditing = editingId === entry.id;
    const isConfirm = confirmDelete === entry.id;
    const eDate = entry.date || getLocalDateString(new Date(entry.timestamp));
    const info = entry.dayOfWeek ? { dayOfWeek: entry.dayOfWeek, holiday: entry.holiday, isSunday: entry.dayOfWeek === '日', isSaturday: entry.dayOfWeek === '土', isHoliday: !!entry.holiday } : JapaneseHolidays.getDateInfo(eDate);
    const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-muted)';

    return React.createElement('div', { key: entry.id },
      isEditing && editPanel('revenue'),
      React.createElement('div', {
        style: { display: 'flex', alignItems: 'center', padding: '10px 0', borderBottom: '1px solid rgba(255,255,255,0.06)', opacity: isEditing ? 0.5 : 1 },
      },
        React.createElement('div', { style: { flex: 1, minWidth: 0 } },
          React.createElement('div', { style: { fontWeight: 500, display: 'flex', alignItems: 'center', gap: '4px', flexWrap: 'wrap', fontSize: '13px' } },
            entry.pickupTime && React.createElement('span', { style: { fontSize: '10px', color: 'var(--color-primary-light)', fontWeight: 600, padding: '1px 5px', borderRadius: '3px', background: 'rgba(26,115,232,0.12)' } }, entry.pickupTime),
            React.createElement('span', null, entry.pickup || '---'),
            React.createElement('span', { style: { color: 'var(--text-muted)', margin: '0 2px' } }, '→'),
            entry.dropoffTime && React.createElement('span', { style: { fontSize: '10px', color: 'var(--color-accent)', fontWeight: 600, padding: '1px 5px', borderRadius: '3px', background: 'rgba(0,200,83,0.12)' } }, entry.dropoffTime),
            React.createElement('span', null, entry.dropoff || '---')
          ),
          React.createElement('div', { style: { fontSize: '11px', color: 'var(--text-muted)', display: 'flex', flexWrap: 'wrap', gap: '4px', marginTop: '2px' } },
            React.createElement('span', null, eDate),
            React.createElement('span', { style: { color: dayColor, fontWeight: 600 } }, `(${info.dayOfWeek})`),
            info.holiday && React.createElement('span', { style: { color: '#ef4444', fontSize: '10px', padding: '1px 5px', borderRadius: '3px', background: 'rgba(239,68,68,0.1)' } }, info.holiday),
            entry.weather && React.createElement('span', null, entry.weather),
            entry.passengers && React.createElement('span', { style: { fontSize: '10px', padding: '1px 4px', borderRadius: '3px', background: 'rgba(255,255,255,0.08)' } }, `${entry.passengers}名`),
            entry.source && React.createElement('span', { style: { fontSize: '10px', padding: '1px 4px', borderRadius: '3px', background: 'rgba(255,152,0,0.15)', color: '#ffb74d', fontWeight: 600 } }, entry.source),
            entry.memo && React.createElement('span', { style: { color: 'var(--text-muted)' } }, `| ${entry.memo}`)
          )
        ),
        React.createElement('div', { style: { marginRight: '8px', whiteSpace: 'nowrap', textAlign: 'right' } },
          entry.noPassenger
            ? React.createElement('div', { style: { fontWeight: 700, color: '#d32f2f', fontSize: '15px' } }, '¥0（待機）')
            : React.createElement('div', { style: { fontWeight: 700, color: 'var(--color-secondary)', fontSize: '15px' } }, `¥${entry.amount.toLocaleString()}`),
          !entry.noPassenger && React.createElement('div', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, `税抜¥${Math.floor(entry.amount / 1.1).toLocaleString()} 税¥${(entry.amount - Math.floor(entry.amount / 1.1)).toLocaleString()}`)
        ),
        React.createElement('button', {
          onClick: () => startEdit(entry, 'revenue'),
          style: { background: 'none', border: 'none', cursor: 'pointer', color: 'var(--color-primary-light)', padding: '4px' },
          title: '編集',
        }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, 'edit')),
        React.createElement('button', {
          onClick: () => handleDelete(entry.id),
          style: { background: 'none', border: 'none', cursor: 'pointer', color: isConfirm ? 'var(--color-danger)' : 'var(--text-muted)', padding: '4px' },
          title: isConfirm ? 'もう一度押して削除' : '削除',
        }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, isConfirm ? 'delete_forever' : 'delete_outline'))
      )
    );
  };

  // 他社エントリ行
  const rivalRow = (entry) => {
    const isEditing = editingId === entry.id;
    const isConfirm = confirmDelete === entry.id;
    const info = entry.dayOfWeek ? { dayOfWeek: entry.dayOfWeek, holiday: entry.holiday, isSunday: entry.dayOfWeek === '日', isSaturday: entry.dayOfWeek === '土', isHoliday: !!entry.holiday } : JapaneseHolidays.getDateInfo(entry.date);
    const dayColor = info.isSunday || info.isHoliday ? '#ef4444' : info.isSaturday ? '#3b82f6' : 'var(--text-muted)';

    return React.createElement('div', { key: entry.id },
      isEditing && editPanel('rival'),
      React.createElement('div', {
        style: { display: 'flex', alignItems: 'center', padding: '10px 0', borderBottom: '1px solid rgba(255,255,255,0.06)', opacity: isEditing ? 0.5 : 1 },
      },
        React.createElement('div', { style: { flex: 1, minWidth: 0 } },
          React.createElement('div', { style: { fontWeight: 500, display: 'flex', alignItems: 'center', gap: '6px', fontSize: '13px' } },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: 'var(--color-primary-light)' } }, 'local_taxi'),
            React.createElement('span', null, entry.location || '---')
          ),
          React.createElement('div', { style: { fontSize: '11px', color: 'var(--text-muted)', display: 'flex', flexWrap: 'wrap', gap: '4px', marginTop: '2px' } },
            React.createElement('span', null, entry.date),
            React.createElement('span', { style: { color: dayColor, fontWeight: 600 } }, `(${info.dayOfWeek})`),
            info.holiday && React.createElement('span', { style: { color: '#ef4444', fontSize: '10px', padding: '1px 5px', borderRadius: '3px', background: 'rgba(239,68,68,0.1)' } }, info.holiday),
            entry.time && React.createElement('span', { style: { fontSize: '11px', color: 'var(--color-primary-light)', fontWeight: 600, padding: '1px 5px', borderRadius: '3px', background: 'rgba(26,115,232,0.12)' } }, entry.time),
            entry.weather && React.createElement('span', null, entry.weather),
            entry.memo && React.createElement('span', { style: { color: 'var(--text-muted)' } }, `| ${entry.memo}`)
          )
        ),
        React.createElement('button', {
          onClick: () => startEdit(entry, 'rival'),
          style: { background: 'none', border: 'none', cursor: 'pointer', color: 'var(--color-primary-light)', padding: '4px' },
          title: '編集',
        }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, 'edit')),
        React.createElement('button', {
          onClick: () => handleDelete(entry.id),
          style: { background: 'none', border: 'none', cursor: 'pointer', color: isConfirm ? 'var(--color-danger)' : 'var(--text-muted)', padding: '4px' },
          title: isConfirm ? 'もう一度押して削除' : '削除',
        }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, isConfirm ? 'delete_forever' : 'delete_outline'))
      )
    );
  };

  // 交通情報カテゴリラベル
  const transitLabels = { trouble: '遅延・運休情報', train: '電車情報', bus: 'バス情報', flight: 'フライト情報' };
  const transitIcons = { trouble: 'warning', train: 'train', bus: 'directions_bus', flight: 'flight' };

  return React.createElement('div', null,
    // タブバー
    React.createElement('div', { style: { display: 'flex', gap: '4px', marginBottom: '16px', overflowX: 'auto', paddingBottom: '4px' } },
      tabs.map(t => React.createElement('button', {
        key: t.id,
        onClick: () => { setTab(t.id); setEditingId(null); setErrors([]); setSearch(''); },
        style: {
          display: 'flex', alignItems: 'center', gap: '4px', padding: '8px 14px',
          borderRadius: '8px', border: 'none', cursor: 'pointer', fontSize: '12px', fontWeight: 600,
          background: tab === t.id ? 'var(--color-primary)' : 'var(--bg-tertiary)',
          color: tab === t.id ? '#fff' : 'var(--text-secondary)',
          whiteSpace: 'nowrap', transition: 'all 0.2s',
        },
      },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, t.icon),
        t.label
      ))
    ),

    // 検索バー（売上・他社タブ）
    tab !== 'transit' && React.createElement('div', { style: { marginBottom: '12px' } },
      React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', background: 'var(--bg-tertiary)', borderRadius: '8px', padding: '8px 12px' } },
        React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: 'var(--text-muted)' } }, 'search'),
        React.createElement('input', {
          type: 'text', value: search, placeholder: '検索...',
          onChange: e => setSearch(e.target.value),
          style: { flex: 1, border: 'none', background: 'transparent', color: 'var(--text-primary)', fontSize: '13px', outline: 'none' },
        }),
        search && React.createElement('button', {
          onClick: () => setSearch(''),
          style: { background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-muted)', padding: '2px' },
        }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'close'))
      )
    ),

    // 保存成功バナー
    saved && React.createElement('div', {
      style: { background: 'rgba(0,200,83,0.15)', border: '1px solid rgba(0,200,83,0.3)', borderRadius: '8px', padding: '10px 14px', marginBottom: '12px', display: 'flex', alignItems: 'center', gap: '8px', fontSize: '13px', color: 'var(--color-accent)' },
    },
      React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, 'check_circle'),
      '保存しました'
    ),

    // === 売上記録タブ ===
    tab === 'revenue' && React.createElement(React.Fragment, null,
      // 手動追加ボタン / フォーム
      !showAddForm
        ? React.createElement('div', { style: { marginBottom: '12px', display: 'flex', gap: '8px' } },
            React.createElement(Button, {
              icon: 'add', onClick: () => setShowAddForm(true),
              style: { flex: 1, padding: '10px', fontSize: '13px', fontWeight: 600 },
            }, '手動で売上を追加'),
            React.createElement('button', {
              onClick: () => {
                setShowAddForm(true);
                // フォームを開いてから乗客なしモードであることを示す
                // ユーザーが乗車地・乗車時刻を入力後に降車地欄の「乗客なし」ボタンで保存
              },
              style: { display: 'flex', alignItems: 'center', gap: '6px', padding: '10px 16px', borderRadius: '8px', border: 'none', cursor: 'pointer', fontSize: '13px', fontWeight: 700, background: '#d32f2f', color: '#fff', whiteSpace: 'nowrap' },
            },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, 'person_off'),
              '乗客なし'
            )
          )
        : React.createElement('div', {
            style: { background: 'rgba(0,200,83,0.08)', border: '1px solid rgba(0,200,83,0.3)', borderRadius: '10px', padding: '14px', marginBottom: '12px' },
          },
            React.createElement('div', { style: { fontWeight: 600, fontSize: '13px', marginBottom: '10px', display: 'flex', alignItems: 'center', gap: '6px' } },
              React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px', color: 'var(--color-accent)' } }, 'add_circle'),
              '売上を手動入力'
            ),
            React.createElement('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '6px' } },
              React.createElement('div', { style: { gridColumn: '1 / -1' } },
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '金額 *'),
                React.createElement('input', { type: 'number', value: addForm.amount, placeholder: '例: 3500', onChange: e => setAddForm(f => ({ ...f, amount: e.target.value })), style: { width: '100%', padding: '8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '15px', fontWeight: 700, boxSizing: 'border-box' } })
              ),
              React.createElement('div', null,
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '日付'),
                React.createElement('input', { type: 'date', value: addForm.date, onChange: e => setAddForm(f => ({ ...f, date: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } })
              ),
              React.createElement('div', null,
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '天候'),
                React.createElement('select', { value: addForm.weather, onChange: e => setAddForm(f => ({ ...f, weather: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } },
                  ['', '晴れ', '曇り', '雨', '雪'].map(o => React.createElement('option', { key: o, value: o }, o || '未設定'))
                )
              ),
              React.createElement('div', { style: { gridColumn: '1 / -1' } },
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '乗車地'),
                React.createElement('div', { style: { display: 'flex', gap: '4px' } },
                  React.createElement('input', { type: 'text', value: addForm.pickup, placeholder: '地図をクリックまたは手入力', onChange: e => setAddForm(f => ({ ...f, pickup: e.target.value })), style: { flex: 1, padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } }),
                  React.createElement('button', {
                    onClick: () => setMapPickerField(mapPickerField === 'pickup' ? null : 'pickup'),
                    style: { padding: '6px 10px', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '12px', fontWeight: 600, display: 'flex', alignItems: 'center', gap: '3px', background: mapPickerField === 'pickup' ? 'var(--color-primary)' : 'var(--bg-tertiary)', color: mapPickerField === 'pickup' ? '#fff' : 'var(--text-secondary)', whiteSpace: 'nowrap' },
                  }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'map'), '地図')
                ),
                addCoords.pickupCoords && React.createElement('div', { style: { fontSize: '10px', color: 'var(--color-accent)', marginTop: '2px' } }, `${addCoords.pickupCoords.lat.toFixed(5)}, ${addCoords.pickupCoords.lng.toFixed(5)}`)
              ),
              // 乗車地マップピッカー
              mapPickerField === 'pickup' && React.createElement('div', { style: { gridColumn: '1 / -1' } },
                React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '4px', fontSize: '11px', color: 'var(--color-primary-light)' } },
                  React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'touch_app'),
                  '地図をタップして乗車地を選択'
                ),
                (window.google && window.google.maps)
                  ? React.createElement('div', { ref: mapPickerRef, style: { width: '100%', height: '660px', borderRadius: '8px', border: '2px solid var(--color-primary)', overflow: 'hidden' } })
                  : React.createElement('div', { style: { padding: '20px', textAlign: 'center', color: 'var(--text-muted)', fontSize: '12px', background: 'var(--bg-tertiary)', borderRadius: '8px' } }, 'Google Maps APIキーを設定してください')
              ),
              React.createElement('div', null,
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '乗車時刻'),
                React.createElement('input', { type: 'time', value: addForm.pickupTime, onChange: e => setAddForm(f => ({ ...f, pickupTime: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } })
              ),
              React.createElement('div', { style: { gridColumn: '1 / -1' } },
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '降車地'),
                React.createElement('div', { style: { display: 'flex', gap: '4px' } },
                  React.createElement('input', { type: 'text', value: addForm.dropoff, placeholder: '地図をクリックまたは手入力', onChange: e => setAddForm(f => ({ ...f, dropoff: e.target.value })), style: { flex: 1, padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } }),
                  React.createElement('button', {
                    onClick: () => setMapPickerField(mapPickerField === 'dropoff' ? null : 'dropoff'),
                    style: { padding: '6px 10px', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '12px', fontWeight: 600, display: 'flex', alignItems: 'center', gap: '3px', background: mapPickerField === 'dropoff' ? 'var(--color-secondary)' : 'var(--bg-tertiary)', color: mapPickerField === 'dropoff' ? '#fff' : 'var(--text-secondary)', whiteSpace: 'nowrap' },
                  }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'map'), '地図'),
                  React.createElement('button', {
                    onClick: () => {
                      const now = new Date();
                      const hh = String(now.getHours()).padStart(2, '0');
                      const mm = String(now.getMinutes()).padStart(2, '0');
                      const dropoffTime = `${hh}:${mm}`;
                      const formData = {
                        ...addForm,
                        dropoffTime,
                        amount: '0',
                        passengers: '0',
                        noPassenger: true,
                        pickupCoords: addCoords.pickupCoords,
                        dropoffCoords: addCoords.dropoffCoords,
                      };
                      const result = DataService.addEntry(formData);
                      if (result.success) {
                        setAddForm({ date: getLocalDateString(), weather: addForm.weather, amount: '', pickup: '', pickupTime: '', dropoff: '', dropoffTime: '', passengers: '1', gender: '', purpose: '', memo: '', source: '' });
                        setAddCoords({ pickupCoords: null, dropoffCoords: null });
                        setMapPickerField(null);
                        setShowAddForm(false);
                        setSaved(true);
                        setTimeout(() => setSaved(false), 2000);
                        setRefreshKey(k => k + 1);
                      } else {
                        setAddErrors(result.errors);
                      }
                    },
                    style: { padding: '6px 10px', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '12px', fontWeight: 600, display: 'flex', alignItems: 'center', gap: '3px', background: '#d32f2f', color: '#fff', whiteSpace: 'nowrap' },
                  }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '16px' } }, 'person_off'), '乗客なし')
                ),
                addCoords.dropoffCoords && React.createElement('div', { style: { fontSize: '10px', color: 'var(--color-accent)', marginTop: '2px' } }, `${addCoords.dropoffCoords.lat.toFixed(5)}, ${addCoords.dropoffCoords.lng.toFixed(5)}`)
              ),
              // 降車地マップピッカー
              mapPickerField === 'dropoff' && React.createElement('div', { style: { gridColumn: '1 / -1' } },
                React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', marginBottom: '4px', fontSize: '11px', color: 'var(--color-secondary)' } },
                  React.createElement('span', { className: 'material-icons-round', style: { fontSize: '14px' } }, 'touch_app'),
                  '地図をタップして降車地を選択'
                ),
                (window.google && window.google.maps)
                  ? React.createElement('div', { ref: mapPickerRef, style: { width: '100%', height: '660px', borderRadius: '8px', border: '2px solid var(--color-secondary)', overflow: 'hidden' } })
                  : React.createElement('div', { style: { padding: '20px', textAlign: 'center', color: 'var(--text-muted)', fontSize: '12px', background: 'var(--bg-tertiary)', borderRadius: '8px' } }, 'Google Maps APIキーを設定してください')
              ),
              React.createElement('div', null,
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '降車時刻'),
                React.createElement('input', { type: 'time', value: addForm.dropoffTime, onChange: e => setAddForm(f => ({ ...f, dropoffTime: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } })
              ),
              React.createElement('div', null,
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '人数'),
                React.createElement('input', { type: 'number', value: addForm.passengers, min: 1, max: 9, onChange: e => setAddForm(f => ({ ...f, passengers: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } })
              ),
              React.createElement('div', null,
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '性別'),
                React.createElement('select', { value: addForm.gender, onChange: e => setAddForm(f => ({ ...f, gender: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } },
                  ['', '男性', '女性', 'その他'].map(o => React.createElement('option', { key: o, value: o }, o || '未設定'))
                )
              ),
              React.createElement('div', null,
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, '配車方法'),
                React.createElement('select', { value: addForm.source, onChange: e => setAddForm(f => ({ ...f, source: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } },
                  ['', 'Go', 'Uber', 'DIDI', '電話', '流し'].map(o => React.createElement('option', { key: o, value: o }, o || '未設定'))
                )
              ),
              React.createElement('div', { style: { gridColumn: '1 / -1' } },
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '4px' } }, '用途'),
                React.createElement('div', { style: { display: 'flex', gap: '6px', flexWrap: 'wrap' } },
                  ...[
                    { value: '通勤', icon: '🏢' },
                    { value: '通院', icon: '🏥' },
                    { value: '買物', icon: '🛒' },
                    { value: '観光', icon: '📸' },
                    { value: '出張', icon: '💼' },
                    { value: '送迎', icon: '🚗' },
                    { value: '空港', icon: '✈️' },
                    { value: '飲食', icon: '🍺' },
                    { value: 'パチンコ', icon: '🎰' },
                  ].map(p =>
                    React.createElement('button', {
                      key: p.value,
                      type: 'button',
                      onClick: () => setAddForm(f => ({ ...f, purpose: f.purpose === p.value ? '' : p.value })),
                      style: {
                        display: 'flex', alignItems: 'center', gap: '4px',
                        padding: '6px 10px', borderRadius: '8px',
                        fontSize: '12px', fontWeight: addForm.purpose === p.value ? '700' : '400',
                        cursor: 'pointer',
                        border: addForm.purpose === p.value ? '2px solid var(--color-primary)' : '1px solid rgba(255,255,255,0.15)',
                        background: addForm.purpose === p.value ? 'rgba(26,115,232,0.25)' : 'rgba(255,255,255,0.05)',
                        color: addForm.purpose === p.value ? 'var(--color-primary-light)' : 'var(--text-secondary)',
                        transition: 'all 0.15s ease',
                      },
                    },
                      React.createElement('span', { style: { fontSize: '14px' } }, p.icon),
                      p.value
                    )
                  )
                )
              ),
              React.createElement('div', { style: { gridColumn: '1 / -1' } },
                React.createElement('label', { style: { fontSize: '11px', color: 'var(--text-secondary)', display: 'block', marginBottom: '2px' } }, 'メモ'),
                React.createElement('input', { type: 'text', value: addForm.memo, placeholder: '自由入力', onChange: e => setAddForm(f => ({ ...f, memo: e.target.value })), style: { width: '100%', padding: '6px 8px', borderRadius: '6px', border: '1px solid rgba(255,255,255,0.15)', background: 'var(--bg-secondary)', color: 'var(--text-primary)', fontSize: '13px', boxSizing: 'border-box' } })
              )
            ),
            addErrors.length > 0 && React.createElement('div', { style: { color: 'var(--color-danger)', fontSize: '12px', marginTop: '8px' } }, addErrors.join(', ')),
            React.createElement('div', { style: { display: 'flex', gap: '8px', marginTop: '12px', justifyContent: 'flex-end' } },
              React.createElement(Button, { variant: 'ghost', onClick: () => { setShowAddForm(false); setAddErrors([]); } }, 'キャンセル'),
              React.createElement(Button, { icon: 'save', onClick: handleManualAdd }, '記録を追加')
            )
          ),

      React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' } },
        React.createElement('div', { style: { fontSize: '13px', color: 'var(--text-secondary)' } },
          `${filteredRevenue.length}件${search ? ` (全${revenueEntries.length}件中)` : ''}`
        ),
        revenueEntries.length > 0 && React.createElement(Button, {
          variant: 'danger', icon: 'delete_forever',
          onClick: () => { if (confirm('全ての売上記録を削除しますか？この操作は取り消せません。')) { DataService.clearAllEntries(); setRefreshKey(k => k + 1); } },
          style: { padding: '5px 10px', fontSize: '11px' },
        }, '全削除')
      ),
      filteredRevenue.length === 0
        ? React.createElement('div', { style: { textAlign: 'center', padding: '40px 20px', color: 'var(--text-muted)' } },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '48px', opacity: 0.3, display: 'block', marginBottom: '8px' } }, 'receipt_long'),
            search ? '該当する記録がありません' : '売上記録がありません'
          )
        : React.createElement(Card, null, filteredRevenue.map(e => revenueRow(e)))
    ),

    // === 他社記録タブ ===
    tab === 'rival' && React.createElement(React.Fragment, null,
      React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' } },
        React.createElement('div', { style: { fontSize: '13px', color: 'var(--text-secondary)' } },
          `${filteredRival.length}件${search ? ` (全${rivalEntries.length}件中)` : ''}`
        ),
        rivalEntries.length > 0 && React.createElement(Button, {
          variant: 'danger', icon: 'delete_forever',
          onClick: () => { if (confirm('全ての他社乗車記録を削除しますか？この操作は取り消せません。')) { DataService.clearAllRivalEntries(); setRefreshKey(k => k + 1); } },
          style: { padding: '5px 10px', fontSize: '11px' },
        }, '全削除')
      ),
      filteredRival.length === 0
        ? React.createElement('div', { style: { textAlign: 'center', padding: '40px 20px', color: 'var(--text-muted)' } },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '48px', opacity: 0.3, display: 'block', marginBottom: '8px' } }, 'local_taxi'),
            search ? '該当する記録がありません' : '他社乗車記録がありません'
          )
        : React.createElement(Card, null, filteredRival.map(e => rivalRow(e)))
    ),

    // === 交通情報タブ ===
    tab === 'transit' && React.createElement(React.Fragment, null,
      React.createElement('div', { style: { fontSize: '13px', color: 'var(--text-secondary)', marginBottom: '12px' } },
        '保存済みの公共交通機関情報'
      ),
      Object.keys(transitData).length === 0
        ? React.createElement('div', { style: { textAlign: 'center', padding: '40px 20px', color: 'var(--text-muted)' } },
            React.createElement('span', { className: 'material-icons-round', style: { fontSize: '48px', opacity: 0.3, display: 'block', marginBottom: '8px' } }, 'directions_transit'),
            '保存された交通情報がありません'
          )
        : React.createElement(Card, null,
            Object.entries(transitData).sort((a, b) => (b[1].fetchedAt || '').localeCompare(a[1].fetchedAt || '')).map(([key, val]) =>
              React.createElement('div', {
                key,
                style: { padding: '12px 0', borderBottom: '1px solid rgba(255,255,255,0.06)' },
              },
                React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '6px' } },
                  React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '6px', fontWeight: 600, fontSize: '13px' } },
                    React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px', color: key === 'trouble' ? 'var(--color-warning)' : 'var(--color-primary-light)' } }, transitIcons[key] || 'info'),
                    transitLabels[key] || key
                  ),
                  React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px' } },
                    val.fetchedAt && React.createElement('span', { style: { fontSize: '10px', color: 'var(--text-muted)' } }, new Date(val.fetchedAt).toLocaleString('ja-JP')),
                    React.createElement('button', {
                      onClick: () => { if (confirm(`「${transitLabels[key] || key}」のデータを削除しますか？`)) deleteTransitCategory(key); },
                      style: { background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-muted)', padding: '4px' },
                      title: '削除',
                    }, React.createElement('span', { className: 'material-icons-round', style: { fontSize: '18px' } }, 'delete_outline'))
                  )
                ),
                val.text && React.createElement('div', {
                  style: { fontSize: '12px', color: 'var(--text-secondary)', lineHeight: 1.5, maxHeight: '120px', overflow: 'auto', padding: '8px', background: 'rgba(255,255,255,0.03)', borderRadius: '6px', whiteSpace: 'pre-wrap' },
                }, val.text.slice(0, 500) + (val.text.length > 500 ? '...' : ''))
              )
            )
          ),
      Object.keys(transitData).length > 0 && React.createElement('div', { style: { marginTop: '12px', display: 'flex', justifyContent: 'flex-end' } },
        React.createElement(Button, {
          variant: 'danger', icon: 'delete_forever',
          onClick: () => { if (confirm('全ての交通情報を削除しますか？')) { AppStorage.set(APP_CONSTANTS.STORAGE_KEYS.TRANSIT_INFO, {}); setRefreshKey(k => k + 1); } },
          style: { padding: '5px 10px', fontSize: '11px' },
        }, '全削除')
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/dev/Logs.jsx
// ============================================================
(function() {
// Logs.jsx - ログビューアページ
window.LogsPage = () => {
  const { useState, useMemo } = React;
  const { logs, clearLogs } = useLogContext();
  const [filter, setFilter] = useState('all');
  const [search, setSearch] = useState('');

  const filteredLogs = useMemo(() => {
    let result = [...logs].reverse();
    if (filter !== 'all') {
      result = result.filter(log => log.level === filter);
    }
    if (search) {
      const s = search.toLowerCase();
      result = result.filter(log => log.message.toLowerCase().includes(s));
    }
    return result;
  }, [logs, filter, search]);

  const counts = useMemo(() => ({
    all: logs.length,
    info: logs.filter(l => l.level === 'info').length,
    warn: logs.filter(l => l.level === 'warn').length,
    error: logs.filter(l => l.level === 'error').length,
    debug: logs.filter(l => l.level === 'debug').length,
  }), [logs]);

  const formatTime = (ts) => {
    const d = new Date(ts);
    return d.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  };

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'terminal'),
      'ログビューア'
    ),

    // フィルター
    React.createElement('div', {
      style: { display: 'flex', gap: '8px', marginBottom: 'var(--space-md)', flexWrap: 'wrap', alignItems: 'center' },
    },
      ['all', 'info', 'warn', 'error', 'debug'].map(level =>
        React.createElement('button', {
          key: level,
          className: `tab ${filter === level ? 'active' : ''}`,
          onClick: () => setFilter(level),
          style: { border: 'none', background: filter === level ? 'rgba(26,115,232,0.15)' : 'rgba(255,255,255,0.04)', borderRadius: '20px', padding: '4px 12px' },
        },
          `${level === 'all' ? '全て' : level.toUpperCase()} (${counts[level]})`
        )
      ),

      React.createElement('input', {
        className: 'form-input',
        type: 'text',
        placeholder: '検索...',
        value: search,
        onChange: (e) => setSearch(e.target.value),
        style: { maxWidth: '200px', padding: '4px 12px', marginLeft: 'auto' },
      }),

      React.createElement(Button, {
        variant: 'danger',
        icon: 'delete',
        onClick: clearLogs,
        style: { padding: '4px 12px', fontSize: '12px' },
      }, 'クリア')
    ),

    // ログ一覧
    React.createElement(Card, { style: { padding: 0, maxHeight: '600px', overflowY: 'auto' } },
      filteredLogs.length === 0
        ? React.createElement('div', {
            style: { padding: 'var(--space-2xl)', textAlign: 'center', color: 'var(--text-muted)' },
          }, 'ログはありません')
        : filteredLogs.map(log =>
            React.createElement('div', { key: log.id, className: 'dev-log-entry' },
              React.createElement('span', { className: 'dev-log-entry__time' }, formatTime(log.timestamp)),
              React.createElement('span', { className: `dev-log-entry__level dev-log-entry__level--${log.level}` },
                log.level.toUpperCase()
              ),
              React.createElement('span', { className: 'dev-log-entry__message' }, log.message)
            )
          )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/dev/Structure.jsx
// ============================================================
(function() {
// Structure.jsx - サイト構造ビューアページ
window.StructurePage = () => {
  const { useState } = React;

  const iconMap = {
    folder: { icon: 'folder', class: 'file-tree__icon--folder' },
    react: { icon: 'description', class: 'file-tree__icon--react' },
    js: { icon: 'javascript', class: 'file-tree__icon--js' },
    css: { icon: 'style', class: 'file-tree__icon--css' },
    html: { icon: 'html', class: 'file-tree__icon--html' },
    md: { icon: 'article', class: 'file-tree__icon--md' },
    file: { icon: 'insert_drive_file', class: 'file-tree__icon--file' },
  };

  const TreeNode = ({ node, depth = 0 }) => {
    const [expanded, setExpanded] = useState(depth < 2);
    const isFolder = node.type === 'folder';
    const iconInfo = iconMap[node.type] || iconMap.file;

    return React.createElement('div', { style: { marginLeft: `${depth * 16}px` } },
      React.createElement('div', {
        className: 'file-tree__item',
        onClick: isFolder ? () => setExpanded(!expanded) : undefined,
        style: { cursor: isFolder ? 'pointer' : 'default' },
      },
        isFolder && React.createElement('span', {
          className: 'material-icons-round',
          style: { fontSize: '14px', color: 'var(--text-muted)', transition: 'transform 0.15s', transform: expanded ? 'rotate(90deg)' : 'rotate(0)' },
        }, 'chevron_right'),

        React.createElement('span', {
          className: `material-icons-round file-tree__icon ${iconInfo.class}`,
        }, iconInfo.icon),

        React.createElement('span', {
          style: { color: isFolder ? 'var(--color-secondary)' : 'var(--text-primary)' },
        }, node.name),

        node.desc && React.createElement('span', {
          style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-xs)', marginLeft: '8px' },
        }, `— ${node.desc}`)
      ),

      isFolder && expanded && node.children && node.children.map((child, i) =>
        React.createElement(TreeNode, { key: i, node: child, depth: depth + 1 })
      )
    );
  };

  // ルート構造
  const routes = [
    { path: '/', page: 'dashboard', desc: 'ダッシュボード（ホーム画面）' },
    { path: '/map', page: 'map', desc: 'Google Maps + GPS地図表示' },
    { path: '/revenue', page: 'revenue', desc: '売上記録・管理' },
    { path: '/analytics', page: 'analytics', desc: '売上分析・統計' },
    { path: '/settings', page: 'settings', desc: '設定（APIキー設定含む）' },
    { path: '/dev', page: 'dev', desc: '開発者ツールハブ' },
    { path: '/dev/structure', page: 'dev-structure', desc: 'サイト構造ビューア（このページ）' },
    { path: '/dev/logs', page: 'dev-logs', desc: 'アプリケーションログ' },
    { path: '/dev/api-status', page: 'dev-api', desc: 'API接続ステータス' },
  ];

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'account_tree'),
      'サイト構造'
    ),

    // ルーティング一覧
    React.createElement(Card, {
      title: 'ページルーティング',
      subtitle: 'アプリ内のすべてのページとそのパス',
      style: { marginBottom: 'var(--space-lg)' },
    },
      React.createElement('div', { style: { display: 'grid', gap: '4px' } },
        routes.map((route, i) =>
          React.createElement('div', {
            key: i,
            style: {
              display: 'flex',
              alignItems: 'center',
              gap: '12px',
              padding: '8px 12px',
              borderRadius: '6px',
              background: 'rgba(255,255,255,0.02)',
              fontSize: 'var(--font-size-sm)',
            },
          },
            React.createElement('code', {
              style: { color: 'var(--color-primary-light)', fontFamily: 'monospace', minWidth: '160px' },
            }, route.path),
            React.createElement('span', {
              style: { color: 'var(--text-muted)', fontSize: '14px' },
            }, '→'),
            React.createElement('span', { style: { color: 'var(--text-secondary)' } }, route.desc)
          )
        )
      )
    ),

    // ファイルツリー
    React.createElement(Card, {
      title: 'ファイル構造',
      subtitle: 'プロジェクトのディレクトリ構造（クリックで展開/折りたたみ）',
    },
      React.createElement('div', { className: 'file-tree', style: { padding: '8px 0' } },
        React.createElement(TreeNode, { node: APP_CONSTANTS.SITE_STRUCTURE })
      )
    ),

    // コンポーネント依存関係
    React.createElement(Card, {
      title: 'コンポーネント階層',
      subtitle: 'Reactコンポーネントのツリー構造',
      style: { marginTop: 'var(--space-lg)' },
    },
      React.createElement('pre', {
        style: {
          fontFamily: 'monospace',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--text-secondary)',
          lineHeight: 1.8,
          overflowX: 'auto',
        },
      },
`App
├── AppProvider (グローバル状態)
│   ├── MapProvider (地図状態)
│   │   └── LogProvider (ログ状態)
│   │       └── Layout
│   │           ├── Header (ヘッダー)
│   │           ├── Sidebar (PC用サイドバー)
│   │           ├── BottomNav (モバイル用ナビ)
│   │           └── [CurrentPage]
│   │               ├── DashboardPage
│   │               ├── MapViewPage
│   │               │   ├── GoogleMapView
│   │               │   └── GpsTracker
│   │               ├── RevenuePage
│   │               ├── AnalyticsPage
│   │               ├── SettingsPage
│   │               └── DevToolsPage
│   │                   ├── StructurePage
│   │                   ├── LogsPage
│   │                   └── ApiStatusPage
`)
    )
  );
};

})();

// ============================================================
// FILE: src/pages/dev/ApiStatus.jsx
// ============================================================
(function() {
// ApiStatus.jsx - API接続ステータスページ
window.ApiStatusPage = () => {
  const { useState, useEffect } = React;
  const { apiKey } = useAppContext();
  const { isTracking, currentPosition } = useMapContext();

  const [checks, setChecks] = useState([]);

  useEffect(() => {
    const results = [
      {
        name: 'Google Maps JavaScript API',
        status: apiKey ? (window.google && window.google.maps ? 'connected' : 'error') : 'not_configured',
        detail: apiKey
          ? (window.google && window.google.maps ? '正常に読み込まれています' : 'APIの読み込みに失敗しました')
          : 'APIキーが設定されていません（設定画面で入力してください）',
        icon: 'map',
      },
      {
        name: 'Geolocation API (GPS)',
        status: 'geolocation' in navigator ? 'connected' : 'error',
        detail: 'geolocation' in navigator
          ? (isTracking ? `追跡中 (${currentPosition ? `${currentPosition.lat.toFixed(4)}, ${currentPosition.lng.toFixed(4)}` : '取得中...'})` : '利用可能（追跡停止中）')
          : 'このブラウザはGeolocation APIに対応していません',
        icon: 'gps_fixed',
      },
      {
        name: 'localStorage',
        status: (() => { try { localStorage.setItem('_test', '1'); localStorage.removeItem('_test'); return 'connected'; } catch { return 'error'; } })(),
        detail: (() => { try { localStorage.setItem('_test', '1'); localStorage.removeItem('_test'); return '正常に動作しています'; } catch { return 'localStorageが利用できません'; } })(),
        icon: 'storage',
      },
      {
        name: 'Service Worker (PWA)',
        status: 'serviceWorker' in navigator ? 'available' : 'not_available',
        detail: 'serviceWorker' in navigator ? '利用可能（未登録）' : 'このブラウザはService Workerに対応していません',
        icon: 'install_mobile',
      },
      {
        name: 'HTTPS',
        status: location.protocol === 'https:' ? 'connected' : 'warning',
        detail: location.protocol === 'https:'
          ? 'HTTPS接続です'
          : `HTTP接続です（${location.protocol}）。GPSやPWAにはHTTPSが必要な場合があります`,
        icon: 'lock',
      },
    ];

    setChecks(results);
  }, [apiKey, isTracking, currentPosition]);

  const statusIcon = (status) => {
    switch (status) {
      case 'connected': return { icon: 'check_circle', color: 'var(--color-accent)' };
      case 'error': return { icon: 'error', color: 'var(--color-danger)' };
      case 'warning': return { icon: 'warning', color: 'var(--color-warning)' };
      case 'not_configured': return { icon: 'settings', color: 'var(--color-warning)' };
      default: return { icon: 'help', color: 'var(--text-muted)' };
    }
  };

  const statusBadge = (status) => {
    switch (status) {
      case 'connected': return 'badge--success';
      case 'error': return 'badge--error';
      case 'warning': return 'badge--warning';
      case 'not_configured': return 'badge--warning';
      default: return 'badge--info';
    }
  };

  const statusLabel = (status) => {
    switch (status) {
      case 'connected': return '接続済み';
      case 'error': return 'エラー';
      case 'warning': return '警告';
      case 'not_configured': return '未設定';
      case 'available': return '利用可能';
      default: return '不明';
    }
  };

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'cloud'),
      'API接続状態'
    ),

    // ステータス一覧
    React.createElement('div', { style: { display: 'grid', gap: 'var(--space-md)' } },
      checks.map((check, i) => {
        const si = statusIcon(check.status);
        return React.createElement(Card, { key: i },
          React.createElement('div', { style: { display: 'flex', alignItems: 'flex-start', gap: '16px' } },
            React.createElement('span', {
              className: 'material-icons-round',
              style: { fontSize: '32px', color: si.color },
            }, check.icon),
            React.createElement('div', { style: { flex: 1 } },
              React.createElement('div', { style: { display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' } },
                React.createElement('span', { style: { fontWeight: 500 } }, check.name),
                React.createElement('span', { className: `badge ${statusBadge(check.status)}` },
                  React.createElement('span', { className: 'material-icons-round', style: { fontSize: '12px' } }, si.icon),
                  statusLabel(check.status)
                )
              ),
              React.createElement('div', {
                style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)' },
              }, check.detail)
            )
          )
        );
      })
    ),

    // ブラウザ情報
    React.createElement(Card, {
      title: 'ブラウザ環境',
      style: { marginTop: 'var(--space-lg)' },
    },
      React.createElement('div', { style: { display: 'grid', gap: '8px', fontSize: 'var(--font-size-sm)' } },
        [
          ['ユーザーエージェント', navigator.userAgent.substring(0, 80) + '...'],
          ['プラットフォーム', navigator.platform || 'N/A'],
          ['言語', navigator.language],
          ['オンライン', navigator.onLine ? 'はい' : 'いいえ'],
          ['画面サイズ', `${window.innerWidth} x ${window.innerHeight}`],
          ['デバイスピクセル比', window.devicePixelRatio],
          ['React バージョン', React.version],
        ].map(([label, value], i) =>
          React.createElement('div', {
            key: i,
            style: { display: 'flex', justifyContent: 'space-between', padding: '4px 0', borderBottom: '1px solid rgba(255,255,255,0.04)' },
          },
            React.createElement('span', { style: { color: 'var(--text-muted)' } }, label),
            React.createElement('span', { style: { fontFamily: 'monospace', textAlign: 'right', maxWidth: '60%', overflow: 'hidden', textOverflow: 'ellipsis' } }, String(value))
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/pages/dev/DevTools.jsx
// ============================================================
(function() {
// DevTools.jsx - 開発者ツールハブ
window.DevToolsPage = () => {
  const { navigate } = useAppContext();
  const { logs } = useLogContext();

  const tools = [
    {
      id: 'dev-structure',
      title: 'サイト構造',
      desc: 'ファイル構造、ルーティング、コンポーネント階層を確認',
      icon: 'account_tree',
      color: 'var(--color-primary-light)',
      badge: null,
    },
    {
      id: 'dev-logs',
      title: 'ログビューア',
      desc: 'アプリケーションのリアルタイムログを確認・検索',
      icon: 'terminal',
      color: 'var(--color-accent)',
      badge: `${logs.length} 件`,
    },
    {
      id: 'dev-api',
      title: 'API接続状態',
      desc: 'Google Maps API、GPS、ブラウザAPIの接続状態を確認',
      icon: 'cloud',
      color: 'var(--color-secondary)',
      badge: null,
    },
  ];

  return React.createElement('div', null,
    React.createElement('h1', { className: 'page-title' },
      React.createElement('span', { className: 'material-icons-round' }, 'code'),
      '開発者ツール'
    ),

    React.createElement('p', {
      style: { color: 'var(--text-secondary)', marginBottom: 'var(--space-lg)', fontSize: 'var(--font-size-sm)' },
    }, 'アプリの内部構造やログ、API接続状態を確認できます。生成AIでの開発時にこのページを参照してください。'),

    // ツール一覧
    React.createElement('div', { className: 'grid grid--3' },
      tools.map(tool =>
        React.createElement(Card, {
          key: tool.id,
          onClick: () => navigate(tool.id),
          style: { cursor: 'pointer', textAlign: 'center', padding: 'var(--space-xl)' },
        },
          React.createElement('span', {
            className: 'material-icons-round',
            style: { fontSize: '48px', color: tool.color, marginBottom: '12px' },
          }, tool.icon),
          React.createElement('div', { style: { fontWeight: 700, marginBottom: '8px' } }, tool.title),
          React.createElement('div', {
            style: { fontSize: 'var(--font-size-sm)', color: 'var(--text-secondary)', marginBottom: '8px' },
          }, tool.desc),
          tool.badge && React.createElement('span', { className: 'badge badge--info' }, tool.badge)
        )
      )
    ),

    // 最新ログプレビュー
    React.createElement(Card, {
      title: '最新ログ（直近5件）',
      style: { marginTop: 'var(--space-lg)' },
    },
      logs.length === 0
        ? React.createElement('div', { style: { color: 'var(--text-muted)', fontSize: 'var(--font-size-sm)' } }, 'ログはまだありません')
        : [...logs].reverse().slice(0, 5).map(log =>
            React.createElement('div', { key: log.id, className: 'dev-log-entry' },
              React.createElement('span', { className: 'dev-log-entry__time' },
                new Date(log.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit', second: '2-digit' })
              ),
              React.createElement('span', { className: `dev-log-entry__level dev-log-entry__level--${log.level}` },
                log.level.toUpperCase()
              ),
              React.createElement('span', { className: 'dev-log-entry__message' }, log.message)
            )
          ),
      logs.length > 5 && React.createElement(Button, {
        variant: 'secondary',
        icon: 'arrow_forward',
        onClick: () => navigate('dev-logs'),
        style: { marginTop: 'var(--space-md)' },
      }, 'すべてのログを表示')
    ),

    // クイック情報
    React.createElement(Card, {
      title: 'プロジェクト情報',
      style: { marginTop: 'var(--space-lg)' },
    },
      React.createElement('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px', fontSize: 'var(--font-size-sm)' } },
        [
          ['フレームワーク', `React ${React.version}`],
          ['ビルド', 'CDN (Babel トランスパイル)'],
          ['地図', 'Google Maps JavaScript API'],
          ['バージョン', APP_CONSTANTS.VERSION],
          ['GPS', 'Geolocation API'],
          ['レスポンシブ', 'PC / タブレット / Android'],
        ].map(([k, v], i) =>
          React.createElement('div', { key: i },
            React.createElement('span', { style: { color: 'var(--text-muted)' } }, `${k}: `),
            React.createElement('span', null, v)
          )
        )
      )
    )
  );
};

})();

// ============================================================
// FILE: src/App.jsx
// ============================================================
(function() {
// App.jsx - ルートコンポーネント（ハッシュルーティング対応）
window.App = () => {
  const { currentPage, navigate } = useAppContext();

  // レガシー: カスタムイベントでのナビゲーション対応（後方互換性）
  React.useEffect(() => {
    const handler = (e) => navigate(e.detail);
    document.addEventListener('navigate', handler);
    return () => document.removeEventListener('navigate', handler);
  }, [navigate]);

  // ページルーティング（useMemoで不要な再生成を防止）
  const page = React.useMemo(() => {
    switch (currentPage) {
      case 'dashboard': return React.createElement(DashboardPage);
      case 'map': return React.createElement(MapViewPage);
      case 'revenue': return React.createElement(RevenuePage);
      case 'rival-ride': return React.createElement(RivalRidePage);
      case 'transit-info': return React.createElement(TransitInfoPage);
      case 'events': return React.createElement(EventsPage);
      case 'analytics': return React.createElement(AnalyticsPage);
      case 'calendar': return React.createElement(CalendarPage);
      case 'info': return React.createElement(InfoPage);
      case 'data-manage': return React.createElement(DataManagePage);
      case 'settings': return React.createElement(SettingsPage);
      case 'dev': return React.createElement(DevToolsPage);
      case 'dev-logs': return React.createElement(LogsPage);
      case 'dev-structure': return React.createElement(StructurePage);
      case 'dev-api': return React.createElement(ApiStatusPage);
      default: return React.createElement(DashboardPage);
    }
  }, [currentPage]);

  return React.createElement(Layout, null, page);
};

})();

// ============================================================
// FILE: src/main.jsx
// ============================================================
(function() {
// main.jsx - エントリーポイント（TaxiApp名前空間登録 + アプリ起動）
(() => {
  // ============================================================
  // TaxiApp 名前空間にすべてのグローバルを整理
  // window.XXX は後方互換のために残すが、正規の参照先は TaxiApp
  // ============================================================
  const T = window.TaxiApp;

  // Utils
  T.utils.constants = APP_CONSTANTS;
  T.utils.logger = AppLogger;
  T.utils.storage = AppStorage;
  T.utils.dataService = DataService;
  T.utils.geminiService = GeminiService;

  // Contexts
  T.contexts.AppContext = AppContext;
  T.contexts.AppProvider = AppProvider;
  T.contexts.MapContext = MapContext;
  T.contexts.MapProvider = MapProvider;
  T.contexts.LogContext = LogContext;
  T.contexts.LogProvider = LogProvider;

  // Hooks
  T.hooks.useAppContext = useAppContext;
  T.hooks.useMapContext = useMapContext;
  T.hooks.useLogContext = useLogContext;
  T.hooks.useGeolocation = useGeolocation;
  T.hooks.useGoogleMaps = useGoogleMaps;
  T.hooks.useLogger = useLogger;

  // Components
  T.components.Loading = Loading;
  T.components.Card = Card;
  T.components.Button = Button;
  T.components.ErrorBoundary = ErrorBoundary;
  T.components.Header = Header;
  T.components.Sidebar = Sidebar;
  T.components.BottomNav = BottomNav;
  T.components.Layout = Layout;
  T.components.GoogleMapView = GoogleMapView;
  T.components.GpsTracker = GpsTracker;
  T.components.MapControls = MapControls;
  T.components.TrafficLegend = TrafficLegend;

  // Pages
  T.pages.Dashboard = DashboardPage;
  T.pages.MapView = MapViewPage;
  T.pages.Revenue = RevenuePage;
  T.pages.RivalRide = RivalRidePage;
  T.pages.TransitInfo = TransitInfoPage;
  T.pages.Events = EventsPage;
  T.pages.Analytics = AnalyticsPage;
  T.pages.Settings = SettingsPage;
  T.pages.DevTools = DevToolsPage;
  T.pages.Logs = LogsPage;
  T.pages.Structure = StructurePage;
  T.pages.ApiStatus = ApiStatusPage;

  // App
  T.App = App;

  // ============================================================
  // アプリケーション起動
  // ============================================================
  AppLogger.info('アプリケーション起動中...');
  AppLogger.info(`バージョン: ${APP_CONSTANTS.VERSION}`);
  AppLogger.info(`React バージョン: ${React.version}`);

  const root = ReactDOM.createRoot(document.getElementById('root'));

  root.render(
    React.createElement(ErrorBoundary, null,
      React.createElement(AppProvider, null,
        React.createElement(MapProvider, null,
          React.createElement(LogProvider, null,
            React.createElement(App)
          )
        )
      )
    )
  );

  AppLogger.info('アプリケーション起動完了');
  AppLogger.info(`登録済みコンポーネント: ${Object.keys(T.components).length}個, ページ: ${Object.keys(T.pages).length}個`);
})();

})();

  </script>

  <!-- Service Worker登録 & PWAインストールプロンプト -->
  <script>
  // Service Worker登録
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js')
        .then(reg => {
          console.log('[PWA] Service Worker登録成功:', reg.scope);
          if (window.AppLogger) AppLogger.info('Service Worker登録完了');
        })
        .catch(err => {
          console.warn('[PWA] Service Worker登録失敗:', err);
        });
    });
  }

  // PWAインストールプロンプト
  window._pwaInstallPrompt = null;
  window._pwaInstalled = false;

  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    window._pwaInstallPrompt = e;
    console.log('[PWA] インストールプロンプト利用可能');
    // カスタムイベントで通知
    document.dispatchEvent(new CustomEvent('pwa-install-available'));
  });

  window.addEventListener('appinstalled', () => {
    window._pwaInstalled = true;
    window._pwaInstallPrompt = null;
    console.log('[PWA] アプリがインストールされました');
    if (window.AppLogger) AppLogger.info('PWAインストール完了');
    document.dispatchEvent(new CustomEvent('pwa-installed'));
  });

  // インストール実行関数
  window.triggerPwaInstall = async () => {
    if (!window._pwaInstallPrompt) return { success: false, reason: 'prompt_not_available' };
    try {
      window._pwaInstallPrompt.prompt();
      const result = await window._pwaInstallPrompt.userChoice;
      window._pwaInstallPrompt = null;
      return { success: result.outcome === 'accepted', reason: result.outcome };
    } catch (e) {
      return { success: false, reason: e.message };
    }
  };
  </script>
</body>
</html>
